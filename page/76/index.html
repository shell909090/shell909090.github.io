<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  
  <meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1">

  
    
    
      <link href="/css/fonts.css" rel="stylesheet" type="text/css">
    
  

  
  <title>Shell&#39;s Home</title>

  
  
  <link rel="stylesheet" href="/css/hugo-octopress.css">

  
  

  
    <link rel="stylesheet" href="/css/fork-awesome.min.css">
  

  
  <link href="//blog.shell909090.org/favicon.png" rel="icon">

  
  <link href="//blog.shell909090.org/index.xml" rel="alternate" type="application/rss+xml" title="Shell&#39;s Home" />

  <meta name="description" content="" />
  <meta name="keywords" content="">
  <meta name="author" content="Shell Xu">

  
  <meta name="generator" content="Hugo 0.55.6" />

  
  
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-48816091-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>


  
  
</head>
<body>


<header role="banner">
<hgroup>
  
  <h1><a href="//blog.shell909090.org/">Shell&#39;s Home</a></h1>
    <h2></h2>
</hgroup></header>


<nav role="navigation">
<fieldset class="mobile-nav">
  
  <select onchange="location = this.value;">
    <option value="">Navigate…</option>
      
  </select>
</fieldset>


<ul class="main-navigation">
  
  
</ul>

<ul class="subscription">
  
</ul>


</nav>




  

<div id="main">
  <div id="content">
    <div class="blog-index">
      
      
      <article>
        
        

<header>
  <p class="meta">Jan 13, 2007
     - 1 minute read 
    

    
  </p>
  <h1 class="entry-title">
    <a href="//blog.shell909090.org/blog/archives/347/">构造过程</a>
  </h1>
</header>

        
          <p>在进入正题前，我们首先回顾下我们的基础C++常识。如果调用某个对象的某个方法，那么会调用到什么？
一般来说，如果这个方法是普通函数，则按照这个对象的声明类型去调用。就好像(&amp;obj)-&gt;obj_type::function(param&hellip;);。而如果是虚函数，则是按照这个对象的构造类型去调用。就好像(&amp;obj)-&gt;((&amp;obj)-&gt;_v_ptr[n])(param&hellip;);。或者说简单点，一个是按照这个类看起来像是哪个类来调用，一个是按照这个类实际是哪个类来调用。
那么，如果在一个基类的某个成员里面调用这个类的另外一个虚函数，调用的是哪个呢？
任何正常人来说，都应该说是，按照这个类的构造类型来确定。基本上没错，不过有一个函数例外。
那么先看一个问题。
class B { public: B(){test ();} virtual void test (){printf (&quot;parentn&quot;);} void out (){test ();} }; class D:public B { public: virtual void test (){printf (&quot;childn&quot;);} }; int _tmain(int argc, _TCHAR* argv[]){ D d; d.out(); return 0; }  想像下输出，再运行下。想想为什么，再看下面。想通了就不用看了。
&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;我是无敌的分割线&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;
C++标准规定，任何一个带有虚函数的类都有一个_v_ptr成员，这个成员必须存放在这个类内存地址中头部。这个成员指向了这个类的虚函数表。于是，调用虚函数的时候，我们首先确定这个是虚函数。(按照这个逻辑，如果父类不声明为虚函数，子类重载为虚函数，还是没用的)然后，我们确定这是第几个虚函数(严格来说，这并不符合面对对象的设计规范，应该是按照函数名字查表的，_v_ptr也不应该仅仅指向虚函数表，而应该是类形态表)。最后，我们去虚函数表中取得入口地址进行调用。
那么为什么在构造函数中调用就无法调用子类的虚函数呢？问题在于_v_ptr的初始化时间上。某个类的构造函数启动前，这个类的_v_ptr才能完成初始化。如果是多重继承，那么首先调用最初类的，然后是次类的，最后是子类的。_v_ptr首先指向基类的，再是继承类，最后是子类。我们在父类构造函数中，_v_ptr指针还指向了父类的虚函数表，所以调用不到子类的虚函数。
其实我们可以这么说，构造函数以前，子类不存在。</p>
          
        
      </article>
      
      <article>
        
        

<header>
  <p class="meta">Jan 12, 2007
     - 1 minute read 
    

    
  </p>
  <h1 class="entry-title">
    <a href="//blog.shell909090.org/blog/archives/346/">IDE</a>
  </h1>
</header>

        
          <p>现在真是深深的为IDE所苦啊。
基本来说，现在用的IDE有几种，eclipse，MSVC，Anjuta，MingStudio，Code::Blocks。不过都有毛病。
eclipse好用的很，功能齐全，插件多，支持多，跨平台。可惜开发Java是本行，C就稍微有点小毛病，而且消耗资源太大。MSVC也是功能强大，可惜Linux下面没法用，而且不支持CVS。Anjuta只是Linux下面的开发程序，而且使用了Automake和Autoconf。MingStudio不开源，Code::Blocks编译困难。
不过想想也是，IDE都又好用又免费了，M$要$哪个去？
其中唯一好用点的也就是Code::Blocks了。前两天看一个论坛上说Code::Blocks是针对单语言的，所以要用Anjuta。我立刻喷笑。说起来一个人能会多少语言呢？三种？五种？要真的是多语言，不如用Eclipse或者Emacs。Eclipse支持Java/C++/Php，Emacs配置好了啥都支持。问题是支持多了，效果就差了。Eclipse在支持C++上就和MSVC没的比。
要比较一个IDE，基本来说是比较三个方面，自动写作，生成和版本管理，统一化测试/调试。
自动写作有四个主要方面，自动完成，符号提示，参数提示，自动格式化。说明白点，自动完成，就是使用某个范围的某个东西，例如变量或者方法。在写好范围(例如对象名或者类名)后会提示这个东西的名字。好比写了::Messa就基本可以自动给出::MessageBox。符号提示则更加智能些，在写作的时候自动判断当前最可能使用的对象并且给出提示。参数提示是指调用函数的时候提示应该传入的参数类型和个数，当然也有自动将最可能的变量传入的例子。自动格式化，就是乱糟糟的代码自动格式整齐。针对C++来说，MSVC可以自动完成，符号提示，参数提示，外挂插件可以自动格式化。Eclipse可以自动完成，参数提示(这就是那个自动填写最可能参数的例子)，外挂插件可以自动格式化。Anjuta和Code::Blocks没用过，不过Code::Blocks可以外挂插件格式化。
生成和版本管理来说，MSVC，Code::Blocks和Eclipse用的是自身的格式，脱离了IDE基本就没用了。Anjuta用的是Autoconf和Automake，即使没有IDE也可以编译。便于跨语言和发行原码包。
统一化测试/调试来说，基本都有行调试的功能，不过都不带测试工具的。</p>
          
        
      </article>
      
      <article>
        
        

<header>
  <p class="meta">Jan 11, 2007
     - 1 minute read 
    

    
  </p>
  <h1 class="entry-title">
    <a href="//blog.shell909090.org/blog/archives/345/">用户和软件制造商的博弈</a>
  </h1>
</header>

        
          <p>作为用户来说，软件越便宜越好。制造商来说，越贵越好。
软件的价格和很多因素相关，生产基础成本，市场竞争，应用市场，技术含量。不过我们今天分析三种因素，服务，技术和市场。
软件的价格中，有很大一部分是用于服务的。大致上包括客户服务费用，安全保证费用(例如出现产品造成客户损失等等)，软件升级和维护费用。免费软件和收费软件在这方面区别最大，收费软件自然可以做好(应该说是必须做好)服务，免费软件也可以做好服务。但是免费软件既然是免费的，让我免费写了大家用我不介意，反正没人用也是浪费，有人用还可扬名。但是还要提供服务，恐怕没人乐意了。所以免费软件的服务基本都是空白，或者是收费的(例如apache的文档)。这个因素基本和我们今天讨论的主题不相关，只是讨厌于某些厂商的服务质量有感而发。
市场的领域和含义非常复杂，大致上领域包括了某个产品理论可以用于的领域和当前用于的领域。理论上说记事本可以用于超大的程序开发，实际上你看到有人在用记事本写代码吗？含义的话，市场不仅仅是一个可用的范围，还应当包括所有用户和所有竞争对手，以及所有人的互相关系和当前状态。其实这已经是非常简化的状况了，软件的市场远远没有传统行业来的大，但是复杂程度却尤有甚之。美国的一个农民可能出售牛肉到日本，中国的一个农民也可能出售牛肉到日本。但是这两个农民互相间不认识，他们不构成直接的竞争动力。他们的代理出售者可能竞价，但是他们本人基本不可能调整自己的产品(当然，我也想像不出来牛肉可以怎么调整——除去中国某些恶心商人的手段外)。然而美国的一个公司卖软件到日本，中国公司也卖，他们一定认识，而且会根据对手行为和当前处境，以及客户状态来调整他们的产品。
最后一个是竞争的关键，技术。这里讨论的是广义上的技术，即抛却含量，纯粹从跑马圈地的角度来讲。如果讲技术的发展性，那最好大家公开所有技术内幕，不过看来不可能的。
技术的意义在于做别人不能做的事情。windows的进程管理器不能显示用户加载模块，sysinternals的就可以。这就是技术。有技术就有仿制。为了保持技术，一般有两种方法。一种是持续研发，成本高，但是优势十足。还有就是专利，恶心人的无奈东西。
如果说技术只是单纯能或者不能的问题，结合到市场上就有复杂的变化。最重要的一种就是利用技术特性来占领市场。如果某个产品是开放的，例如开放标准，出售代码。就可能出现很多不准确的免费仿制品。这些仿制品的大量应用奠定了这个产品的基础，使得产品具备非常大的市场和价值。然而市场，准确的说是用户，是具备产品粘着度的。也就是说，如果喜欢一个产品，就会一直使用这个产品。如果一个产品不具备粘着度，那就完全的没有价值了。因为他的用户随时都会转变为别人的。培育市场，就是培育大量的用户，并且使得他们具备高的粘着度。技术上说，存在这么一种情况，专利A，开放标准，出售研发代码(SDK)。专利B，封闭标准，出售研发代码，但是兼容专利A。那么专利B的产品会给客户一种导向，就是B比A更好。如果价格一样的话，我们不难想像客户的选择。这样的话A不仅仅是流失客户的问题，而且在后续产品上，用户会有惊人的粘着度。一直都是B专利兼容A专利，一直被压了打。
理论上这样会导致大家不愿意在核心格式上开放标准，然而标准的开放会带来非常广阔的兼容性好处。例如著名的开放标准XML，从技术角度讲几乎就没有什么难以理解的高级技术。然而这个标准本身却是伟大的发明。所以比较流行的方式应当是授权标准，标准是免费的，但是是授权的。如果在此上面衍生变化必须得到标准化委员会的认可，然而其中还是有很大问题的。例如微软就变更了java的标准，并且在事实上(虽然从来不承认)变更了html的标准。IE可以浏览标准的html，但是标准的html浏览器却不能浏览IE的格式。由此可以看出各个生产厂商在专利上的竞争方式。
作为厂商来讲，最好的运作模式是没实力兼容标准，这样用户觉得你功能强大。有实力就修改标准，这样可以养成用户粘着度。然而在用户看来，最好选择仅仅使用最开放最便宜的标准的软件。虽然这样会在使用中造成不便。然而却杜绝了大厂商篡改标准圈地的可能，在用户和软件公司博弈的时候获得更大的优势。</p>
          
        
      </article>
      
      <article>
        
        

<header>
  <p class="meta">Jan 10, 2007
     - 1 minute read 
    

    
  </p>
  <h1 class="entry-title">
    <a href="//blog.shell909090.org/blog/archives/344/">code2dia和cpp2dia</a>
  </h1>
</header>

        
          <p>前两天找自动化工具，发现两个工具，叫dia2code和cpp2dia。两个都已经玩过了，还不错。这两个工具是基于UML的建模工具，和IBM Retional有异曲同工之妙，只是没有那么完整好用而已。
dia是一种矢量图编辑工具，其中包含了UML模块。不过只有UML图的建模工具是不完整的，dia2code可以将UML转换成多种语言的定义文件，其中包括了C++和java(我也就要这两种就够了)。画出关系图后，一条指令就可以自动生成代码框架，套用indent格式一把就可以拿来写了(java的话自然是eclipse)。美中不足的是，如果生成代码框架可以自动扩充就好了。例如当前我已经在某个框架上写了代码，然后发现要添加一个函数。难道还要重生成一遍，然后再Ctrl+C,Ctrl+V吗？回头估计要写一个程序来解决这个问题。
cpp2dia到是可以部分的解决这个问题。如果说dia2code是以UML模型为基础，cpp2dia就是以程序代码为基础。cpp2dia可以从代码中生成出dia模型来(当然，看名字就知道，只支持C++)。如果要添加函数，尽管修改代码，回头重新生成dia就是。不过这个毕竟不是比较完美的解决方案。
我做了一个测试。画了一个图形a.dia，然后用dia2code生成一堆框架。拿框架去套cpp2dia，结果出来一个output.dia。output.dia和a.dia拓朴结构一致，但是位置就差很多了(这也没办法)。最后用output.dia生成框架，生成结果和原来框架完全一致。
这两个工具的意义，在于编写代码的同时，可以清晰的看到代码的相互关系。代码写好了，文档也自然有了。UML图在手里面，代码自然也好写多了。同类的解决方案有IBM的Retional，Sun的JavaStudio，Microsoft的Visio，虽然都是要收费的，而且是白花花的银子啊～～～</p>
          
        
      </article>
      
      <article>
        
        

<header>
  <p class="meta">Jan 8, 2007
     - 1 minute read 
    

    
  </p>
  <h1 class="entry-title">
    <a href="//blog.shell909090.org/blog/archives/343/">超级牛力</a>
  </h1>
</header>

        
          <p>用过debian的朋友，在用apt-get和aptitude的时候会发现有句声明。
#aptitude --help ... 这个 aptitude 没有超级牛力。 #apt-get --help ... 本 APT 有着超级牛力。  什么是超级牛力呢？
超級牛力是 Debian 系統中一股神秘的力量。
/*
..暴打ing..
*/
其实说明白点，超级牛力就是一个彩蛋。详细可以参看SuperCowPowers。
$ apt-get moo (__) (oo) /------/ / | || * /---/ ~~ ~~ ....&quot;Have you mooed today?&quot;... $ apt-build moo (__) ~ (oo) / _____/___/ / / / / ~ / * / / ___/ *----/ / / / ~ ~ ...&quot;Have you danced today ? Discow !&quot;... $ aptitude moo 此軟體沒有復活節彩蛋程式。 $ aptitude -v moo 此軟體真的沒有復活節彩蛋程式。 $ aptitude -vv moo 我不是已經告訴你這個軟體真的沒有復活節彩蛋程式了嗎?</p>
          
            <footer>
              <a href="//blog.shell909090.org/blog/archives/343/" rel="full-article">Read On &rarr;</a>
            </footer>
          
        
      </article>
      
      <article>
        
        

<header>
  <p class="meta">Jan 5, 2007
     - 1 minute read 
    

    
  </p>
  <h1 class="entry-title">
    <a href="//blog.shell909090.org/blog/archives/342/">中国的出国网络断了</a>
  </h1>
</header>

        
          <p>同志们，由于人力不可抗拒因素(中国的出国网络海底光缆给地震震断了)，所以我的blog不定期更新。
敬请耐心等待。</p>
          
        
      </article>
      
      <article>
        
        

<header>
  <p class="meta">Dec 26, 2006
     - 1 minute read 
    

    
  </p>
  <h1 class="entry-title">
    <a href="//blog.shell909090.org/blog/archives/341/">getline的效率问题</a>
  </h1>
</header>

        
          <p>用过C++的肯定都知道getline(cin, str)这个用法吧，用于将某行读入到一个字符串对象中。但是根据我的测试，这个方法有严重的效率问题。
正则表达式行匹配器，匹配一个23M文件。用getline的总运行时间是21秒，用直接文件读取方法只有7秒。getline方法在屏蔽对读入数据的正则匹配后还运行了9秒上下。这里有人可能弄不懂，即使读取不用时间，getline花费的时间加正则运算时间不应该是总时间吗？结论是不是的，因为多个接口上下调用需要时间，str对象得到指针需要时间。所以其中还有一些时间差。不过getline方法效率差是显而易见的。
原因在于istream的类型和行的长度。我们是从文件中读取的，一次获得一个字符的取得的。ifstream应该没有弱智到一次只ReadFile一个字节，估计是用了1-4K的缓冲簇。对于大型文件，这个缓冲簇应该越大效率越高。但是stream不会知道输入流的长度，所以——
而且即使知道了，50W个byte就是50W次call调用，花多少时间自己考虑吧。
还有一个是string类型的问题。getline istream一般都是用string作为接收对象的，因为string几乎可以无限制的接收。在STL的实现中，string是vector一样的连续块分配。当长度超出的时候，就必须重新分配，然后复制数据，删除原先块。因此STL中建议给string对象reserve一个块来提高效率。不过getline开始的时候会earse string对象，可能在这里面保留区域就被OOXX了——
所以在大规模数据处理中，还是手来吧。</p>
          
        
      </article>
      
      <article>
        
        

<header>
  <p class="meta">Dec 22, 2006
     - 3 minute read 
    

    
  </p>
  <h1 class="entry-title">
    <a href="//blog.shell909090.org/blog/archives/340/">EPS转BMP和代码优化</a>
  </h1>
</header>

        
          <p>EPS转BMP(我用的是PNG，不过还是一回事情)。EPS内部有两种图片，一个是TIF，位置和大小在头32个字节中描述。具体可以看EPS文档，在lp[5]保存位置，lp[6]保存大小。还有就是%%BeginBinary:
后面跟一个大小，然后跟beginimagex0D。在前文中应当有大小，自己找找看去，最后是一堆数据。存放方法是一位一位的像素连续存放，先存放一行C，然后是一行M，然后是Y，然后是K。当这4者全部存放完后，向后跳空一端区域，到本行开始的4字节对齐处，开始下一行的存放。
例如3个像素宽的图片(好简单——)存放方法就是，在0字节的最高三位(7,6,5位)，存放了这三个像素的C值。次三位(4,3,2位)，存放了M值。然后Y值存放在0字节的两位(1,0位)和1字节的一位(7位)。最后K值存放在1字节的次三位(6,5,4位)。然后跳空对齐，在4字节的位置开始描述下一行。
了解这个过程了，就应该发现，要转换到BMP需要大量的位操作。前置过程不说了，假定数据在内存里面(我当然不会用读取这种方法，用的是文件内存映射啦)，然后目标是GDI+的BitmapData对象。
BYTE getBit (PBYTE lpInData, int bit) { bit*=n; BYTE rslt; rslt = lpInData[bit / 8]; rslt &gt;&gt;= (7 - bit % 8); return rslt &amp; 0x1; } for (y = 0; y &lt; tgtData.Height; y++) { line_start = lpOut + l * n * Stride; for (x = 0; x &lt; tgtData.Width; x++) { c = 1 - getBit (line_start, x); m = 1 - getBit (line_start, x + tgtData.</p>
          
            <footer>
              <a href="//blog.shell909090.org/blog/archives/340/" rel="full-article">Read On &rarr;</a>
            </footer>
          
        
      </article>
      
      <article>
        
        

<header>
  <p class="meta">Dec 21, 2006
     - 4 minute read 
    

    
  </p>
  <h1 class="entry-title">
    <a href="//blog.shell909090.org/blog/archives/339/">正则表达式解析文本</a>
  </h1>
</header>

        
          <p>最近碰到这么个问题，一个文本，每行都是乱糟糟的东西，要从里面解析出东西来。行匹配铁定是用正则表达式，我用了Boost，不会的看我前两天的blog去。
下面是按行解析问题。简单来说，写一个类继承Lister，然后实现里面的三个纯虚方法。maxSeqence返回最大可以支持的表达式，registe_regex返回表达式文本，seqenceProcess返回相应函数的指针。其实可以写成直接调用seqenceProcess加上匹配序号，然后让用户在函数内部做switch-case的。不过这样用户代码量稍微有点多，所以干脆玩一把技术。然后是几个非纯虚函数，nextSeqence可以根据当前状态来控制下一个要匹配的表达式，默认是+1，一个一个全部匹配。beforeProcess和afterProcess分别是处理前后，可以调整输入流。noMatch是一个比较常用的虚函数，用于响应没有匹配时的状态。
匹配的结果在cmatch &amp; what中，详细请看boost::regex。不过what[0].str()可以获得整句的string型返回，what[1]开始就是正则的匹配结果。
&mdash;&mdash;&mdash;2006-12-25&mdash;&mdash;&mdash;&mdash;&mdash;
原来的结果删除，我重写了一个。
主要有两个问题，一个是getline的效率问题，我会撰文说明的。还有就是两处细节不大好。
为了修正这两个问题，我突然发现整个的构架不大好了——怎么办？重写吧——
下面是新的，一个类line_regex，直接继承就好。line_buffer是用于解决getline效率不高的问题的，当然我偷了个懒，实现代码用了WIN32API，所以是不可移植的。而且数据是一次读取，最多256M。不过相信这种级别的问题还难不倒大家。line_buffer类中的函数都很清晰明了，就不介绍了。
Process (tistream &amp; is)和Process (line_buffer &amp; lb)是两大入口，同时支持自有的输入方法和流输入。当然流输入清晰明了标准化程度高。不过效率差的一塌糊涂。继承类初始化的时候，记得设置pfTable为入口列表，然后调用注册函数完成注册。nextSeqence和上面一样，可以定制下一个匹配式。noMatch用于无匹配的时候。beforeProcess和afterProcess分别会在某行开始和结束匹配后用，返回-1结束运行。其中beforeProcess返回正数会导致本行跳过，可以作为过滤器。
---------------------LineRegex.h-------------------- #include #include #include #include #include #include #include using namespace std; using namespace boost; typedef basic_stringtstring; typedef basic_regextregex; typedef match_resultstmatch; typedef basic_istream &gt;tistream; #ifndef_LINE_REGEX_H_ #define_LINE_REGEX_H_ class line_regex; typedef int (line_regex::*ProcessFunction) (const tmatch &amp; what, int line); class line_buffer { public: line_buffer(); ~line_buffer(); intopen(LPCTSTR lpPath); voidclose(); LPTSTRgetline(); longsize(); protected: UINTFileSize; LPVOIDlpFile; TCHAR *lpNow, *lpNext; }; class line_regex { public: line_regex(); ~line_regex(); virtualintnextSeqence(int seqence); virtual intnoMatch(LPTSTR strLine, int line); virtual int beforeProcess (LPTSTR strLine, int line); virtual int afterProcess (LPTSTR strLine, int line); voidregiste_expression(LPCTSTRexps[]); int Process (tistream &amp; is); int Process (line_buffer &amp; lb); protected: intProcessLine(LPTSTR strLine, int line); longmaxSeqence; ProcessFunction*pfTable; tregex*expressions; tmatchwhat; }; #endif//_LINE_REGEX_H_ ---------------------------------------------------- ----------------------LineRegex.</p>
          
            <footer>
              <a href="//blog.shell909090.org/blog/archives/339/" rel="full-article">Read On &rarr;</a>
            </footer>
          
        
      </article>
      
      <article>
        
        

<header>
  <p class="meta">Dec 20, 2006
     - 6 minute read 
    

    
  </p>
  <h1 class="entry-title">
    <a href="//blog.shell909090.org/blog/archives/338/">windows service的C&#43;&#43;封装实现</a>
  </h1>
</header>

        
          <p>windows系统服务入口的封装类，service是基类，service_manager是管理类。支持UNICODE，可以多服务封装在一个程序里面，过程当然都是自动的。拥有自动防错系统，在服务异常退出的时候会去关闭服务，而不是开着服务直接没了进程。写一个类，继承service，然后在哪里出一个实例，就可以了。service中有很多虚函数，可以重载了监听对应事件(我应该写的比较明白吧)。get_service_name，返回UNICODE的字符串指针，定义服务名称。注意是纯虚函数，必须实现。get_dependence，也是返回UNICODE的字符指针。指明这个服务依赖什么服务。get_service_type返回服务类型，其实也就是是否可以交互。get_contral_accepts，支持的信号(例如是否可以暂停)，默认可以暂停。on_start开始时候调用的函数，下同。
使用方法
#include #include &quot;service.h&quot; class test_service : public service{ public: virtual LPTSTRget_service_name (); virtual DWORD on_start (DWORD argc, LPTSTR * argv); virtual DWORD on_stop (); virtual DWORD on_shutdown (); }; LPTSTR test_service::get_service_name () { return _T (&quot;test_service&quot;); } DWORD test_service::on_start (DWORD argc, LPTSTR * argv) { return service::on_start (argc, argv); } DWORD test_service::on_stop () { return service::on_stop (); } DWORD test_service::on_shutdown () { return service::on_shutdown (); } int _tmain (int argc, _TCHAR * argv[]) { test_service ts; if (argc == 1) service_manager::start (); else if (!</p>
          
            <footer>
              <a href="//blog.shell909090.org/blog/archives/338/" rel="full-article">Read On &rarr;</a>
            </footer>
          
        
      </article>
      
      
      






<div class="pagination">

    
        
        
        
        <a href="/" aria-label="First" class="label-pagination"><i class="fa fa-angle-double-left fa-lg"></i></a>
    

    
    
        <a href="/page/75/" aria-label="Previous" class="label-pagination"><i class="fa fa-angle-left fa-lg"></i></a>
    

    
        <a href="/" class="label-pagination">1</a>
    
        <a href="/page/2/" class="label-pagination">2</a>
    
        <a href="/page/3/" class="label-pagination">3</a>
    
        <a href="/page/4/" class="label-pagination">4</a>
    
        <a href="/page/5/" class="label-pagination">5</a>
    
        <a href="/page/6/" class="label-pagination">6</a>
    
        <a href="/page/7/" class="label-pagination">7</a>
    
        <a href="/page/8/" class="label-pagination">8</a>
    
        <a href="/page/9/" class="label-pagination">9</a>
    
        <a href="/page/10/" class="label-pagination">10</a>
    
        <a href="/page/11/" class="label-pagination">11</a>
    
        <a href="/page/12/" class="label-pagination">12</a>
    
        <a href="/page/13/" class="label-pagination">13</a>
    
        <a href="/page/14/" class="label-pagination">14</a>
    
        <a href="/page/15/" class="label-pagination">15</a>
    
        <a href="/page/16/" class="label-pagination">16</a>
    
        <a href="/page/17/" class="label-pagination">17</a>
    
        <a href="/page/18/" class="label-pagination">18</a>
    
        <a href="/page/19/" class="label-pagination">19</a>
    
        <a href="/page/20/" class="label-pagination">20</a>
    
        <a href="/page/21/" class="label-pagination">21</a>
    
        <a href="/page/22/" class="label-pagination">22</a>
    
        <a href="/page/23/" class="label-pagination">23</a>
    
        <a href="/page/24/" class="label-pagination">24</a>
    
        <a href="/page/25/" class="label-pagination">25</a>
    
        <a href="/page/26/" class="label-pagination">26</a>
    
        <a href="/page/27/" class="label-pagination">27</a>
    
        <a href="/page/28/" class="label-pagination">28</a>
    
        <a href="/page/29/" class="label-pagination">29</a>
    
        <a href="/page/30/" class="label-pagination">30</a>
    
        <a href="/page/31/" class="label-pagination">31</a>
    
        <a href="/page/32/" class="label-pagination">32</a>
    
        <a href="/page/33/" class="label-pagination">33</a>
    
        <a href="/page/34/" class="label-pagination">34</a>
    
        <a href="/page/35/" class="label-pagination">35</a>
    
        <a href="/page/36/" class="label-pagination">36</a>
    
        <a href="/page/37/" class="label-pagination">37</a>
    
        <a href="/page/38/" class="label-pagination">38</a>
    
        <a href="/page/39/" class="label-pagination">39</a>
    
        <a href="/page/40/" class="label-pagination">40</a>
    
        <a href="/page/41/" class="label-pagination">41</a>
    
        <a href="/page/42/" class="label-pagination">42</a>
    
        <a href="/page/43/" class="label-pagination">43</a>
    
        <a href="/page/44/" class="label-pagination">44</a>
    
        <a href="/page/45/" class="label-pagination">45</a>
    
        <a href="/page/46/" class="label-pagination">46</a>
    
        <a href="/page/47/" class="label-pagination">47</a>
    
        <a href="/page/48/" class="label-pagination">48</a>
    
        <a href="/page/49/" class="label-pagination">49</a>
    
        <a href="/page/50/" class="label-pagination">50</a>
    
        <a href="/page/51/" class="label-pagination">51</a>
    
        <a href="/page/52/" class="label-pagination">52</a>
    
        <a href="/page/53/" class="label-pagination">53</a>
    
        <a href="/page/54/" class="label-pagination">54</a>
    
        <a href="/page/55/" class="label-pagination">55</a>
    
        <a href="/page/56/" class="label-pagination">56</a>
    
        <a href="/page/57/" class="label-pagination">57</a>
    
        <a href="/page/58/" class="label-pagination">58</a>
    
        <a href="/page/59/" class="label-pagination">59</a>
    
        <a href="/page/60/" class="label-pagination">60</a>
    
        <a href="/page/61/" class="label-pagination">61</a>
    
        <a href="/page/62/" class="label-pagination">62</a>
    
        <a href="/page/63/" class="label-pagination">63</a>
    
        <a href="/page/64/" class="label-pagination">64</a>
    
        <a href="/page/65/" class="label-pagination">65</a>
    
        <a href="/page/66/" class="label-pagination">66</a>
    
        <a href="/page/67/" class="label-pagination">67</a>
    
        <a href="/page/68/" class="label-pagination">68</a>
    
        <a href="/page/69/" class="label-pagination">69</a>
    
        <a href="/page/70/" class="label-pagination">70</a>
    
        <a href="/page/71/" class="label-pagination">71</a>
    
        <a href="/page/72/" class="label-pagination">72</a>
    
        <a href="/page/73/" class="label-pagination">73</a>
    
        <a href="/page/74/" class="label-pagination">74</a>
    
        <a href="/page/75/" class="label-pagination">75</a>
    
        <a href="/page/76/" class="label-pagination">76</a>
    
        <a href="/page/77/" class="label-pagination">77</a>
    
        <a href="/page/78/" class="label-pagination">78</a>
    
        <a href="/page/79/" class="label-pagination">79</a>
    
        <a href="/page/80/" class="label-pagination">80</a>
    
        <a href="/page/81/" class="label-pagination">81</a>
    
        <a href="/page/82/" class="label-pagination">82</a>
    
        <a href="/page/83/" class="label-pagination">83</a>
    
        <a href="/page/84/" class="label-pagination">84</a>
    
        <a href="/page/85/" class="label-pagination">85</a>
    
        <a href="/page/86/" class="label-pagination">86</a>
    
        <a href="/page/87/" class="label-pagination">87</a>
    
        <a href="/page/88/" class="label-pagination">88</a>
    
        <a href="/page/89/" class="label-pagination">89</a>
    
        <a href="/page/90/" class="label-pagination">90</a>
    
        <a href="/page/91/" class="label-pagination">91</a>
    
        <a href="/page/92/" class="label-pagination">92</a>
    
        <a href="/page/93/" class="label-pagination">93</a>
    
        <a href="/page/94/" class="label-pagination">94</a>
    

    
    
        <a href="/page/77/" aria-label="Next" class="label-pagination"><i class="fa fa-angle-right fa-lg"></i></a>
    

    
    
        <a href="/page/94/" aria-label="Last"><i class="fa fa-angle-double-right fa-lg"></i></a>
    

</div>

  
    </div>
    

<aside class="sidebar thirds">
  <section class="first odd">

    

    <p>
      
    </p>
  </section>



  
  <ul class="sidebar-nav">
    <li class="sidebar-nav-item">
      
      
      
      
      
         
      
      
      
      
      
      
      
      

    
    
    </li>
  </ul>

  

  

  
  
  
    
      <section class="even">
        <h1>Recent Posts</h1>
        <ul id="recent_posts">
          
          
            
              <li class="post">
                <a href="/blog/archives/2868/">外设接口和供电的演化史</a>
              </li>
            
          
            
              <li class="post">
                <a href="/blog/archives/2867/">996</a>
              </li>
            
          
            
              <li class="post">
                <a href="/blog/archives/2866/">关于抵制洋节</a>
              </li>
            
          
            
              <li class="post">
                <a href="/blog/archives/2865/">恒春潜水记录</a>
              </li>
            
          
            
              <li class="post">
                <a href="/blog/archives/2864/">递归有关的几个小问题</a>
              </li>
            
          
            
              <li class="post">
                <a href="/blog/archives/2863/">openssl证书相关</a>
              </li>
            
          
            
              <li class="post">
                <a href="/blog/archives/2862/">openssl基本密码学操作</a>
              </li>
            
          
            
              <li class="post">
                <a href="/blog/archives/2861/">密码学基本原理</a>
              </li>
            
          
            
              <li class="post">
                <a href="/blog/archives/2860/">similan船宿</a>
              </li>
            
          
            
              <li class="post">
                <a href="/blog/archives/2859/">在云存储上叠加加密文件系统</a>
              </li>
            
          
        </ul>
      </section>
    
  
</aside>
    
  </div>
</div>
    <footer role="contentinfo">
      <p>Copyright &copy; 2019 Shell Xu - <a href="//blog.shell909090.org/license/">License</a> -
        <span class="credit">Powered by <a target="_blank" href="https://gohugo.io">Hugo</a> and <a target="_blank" href="https://github.com/parsiya/hugo-octopress/">Hugo-Octopress</a> theme.
      </p>
    </footer>

    
    
    

    
  </body>
</html>
   

