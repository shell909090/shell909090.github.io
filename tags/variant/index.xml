<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Variant on Shell&#39;s Home</title>
    <link>http://shell909090.org/tags/variant/</link>
    <description>Recent content in Variant on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Sat, 06 Sep 2008 22:50:00 +0800</lastBuildDate>
    <atom:link href="http://shell909090.org/tags/variant/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>C&#43;&#43;下的Variant</title>
      <link>http://shell909090.org/blog/archives/32/</link>
      <pubDate>Sat, 06 Sep 2008 22:50:00 +0800</pubDate>
      
      <guid>http://shell909090.org/blog/archives/32/</guid>
      <description>&lt;p&gt;所谓C++语言，是一种强类型语言。即是说，C++种的某个变量，在使用时类型是已经确定的。这个并不是设计者的喜好或者是偏心，而是C++中的变量都会被翻译成准确的内存地址和大小，如果类型不确定是不可能处理的。但是在事实中，我们经常要处理一种&amp;rdquo;变类型&amp;rdquo;。例如，我们可能需要解析表达式，这个时候我们可能用一个或者两个栈来解决这个问题。可栈里面塞的东西就精彩了，对象，函数，数据，都在里面。这时候，如果是python，我们可以直接用list，他是弱类型的。但是C++怎么办？
一般来说，我们会使用Variant类型来解决这个问题。这是C++面对对象机制和算子机制所派生出来的产物，能够让用户自行定义对象的行为。如果一个对象，可以表现的像这个又像那个，那不就解决问题了？因此在COM中就有一个variant。不过贝壳看过机制，是一堆东西的集合，非常的不美丽。今天贝壳又看到一个variant的实现，漂亮多了。
废话少说，上代码。
#include
using namespace std;
#include
using namespace boost;&lt;/p&gt;

&lt;p&gt;int _tmain(int argc, _TCHAR* argv[])
{
any a;
a = 10;
printf (&amp;ldquo;%s: %dn&amp;rdquo;, a.type ().name (), any_cast(a));
a = 10.5;
printf (&amp;ldquo;%s: %fn&amp;rdquo;, a.type ().name (), any_cast(a));
a = string (&amp;ldquo;str&amp;rdquo;);
printf (&amp;ldquo;%s: %sn&amp;rdquo;, a.type ().name (), any_cast(a).c_str ());
return 0;
}
当类型错误时，出现bad_cast exception。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>