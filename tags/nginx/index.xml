<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Nginx on Shell&#39;s Home</title>
    <link>//blog.shell909090.org/tags/nginx/</link>
    <description>Recent content in Nginx on Shell&#39;s Home</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Wed, 15 Jan 2014 10:53:20 +0800</lastBuildDate>
    <atom:link href="//blog.shell909090.org/tags/nginx/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>golang和nginx的简单性能对比</title>
      <link>//blog.shell909090.org/blog/archives/2536/</link>
      <pubDate>Wed, 15 Jan 2014 10:53:20 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/2536/</guid>
      <description>&lt;h1 id=&#34;说明&#34;&gt;说明&lt;/h1&gt;&#xA;&lt;p&gt;测试都是ab做的，中等并发量，统一采用10000并发，100000个请求。都是本机请求本机，避免公司内网IDS的干扰。&lt;/p&gt;&#xA;&lt;p&gt;机器是一台双核CPU的DELL：Intel(R) Pentium(R) CPU G2030 @&#xA;3.00GHz。配4G内存。&lt;/p&gt;&#xA;&lt;p&gt;第一组数据是ab测试nginx，nginx的配置如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;worker_processes 4;&#xA;pid /run/nginx.pid;&#xA;worker_rlimit_nofile 30000;&#xA;&#xA;events {&#xA;        worker_connections 20000;&#xA;        multi_accept on;&#xA;}&#xA;&#xA;http {&#xA;        sendfile on;&#xA;        tcp_nopush on;&#xA;        tcp_nodelay on;&#xA;        ...&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;第二组是ab测试golang，返回固定是个OK。&lt;/p&gt;&#xA;&lt;p&gt;第三组是ab测试golang，返回某个目录或文件。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;err := http.ListenAndServe(&amp;quot;:8080&amp;quot;, http.FileServer(http.Dir(&amp;quot;/home/shell/photo&amp;quot;)))&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;nginx&#34;&gt;nginx&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Concurrency Level:      10000&#xA;Time taken for tests:   5.720 seconds&#xA;Complete requests:      100000&#xA;Failed requests:        0&#xA;Write errors:           0&#xA;Total transferred:      172100000 bytes&#xA;HTML transferred:       160000000 bytes&#xA;Requests per second:    17482.47 [#/sec] (mean)&#xA;Time per request:       572.001 [ms] (mean)&#xA;Time per request:       0.057 [ms] (mean, across all concurrent requests)&#xA;Transfer rate:          29382.16 [Kbytes/sec] received&#xA;&#xA;Connection Times (ms)&#xA;              min  mean[+/-sd] median   max&#xA;Connect:        0  320 581.1    146    3262&#xA;Processing:     1  197 136.6    198    1886&#xA;Waiting:        1  162 120.6    154    1811&#xA;Total:          1  517 604.1    371    3558&#xA;&#xA;Percentage of the requests served within a certain time (ms)&#xA;  50%    371&#xA;  66%    455&#xA;  75%    515&#xA;  80%    587&#xA;  90%   1167&#xA;  95%   1378&#xA;  98%   3375&#xA;  99%   3402&#xA; 100%   3558 (longest request)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;golang-with-string&#34;&gt;golang with string&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Concurrency Level:      10000&#xA;Time taken for tests:   5.147 seconds&#xA;Complete requests:      100000&#xA;Failed requests:        0&#xA;Write errors:           0&#xA;Total transferred:      11800000 bytes&#xA;HTML transferred:       200000 bytes&#xA;Requests per second:    19429.37 [#/sec] (mean)&#xA;Time per request:       514.685 [ms] (mean)&#xA;Time per request:       0.051 [ms] (mean, across all concurrent requests)&#xA;Transfer rate:          2238.93 [Kbytes/sec] received&#xA;&#xA;Connection Times (ms)&#xA;              min  mean[+/-sd] median   max&#xA;Connect:        0  293 659.6      5    3020&#xA;Processing:     1   37 112.3     10    1644&#xA;Waiting:        1   34 111.9      9    1642&#xA;Total:          3  329 700.4     16    4653&#xA;&#xA;Percentage of the requests served within a certain time (ms)&#xA;  50%     16&#xA;  66%     25&#xA;  75%    248&#xA;  80%   1003&#xA;  90%   1032&#xA;  95%   1431&#xA;  98%   3026&#xA;  99%   3042&#xA; 100%   4653 (longest request)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;golang-with-file&#34;&gt;golang with file&lt;/h1&gt;&#xA;&lt;pre&gt;&lt;code&gt;Concurrency Level:      10000&#xA;Time taken for tests:   8.122 seconds&#xA;Complete requests:      100000&#xA;Failed requests:        0&#xA;Write errors:           0&#xA;Keep-Alive requests:    100000&#xA;Total transferred:      72200000 bytes&#xA;HTML transferred:       53500000 bytes&#xA;Requests per second:    12312.87 [#/sec] (mean)&#xA;Time per request:       812.158 [ms] (mean)&#xA;Time per request:       0.081 [ms] (mean, across all concurrent requests)&#xA;Transfer rate:          8681.54 [Kbytes/sec] received&#xA;&#xA;Connection Times (ms)&#xA;              min  mean[+/-sd] median   max&#xA;Connect:        0   29 333.4      0    7009&#xA;Processing:     0  495  98.1    524    1918&#xA;Waiting:        0  495  98.1    524    1918&#xA;Total:          0  524 353.0    525    8086&#xA;&#xA;Percentage of the requests served within a certain time (ms)&#xA;  50%    525&#xA;  66%    531&#xA;  75%    535&#xA;  80%    537&#xA;  90%    543&#xA;  95%    550&#xA;  98%    558&#xA;  99%    563&#xA; 100%   8086 (longest request)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;h1 id=&#34;分析&#34;&gt;分析&lt;/h1&gt;&#xA;&lt;p&gt;从rps来看，三者都达到了10Krps的级别以上，而且差距很小。golang在没有逻辑的情况下比nginx还要快11%，但是加入逻辑后反而落后30%（这不奇怪）。三者差距都在50%以内，基本属于同一个数量级。&lt;/p&gt;</description>
    </item>
    <item>
      <title>debian wheezy下以uwsgi安装graphite</title>
      <link>//blog.shell909090.org/blog/archives/2200/</link>
      <pubDate>Mon, 09 Jul 2012 08:45:28 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/2200/</guid>
      <description>&lt;h1 id=&#34;abstract&#34;&gt;abstract&lt;/h1&gt;&#xA;&lt;p&gt;graphite是一个python写的性能监控系统。这个系统是由多个分离的部分组成的。&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;graphite-web: 由django写的web界面系统。&lt;/li&gt;&#xA;&lt;li&gt;carbon: 数据收集的守护进程。&lt;/li&gt;&#xA;&lt;li&gt;whisper: 一种python写的数据库，类似rrd，便于大量的性能日志数据收集和处理。上两个组件会调用这个库。&lt;/li&gt;&#xA;&lt;li&gt;collectd: 数据收集守护进程，向carbon中喂数据的数据源。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;另外，有一点黑色幽默的就是，graphite的意思是石墨，是炭(carbon)的一种同素异形体。因此在graphite项目中，多次出现carbon这个名字。当然，另两个同素异形体是钻石(diamond)和足球烯(footballene)，你就暂时别指望看到他们的身影了。&lt;/p&gt;&#xA;&lt;p&gt;另一个用python写的，以元素命名的著名软件是mercurial。化学元素中的汞，俗称水银，符号hg。因此mercurial的命令行简写才是hg。&lt;/p&gt;&#xA;&lt;p&gt;以上几个的结构大概是这样的：&lt;/p&gt;&#xA;&lt;p&gt;collectd(source) -network-&amp;gt; carbon -&amp;gt; writing-&amp;gt; whisper&lt;/p&gt;&#xA;&lt;p&gt;database -&amp;gt; reading-&amp;gt; graphite-web&lt;/p&gt;&#xA;&lt;p&gt;下文描述了在debian wheezy下，以nginx+uwsgi模式安装graphite的过程。之所以用这个模式，是因为我的大部分系统都是python写的，同样安装在uwsgi下面。一事不烦二主。&lt;/p&gt;&#xA;&lt;h1 id=&#34;carbon&#34;&gt;carbon&lt;/h1&gt;&#xA;&lt;p&gt;carbon有对应的debian包，可以很简单的安装。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo aptitude install graphite-carbon&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;默认的数据端口是2003，默认的数据路径是/var/lib/graphite/，这个在下文需要用到。&lt;/p&gt;&#xA;&lt;h1 id=&#34;graphite&#34;&gt;graphite&lt;/h1&gt;&#xA;&lt;h2 id=&#34;virtual&#34;&gt;virtual&lt;/h2&gt;&#xA;&lt;p&gt;graphite有部分需要安装到系统中，因此最好用virtualenv进行安装。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;cd /var/web/&#xA;sudo aptitude install python-virtualenv&#xA;virtualenv --system-site-packages graphite&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;我假定你的安装路径是/var/web/graphite，这个在下面要反复用到。&lt;/p&gt;&#xA;&lt;h2 id=&#34;install&#34;&gt;install&lt;/h2&gt;&#xA;&lt;p&gt;在安装路径下，执行以下内容&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;source bin/activite&#xA;pip install graphite-web --install-option=&amp;quot;--prefix=/var/web/graphite&amp;quot; --install-option=&amp;quot;--install-lib=/var/web/graphite/webapp&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;注意，/var/web/graphite需要根据上面的设定自行修改，webapp是你的django基础路径。&lt;/p&gt;&#xA;&lt;h2 id=&#34;configure&#34;&gt;configure&lt;/h2&gt;&#xA;&lt;p&gt;在/var/web/graphite/webapp/graphite下面，执行以下内容&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;cp local_settings.py.example local_settings.py&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;然后编辑local_settings.py&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;GRAPHITE_ROOT = &#39;/var/web/graphite&#39;&#xA;WHISPER_DIR = &#39;/var/lib/graphite/whisper&#39;&#xA;DATABASES = ...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;注意databases，不要在settings.py里面修改，要改这里的才有效。我用的是sqlite，如果你高兴，可以改为postgres/mysql。WHISPER_DIR是上文carbon中设定的目录。&lt;/p&gt;</description>
    </item>
    <item>
      <title>uwsgi under debian</title>
      <link>//blog.shell909090.org/blog/archives/1919/</link>
      <pubDate>Tue, 27 Sep 2011 10:28:02 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/1919/</guid>
      <description>&lt;p&gt;好了，debian官方的uwsgi总算出来了。包已经到了testing，stable暂时别指望了，等下一次release吧。这次打的包，比贝壳打的复杂多了。贝壳自己只打了python专用的包，debian官方的包将多个语言分别打成了plugins。&lt;/p&gt;&#xA;&lt;p&gt;下面说说，使用debian官方的包如何做uwsgi发布，还是vhost模式哦。&lt;/p&gt;&#xA;&lt;p&gt;首先安装uwsgi，uwsgi-plugin-python这两个包。uwsgi-plugin-greenlet-python也可以考虑，装不装看你的需求。&lt;/p&gt;&#xA;&lt;p&gt;然后在/etc/uwsgi/apps-available/sites.xml下面写一个文本文件，内容如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;uwsgi&amp;gt;&#xA;&amp;lt;vhost/&amp;gt;&#xA;&amp;lt;no-site/&amp;gt;&#xA;&amp;lt;/uwsgi&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;再从/etc/uwsgi/apps-enabled/sites.xml链接过去，重启uwsgi服务，事情就搞定了。&lt;/p&gt;&#xA;&lt;p&gt;默认的配置在/usr/share/uwsgi/conf/default.ini，可以看看是否都满意了。一般来说，master和no-orphans都建议打开，chmod-socket最高660，改成600应该也可以工作。贝壳的机器负载小，只用一个worker就够了，所以完整的配置是这样的：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;&amp;lt;uwsgi&amp;gt;&#xA;&#x9;&amp;lt;plugins&amp;gt;greenlet,ugreen&amp;lt;/plugins&amp;gt;&#xA;&#x9;&amp;lt;workers&amp;gt;1&amp;lt;/workers&amp;gt;&#xA;&#x9;&amp;lt;reload-on-as&amp;gt;128&amp;lt;/reload-on-as&amp;gt;&#xA;&#x9;&amp;lt;vhost/&amp;gt;&#xA;&#x9;&amp;lt;no-site/&amp;gt;&#xA;&amp;lt;/uwsgi&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;nginx里面如此设定：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;location /asdf {&#xA;&#x9;include uwsgi\_params;&#xA;&#x9;uwsgi\_param UWSGI\_PYHOME /usr;&#xA;&#x9;uwsgi\_param UWSGI\_CHDIR /var/web/hosts;&#xA;&#x9;uwsgi\_param UWSGI\_SCRIPT main;&#xA;&#x9;uwsgi\_pass unix:/run/uwsgi/sites/socket;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;其中，我的程序放在/var/web/hosts底下，使用系统环境来运行（而不是virtualenv），主脚本（带applications那个）是main.py。unix&lt;/p&gt;&#xA;&lt;p&gt;socket和上文default.ini里面的socket正好对应上。&lt;/p&gt;&#xA;&lt;p&gt;同理，我们其实还可以开多个uwsgi应用，只要放置多个xml配置就好。不过既然都采用了vhost模式，何必还开多个呢？这毕竟不是虚拟网站，要给其他人使用的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用uwsgi搭建python应用</title>
      <link>//blog.shell909090.org/blog/archives/1811/</link>
      <pubDate>Wed, 25 May 2011 11:08:38 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/1811/</guid>
      <description>&lt;p&gt;   wsgi是python的一个标准web服务接口，具体去google&#xA;pep文档，不解释。在李木头的忽悠下，贝壳试用了一下uwsgi搭建python服务器，感觉还不错。&#xA; &#xA; 首先，贝壳将uwsgi打包成deb包，因为这东西和python基本没什么关系，就是一个标准的系统守护服务程序。其中贝壳测试了一下，uwsgi编译的时候是依赖版本的。所以请教了一下thomas，打了uwsgi2.6和uwsgi2.7两个包。没办法，mercurial对python2.7的支持不是很好，每次都出问题。具体的可以加贝壳的repos:&#xA;&lt;a href=&#34;https://home.shell909090.org/debian/&#34;&gt;https://home.shell909090.org/debian/&lt;/a&gt;&lt;span&#xA;style=&#34;min-height: 16px; padding-right: 16px; width: 16px;&#34;&gt;&lt;/span&gt;&#xA;testing，然后通过一下贝壳的key，就可以直接安装uwsgi2.6了。当然，不通过key也可以，只是每次安装升级都有警告。&#xA; &#xA; 贝壳写了一个很简单的init.d，使用&amp;ndash;vhost来启动uwsgi为服务模式。这种模式的好处是，uwsgi的具体执行的应用都是由nginx来确定的，因此所有的映射只需要修改nginx配置就好。uwsgi参数很多，包括可以指定内存限制，工作进程/线程，定时重启工作进程，多解释器等等。是一个高效的，功能强大的服务器。具体可以自己参考调整。最好的的地方是，uwsgi还支持virtualenv，你可以给不同的应用建立不同的工作环境，从而在环境中使用指定的包，而不是系统包。&#xA;   下面是一个nginx配置的例子。       location /ticket {              &#xA; include uwsgi_params;                uwsgi_param UWSGI_PYHOME /usr;&#xA;               uwsgi_param UWSGI_CHDIR /home/shell/workspace/hg/thost;&#xA;               uwsgi_param UWSGI_SCRIPT main;              &#xA; uwsgi_pass unix:/var/run/uwsgi.socket;        }        location&#xA;/mlocate {                include uwsgi_params;              &#xA; uwsgi_param UWSGI_PYHOME /usr;                uwsgi_param&#xA;UWSGI_CHDIR /home/shell/workspace/hg/thost;                uwsgi_param&#xA;UWSGI_SCRIPT main;                uwsgi_pass&#xA;unix:/var/run/uwsgi.socket;        }        location /hg {              &#xA; include uwsgi_params;                uwsgi_param UWSGI_PYHOME /usr;&#xA;               uwsgi_param UWSGI_CHDIR /home/shell/workspace/hg;      &#xA;         uwsgi_param UWSGI_SCRIPT hgweb;                uwsgi_param&#xA;SCRIPT_NAME /;                uwsgi_param SERVER_NAME hgweb;        &#xA;       uwsgi_pass unix:/var/run/uwsgi.socket;        }  &#xA; 这里面设定了三个应用。由于贝壳不需要virtualenv，所以PYHOME设定了/usr。第一二个应用的基础路径在/home/shell/workspace/hg/thost，脚本叫做main.py。第三个应用的基础路径在/home/shell/workspace/hg，脚本叫做hgweb.py。需要注意的是，uwsgi会以模块方式导入这些脚本，然后使用其中的application对象作为wsgi处理函数。所以不要把application对象赋值放在if&#xA;__name__ ==&#xA;&amp;lsquo;__main__&amp;lsquo;里面，那没用的。第三个应用指定了SCRIPT_NAME和SERVER_NAME，是因为hg的wsgi模块没有SCRIPT_NAME不工作，而这个应用和前两个不在一起，所以如果不指定SERVER_NAME会导致覆盖冲突。&#xA;   &#xA;这种部署模式的好处是，我可以使用一个宿主来管理所有的应用，而不必每个应用启动一个宿主，省去了多个宿主管理的麻烦。而多进程，压力分布等等问题都被uwsgi的配置系统搞定了。于是应用程序宿主做到了彻底的免管理，即装即用，只用调节性能匹配即可。具体程序配置下放到nginx中，要修改映射关系只用管理一个位置。&lt;/p&gt;</description>
    </item>
    <item>
      <title>nginx使用fastcgi连接django时的细节</title>
      <link>//blog.shell909090.org/blog/archives/1694/</link>
      <pubDate>Tue, 15 Feb 2011 11:10:00 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/1694/</guid>
      <description>&lt;p&gt;django使用PATH_INFO和SCRIPT_NAME来计算urls.py中的匹配路径，当两者都设定时，会出现URL计算结果为空，导致无法访问的问题。具体看这里。&lt;/p&gt;&#xA;&lt;p&gt;&lt;a href=&#34;http://aftnn.org/2009/jan/23/nginx-django-fastcgi/&#34;&gt;http://aftnn.org/2009/jan/23/nginx-django-fastcgi/&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何做一个mercurial的http发布</title>
      <link>//blog.shell909090.org/blog/archives/1618/</link>
      <pubDate>Mon, 22 Nov 2010 09:29:00 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/1618/</guid>
      <description>&lt;p&gt;我假定你了解hg，了解python，理解nginx或者其他cgi/fcgi的配置过程。现在想用http发布自己的mercurial仓库，而且可能发布一群，怎么操作呢？&lt;/p&gt;&#xA;&lt;p&gt;首先，复制模板文件过来，你可以挑选其中之一。以下是debian的文件位置，其他发布请自行查询。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;/usr/share/doc/mercurial-common/examples/hgweb.wsgi&#xA;/usr/share/doc/mercurial-common/examples/hgweb.fcgi&#xA;/usr/share/doc/mercurial-common/examples/hgweb.cgi&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;我使用nginx+fastcgi模式部署，因此复制了hgweb.fcgi。我假定你的仓库在~/hg下面，有很多子仓库。复制hgweb.fcgi到~/hg/下，改名为hgweb.py，并修改以下两行。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;config = &amp;quot;/path/to/you/config&amp;quot;&#xA;WSGIServer(application, bindAddress=&#39;hgweb.sock&#39;).run()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;其中bindAddress为你需要监听的unixsocket路径，没有前缀表示在当前目录生成。而后建立配置文件，大概为以下内容。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;[web]&#xA;allow_push = someone&#xA;push_ssl = false&#xA;&#xA;[paths]&#xA;/hg/proj1=/path/to/proj1&#xA;/hg/proj2=/path/to/proj2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;以上就完成了hgweb的服务配置，/hg/proj1是你的url映射路径，/path/to/proj1是物理路径。someone是允许进行push的人，而push_ssl是允许http推送。而后，启动服务。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;python hgweb.py &amp;amp;&#xA;chmod 666 hgweb.sock&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;注意，这里要用screen之类的程序来启动hgweb，否则term关闭后服务进程停止，就没的玩了。修改权限是因为debian下的nginx使用www-data运行，对/home/user/hg没有读写权限，导致无法使用unixsock。&lt;/p&gt;&#xA;&lt;p&gt;在nginx中做以下配置。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;location ^~ /hg/ {&#xA;&#x9;limit_except GET {&#xA;&#x9;&#x9;auth_basic &amp;quot;Restricted&amp;quot;;&#xA;&#x9;&#x9;auth_basic_user_file /home/user/hg/users;&#xA;&#x9;}&#xA;&#x9;fastcgi_pass unix:/home/user/hg/hgweb.sock;&#xA;&#x9;include fastcgi_params;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;如果你不需要auth，可以自行参照nginx的配置修改。其他web服务器以此类推。重启服务后，&lt;a href=&#34;http://domains/hg/proj1&#34;&gt;http://domains/hg/proj1&lt;/a&gt; 就可以访问到proj1了。&lt;/p&gt;&#xA;&lt;p&gt;当然，其实最后还要提一句，如果你不需要web界面，可以直接设定将文件内容直接发出去，这样也是可以做pull/push的。&lt;/p&gt;&#xA;&lt;p&gt;参考：&#xA;&lt;a href=&#34;http://mercurial.selenic.com/wiki/PublishingRepositories&#34;&gt;http://mercurial.selenic.com/wiki/PublishingRepositories&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>以nginx作为subversion前端的一些细节</title>
      <link>//blog.shell909090.org/blog/archives/108/</link>
      <pubDate>Fri, 02 Apr 2010 03:40:00 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/108/</guid>
      <description>&lt;h1 id=&#34;location--50xhtml--root-varwwwnginx-default--&#34;&gt;本文系电脑资料，同步到blog上。小黄姐姐不必看了，可以帮我留个言。&#xA;nginx性能不错，可惜不支持WebDAV，因此没法拿来作为subversion的http服务。于是考虑开一个nginx作为前端，后端就跑一个apache来作为容器。配置这么写的(节选)：&#xA;=========/etc/nginx/sites-enabled/default========= server { listen  &#xA;443; server_name  OOXX ssl  on; ssl_certificate  keys/server.crt;&#xA;ssl_certificate_key  keys/server.key; ssl_session_timeout  5m;&#xA;ssl_protocols  SSLv2 SSLv3 TLSv1; ssl_ciphers &#xA;ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:+SSLv2:+EXP;&#xA;ssl_prefer_server_ciphers   on; access_log &#xA;/var/log/nginx/localhost.access.log; include            &#xA;/etc/nginx/mapping-ssl; error_page   500 502 503 504  /50x.html;&#xA;location = /50x.html { root   /var/www/nginx-default; } }&lt;/h1&gt;&#xA;&lt;h1 id=&#34;proxy_add_x_forwarded_for-&#34;&gt;打开了一个https的服务，这是当然的，svn传输的数据使用http很危险。&#xA;===========/etc/nginx/mapping-ssl============= location ^~ /svn {&#xA;proxy_set_header    Destination $http_destination;&#xA;proxy_pass          &lt;a href=&#34;http://apache_svr&#34;&gt;http://apache_svr&lt;/a&gt;; proxy_set_header   &#xA;Host            $host; proxy_set_header    X-Real-IP      &#xA;$remote_addr; proxy_set_header    X-Forwarded-Host $host;&#xA;proxy_set_header    X-Forwarded-Proto https; proxy_set_header   &#xA;X-Forwarded-Server $host; proxy_set_header    X-Forwarded-For&#xA;$proxy_add_x_forwarded_for; }&lt;/h1&gt;&#xA;&lt;h1 id=&#34;varwebsvnmainconfauthz-location&#34;&gt;将/svn下面的所有请求交给apache2。&#xA;=====/etc/apache2/mods-enabled/dav_svn.conf===== &amp;lt;Location&#xA;/svn/main&amp;gt; DAV svn SVNPath /var/web/svn/main AuthType Basic AuthName&#xA;&amp;ldquo;Subversion Repository&amp;rdquo; Require valid-user AuthUserFile&#xA;/var/web/svn/main/conf/passwd AuthzSVNAccessFile&#xA;/var/web/svn/main/conf/authz &amp;lt;/Location&amp;gt;&lt;/h1&gt;&#xA;&lt;h1 id=&#34;svn154-r33841tortoisesvn-15514361-neon0283&#34;&gt;看起来很美，但是在使用中会发生502错误，原因是来自文件移动后，svn会使用COPY作为Verb去请求服务器端，这时候发生了这样一条日志：&#xA;==========/var/log/apache2/access.log========== 127.0.0.1 - {user}&#xA;[02/Apr/2010:11:07:31 +0800] &amp;ldquo;COPY {path} HTTP/1.0&amp;rdquo; 502 546 &amp;ldquo;-&amp;rdquo;&#xA;&amp;ldquo;SVN/1.5.4 (r33841)/TortoiseSVN-1.5.5.14361 neon/0.28.3&amp;rdquo;&lt;/h1&gt;&#xA;&lt;p&gt;搜索了一下，这是因为使用https作为http服务的前端造成的，这里(&lt;a href=&#34;https://secure.bonkabonka.com/blog/2008/01/04/nginx_fronting_for_subversion.html)&#34;&gt;https://secure.bonkabonka.com/blog/2008/01/04/nginx_fronting_for_subversion.html)&lt;/a&gt;提到了解决方案，而它又引用了另一个网页(&lt;a href=&#34;http://silmor.de/49)&#34;&gt;http://silmor.de/49)&lt;/a&gt;解释细节。不幸的是，这个细节是错误的。关键在于这句上&#xA;LoadModule headers_module /usr/lib/apache2/modules/mod_headers_too.so&#xA;仔细看一下就会发现，mod_headers_too应当是mod_headers。在debian下，应当执行这几条指令。&#xA;cd /etc/apache2/mods-enabled ln -s ../mods-available/headers.load&#xA;headers.load 然后，在/etc/apache2/httpd.conf中写入以下内容：&#xA;RequestHeader edit Destination ^https http early 问题解决，Q.E.D。&lt;/p&gt;</description>
    </item>
    <item>
      <title>一个远程下载verycd的小技巧</title>
      <link>//blog.shell909090.org/blog/archives/89/</link>
      <pubDate>Fri, 29 Jan 2010 15:59:00 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/89/</guid>
      <description>&lt;p&gt;贝壳家里开了emule，天天下载，问题是又不能每次都是晚上添加资源。&lt;/p&gt;&#xA;&lt;p&gt;怎么办呢？不知道大家知道不知道，emule是可以网络管理的，端口是4711。不过不是https，密码容易泄露。而且贝壳已经有一个nginx服务器了，也懒的再做端口映射，换端口。于是，在nginx中做如下设定。(当然，贝壳是放在https段中的)&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;location ^~ /emule/ {&#xA;&#x9;rewrite ^/emule/(.*)$ /$1 break;&#xA;&#x9;proxy_pass &amp;lt;http://hostip:4711&amp;gt;;&#xA;&#x9;proxy_set_header Host $host;&#xA;&#x9;proxy_set_header X-Real-IP $remote_addr;&#xA;&#x9;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;然后，用&lt;a href=&#34;https://dynname/emule/&#34;&gt;https://dynname/emule/&lt;/a&gt;就可以访问你家里的emule了，记得密码设强点。&lt;/p&gt;&#xA;&lt;p&gt;接下来，verycd里面曾经有复制所有连接的选项，现在没了。面对几个链接，也就手工复制一下，面对上百个连接，贝壳就无语了。贝壳试验过几个插件，都无法正确识别ed2k的链接获取。那怎么办呢？这时就要请出我们伟大的Linux。&lt;/p&gt;&#xA;&lt;p&gt;需要准备的工具是lynx，请预先装好，然后如下操作。(范例是个动画^_^)&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;wget -c &amp;lt;http://www.verycd.com/topics/2779234/&amp;gt;&#xA;lynx -dump -listonly index.html | grep &amp;quot;ed2k://&amp;quot; | sed &amp;quot;s/.*ed2k/ed2k/g&amp;quot; | grep -v BIG5 &amp;gt; out.txt&#xA;wc -l out.txt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;lynx的-dump选项是将某个网页全部渲染成文本进行展示，这是html2text的好方法，效果还不错哦，不过中文支持好像不是很好。而-listonly则是展示出页面上的所有链接，这就拿到了我们需要的原始数据。&lt;/p&gt;&#xA;&lt;p&gt;然后，我们取其中的ed2k行，忽略其他链接，再通过sed转换，去除头部的编号和空格，这样就可以得到所有的ed2k链接。&lt;/p&gt;&#xA;&lt;p&gt;我在下面是用-v BIG5的参数，忽略了其中繁体中文的资源，然后输出到一个文件中。数数行数，52行，大致和文件个数相当(其中好像有两个v2)。那就是可用资源了，复制到emule的控制页面中——出错？&lt;/p&gt;&#xA;&lt;p&gt;这是因为emule的控制页面使用GET方式传递参数，因此有长度限制。你需要将链接10个一批往里面复制——有个几次就OK了。当然，如果还是多，贝壳回头会写一篇文章，介绍如何使用curl自动干这事情——这还不算太难。&lt;/p&gt;&#xA;&lt;p&gt;这就是为啥贝壳喜欢Linux的原因了。相比Windows下的两个解决方案，找插件太费劲，自己写程序更费劲。Linux使用现有工具的组合可以轻松完成这一任务。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
