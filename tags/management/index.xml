<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>management on Shell&#39;s Home</title>
    <link>//blog.shell909090.org/tags/management/</link>
    <description>Recent content in management on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Fri, 16 Sep 2011 10:12:08 +0800</lastBuildDate><atom:link href="//blog.shell909090.org/tags/management/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>给初创小公司的几句话（四）</title>
      <link>//blog.shell909090.org/blog/archives/1911/</link>
      <pubDate>Fri, 16 Sep 2011 10:12:08 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1911/</guid>
      <description>第四个故事来自一个朋友的笑话。说某人从一家公司辞职了，朋友问说什么情况。某人说，和老板相处不来。老板看到有人上班看网页，就出了条规定，不许上班时间看网页，否则罚款。看到有人带朋友进办公室，就出条规定，不许上班时带朋友进办公室，否则罚款。上个月老婆出差，没人照顾家里的仓鼠，带去两天，出条规定，不得带宠物上班。某人情感受到了强烈的伤害，所以愤而辞职。
其实说起来，这些事情都不是什么大事，鸡毛蒜皮到了我们可以当笑话说的地步。细究起来也确实是员工应当执行的，属于正常雇员的基本素养。不过如果您自己开家公司，照着上面的做，搞不好手下还真就一堆辞职的。
从某种意义上说，这是一个心理问题。在IBM，或者Oracle这种大公司，出现这些条款没人觉得有什么不对，关键在于两点。一方面，大公司本身就给人一种正儿八经，板着个脸的印象。员工进公司的时候，就知道自己随时会碰到各种狗屁倒灶的规定，有一定的心理准备。小公司通常老总天天见，搞不好下班还一起吃饭喝酒，上班的时候板起脸来做规矩，情感上受得了受不了就不好说了。另一方面，大公司的规定相对完备，什么可以什么不可以都规定的非常详细。小公司难免挂一漏万，天天改规矩，确实不怎么好看。
反过来说，这也是初创公司对大公司的优势。在大公司里，管理层显然不会留意到每个人的特性，并且针对性的管理。然而初创公司就那么几号人，大部分都是熟人。要针对管理不是一件不可能的事情。老婆出差，家里仓鼠可以带到公司，顺便睡在公司做程序得了，反正家里也没人。诸如此类的事情并不怎么难做。当然，当初创公司上了一定规模（推荐大概是10-30人）后，管理转换必然要产生阵痛。然而也远好过在三两个人的公司里面规定四五十条的规范。</description>
    </item>
    
    <item>
      <title>给初创小公司的几句话（三）</title>
      <link>//blog.shell909090.org/blog/archives/1865/</link>
      <pubDate>Wed, 27 Jul 2011 14:59:17 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1865/</guid>
      <description>第三篇故事，是来自于贝壳自己的惨痛经历，在另一位朋友那里也有类似教训，可惜他未及早听我一句。
贝壳原来在一家公司里面做项目经理，公司做企业定制开发，现在仍在，所以具体情况隐去不表。因为某些情况，老板叫贝壳做了项目经理，按照资历和能力来说，其实并未足够。贝壳精通的是C++开发，而项目是使用.net技术做的。因此贝壳对项目的管理能力实际上打了一个折扣，只能负责结构设计和协调。当时对项目管理也不是很精通，可以说是半吊子水平。公司承接了一个企业的业务系统开发，经过前期准备，我们团队就开去了客户那里进驻。客户要求，界面一定要漂亮。因此我们选型下来的结果，使用了.net 3.5的wpf开发。开发过程中其实还是有很多问题，很多都是新手问题，暴露贝壳总体设计和项目把握的缺陷。不过这和今天主题无关，就略过不谈了。主要是.net 3.5开发，到了最后发生了几个严重问题。
首先第一个问题，是客户有很多win2000机器，甚至还有一些win98。这个在当初系统设计的时候完全没有考虑。我们开发的机器一律全是winxp，.net 3.5 wpf可以完全的运行在上面。而对于win2000，wpf是无法安装的。于是，我们就必须要求客户升级到winxp。企业用户，他们还必须使用正版。其次，.net 3.5在进行远程SOAP调用的时候，会出现严重的内存泄漏。其实并不是真的泄漏了，.net 3.5的SOAP系统没有考虑调用接口可能多达数百个的情况，对每个函数都进行了序列化器缓存。这个缓存会耗费100-200M的空间，加上其他开销，我们的系统总开销是200-300M，比大部分游戏还高。这个直接导致客户运行我们系统的时候，必须多加一倍的内存。
更郁闷的问题还在后面，wpf是使用dx渲染的系统，因此如果客户没有独立显卡，系统速度就会慢如龟速。wpf的部署必须使用完整sdk，2.0的runtime安装包只有20M，而3.5的完整sdk高达350M。我们在每台机器上安装的时候都是用U盘完整安装350M的sdk。不过这都不是最郁闷的，最郁闷的是，我们项目最后问题实在太多，有个员工做了一个web版的。界面难看很多，但是方便移植部署，内存消耗小。瞬间得到全企业上下一致支持，他们的老板还问我们，当初为什么不这么设计。贝壳哪里好意思说，您不是要漂亮么？
实话说，要不是老板和客户关系好，我们非要给愤怒的客户踢出大门不可。这一个项目，成功的是老板，失败的是贝壳。
总结下来，两个教训。首先是设计必须实地的调查一线需求，不能光听上面的就得出结论，也不能光看部分典型用户就得出结论。如果有一些关键用户对构架支持不良，业务上又不能放弃，就必须权衡得失，甚至修改构架。如果当时我们知道win2000乃至win98的事情，就压根不会考虑使用wpf来做界面。第二个，就是不能迷信技术，或者激进的使用无法掌控的技术。宁可使用最土的办法，老老实实的把业务做出来。新技术由于刚刚出现，因此很多问题都没有完全暴露，很多领域也没有经验积累。例如这个例子里面的内存占用问题，安装包问题，系统问题，都是到了部署时才发生的问题。使用新技术，就会随时面对无人发现的问题，这和RPG的踩地雷战斗是一样的经历。只是这里不但没有经验值，而且踩多了还会直接挂掉。</description>
    </item>
    
    <item>
      <title>给初创小公司的几句话（二）</title>
      <link>//blog.shell909090.org/blog/archives/1861/</link>
      <pubDate>Thu, 21 Jul 2011 14:31:28 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1861/</guid>
      <description>上面一篇，贝壳说了说老板搞外行指挥内行的问题。这篇反过来，是我一个朋友X的经历。他经历的更加的传奇一些，是一个内行指挥外行的经历。
X是一家外企的程序员，原本这家外企没有IT部，后来为了做市场，于是成立了IT部。他是头一批的老员工，情况和贝壳类似。在他们之后，进来了一个很有水平的程序员Y。Y的水平很高，所以很快的就成了IT部实际的领导人。原本的外企中方经理很是器重，承诺分一定的公司股份，但是要求IT部能够达到一定目标。例如流量多少，来多少IP访问等等。Y很快就带领整个IT部开始行动了，需求分析，计划制定，时间节点分布，系统架构，都很中规中矩。SSH开发网站本身就是一个中规中矩的过程，没有太多的创意可说。半年不到，系统就上线了，基础测试通过，公司上下都很开心。
问题发生在Y拿到公司股份之后，通常按照协议，股份是不能很快变现的。我不知道Y和公司怎么谈的协议，X君作为一个局外人，也只能告诉我一些小道消息。据说Y的股票居然很快就出手了，而后Y君很快的辞职，开了家咨询公司。
而后公司系统陆续发生了一些问题，本来很稳定的流量一下缩水到几分之一，而X君说，他们的营销策略从未有大的改变。更麻烦的是，系统总是出一些莫名其妙的小问题，经常无法访问。公司没办法，只能高价请回Y君来解决。每次都是问题很快解决，但是另一个问题又再出现。几次往返后，公司实在不堪忍受，就再找了一个高手进来看看系统。X君说，人家上午过来，下午走人。说从未看过如此混乱不堪的代码，几乎没有可维护性，建议直接重写。
然后公司就陷入了两难，要不要重写呢？不重写，这个系统显然没有任何继续发展的可能。重写，又如何保证新来的工程师不会搞出这种不可维护的系统。
据说，到X走的时候，中方经理已经被迫辞职了，外方决定找印度阿三来解决这个问题。当然，后面就是一个新的传说了。
整个事情好像是一个职场阴暗面的故事，感觉平平无奇。不过实际上，整个故事还是有几个神奇的地方存在的。首先，公司没有做过Y君的背景调查么？还是说Y君以前一直OK？其次，通常股份都是不可立刻变现的，必须经过三到五年，其目的就是防止这种事情。类似的条件还有无法转让什么的，都跑到哪里去了？最后，公司所有人，包括X君在内，没有发现Y君的系统是不可维护的么？我始终感觉这个故事的背后还有其他故事，只是这已经不是我们讨论的要点了。</description>
    </item>
    
    <item>
      <title>给初创小公司的几句话（一）</title>
      <link>//blog.shell909090.org/blog/archives/1856/</link>
      <pubDate>Thu, 14 Jul 2011 17:30:29 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1856/</guid>
      <description>贝壳做程序员到现在，没去过国企（好吧，和他们有过合作，可实在看不惯他们的作派，死也不去），没去过外企（也是有合作，可惜英语太差），全在各种私企里面打转。从初创公司到中型外包都呆过，还曾是某初创公司的第一个员工，可惜结局不怎么好——关门了。初创公司的一些问题，可谓前仆后继，大家的死法差不多。当员工时，不好给老板直接提意见。现在私下里偷偷说说，有想开公司的当故事听吧。
初创公司第一怕，就是没有经验。没有经验的程序员，没有经验的经理，所以很多事情都不知道怎么办，只能摸着石头过河。实话说，完全摸石头的，还不如不开了。最起码最起码，老板做什么，就必须熟悉这行。想干互联网，必须熟悉互联网。想干企业，就必须熟悉企业。没这个要求，不如不干。至于技术上没经验，可以找合适的程序员。如果老板熟悉互联网，很多做阿里巴巴阿，做腾讯之类的傻话都不会说出来了，他要做的一定是个没有的东西，或者说在中国没有，或者有，但是市场刚要起步。在一个饱和市场内挑战一个巨头，这和唐吉柯德挑战风车是一样的，能得到的只是海明威笔下的鱼骨头。
初创公司没有人熟悉技术怎么办？这就要看你的公司类型了。如果你决定以业务为核心，可以找个诚实可靠（别说看人看不准，如果人看不准，公司哪里都会碰壁）有经验的程序员做主管，记得谈分红或者股份，然后放手给他。他会帮你管理的很好的。不过记得偶尔就他的做法咨询一下其他懂行的朋友。通常这类程序员最好是来自于大型企业IT部或者大型互联网公司，他们会把大型互联网公司的规范带过来。当然，也不要无条件的接受。先文档后程序，重测试轻代码之类的东西对初创是不适用的。起码要等公司有10来个程序员再回头补课。这些人构成的程序部是写不出什么天才程序的，但是可以有效廉价的把你要做的业务做起来。
如果你决定以技术为核心（实话说，中国这种公司比例不高），你起码得有一个高手在手里，才能谈公司的问题。而且公司开起来，你得分给他很高比例的股份。大部分这类创业老板，都是自己就是高级程序员，觉得挺了解程序了。这种情况下的建议反过来，你要找熟悉市场的人，不要觉得你很熟悉市场。程序员不是一个典型用户，除非你的用户都是程序员，否则大部分的需求需要重新考虑，甚至商业模式都未必成立。
初创公司最怕的情况，就是老板不懂技术，也不找人，胡乱指挥。贝壳呆的头家公司，现在已经关门了，所以说说问题也不大。老板决定做销售管理软件，实话说这个决定没什么问题，问题是老板的生产过程。他先找了三个程序员过来（两个新手一个老手，贝壳就是第一个员工，当时年轻，什么都不懂），然后请一个大学教授当顾问。由于大学老师都比较忙，因此他让其中一个比较有经验的程序员负责平时管理，不过还是按照员工待遇。然后他开始做需求，结果时间太少，需求做半本就开始做程序。一下就犯了大忌，需求未系统化。老程序员心知肚明，可是能说什么呢？自己连合伙人都不是，根本说不动老板。
然后制定计划的时候，老程序员制定了一个相对保守的计划——这是当然，因为只有一个老程序员和两个新手，他怎么也不敢激进阿。老板当场否决，把时间提前了两个月，变成三个月完成，并且承诺会加派招程序员。又是一个大忌，拍脑袋决定周期，也没有标杆事件控制。当天我就看到老程序员白着脸进去黑着脸出来，然后很郁闷的修改时间。不过后面的事情好玩的很，程序员来一个走一个，基本留不住人。现在想起来，当时工资实在太低了。工资低是有理由的，贝壳当时基本什么都不会，光学SSH就学了一个多月——还基本不大会用。
做产品的时候，考虑使用数据库，一下子居然挑中了oracle。现在反观，我也不知道怎么做的决策。用oracle做互联网的公司，目前为止我还没听说过第二家，因为oracle的长处在于事务和稳定性，而不是性能。由于维护麻烦，因此也没有买oracle自己的授权，而是第三方公司卖的5W的版本。就贝壳后来所知，oracle从未有这个级别的版本，他们的产品都是20W一个CPU，可以支持25个同步连接来卖的。天知道这个所谓第三方公司是怎么回事。由于配置麻烦（当时还是8），因此抽调我过去处理oracle的安装问题。贝壳就花了一个多月，把linux和oracle安装学了一遍。不过这一来，一个多月贝壳就基本没怎么写代码。一个初创公司一个员工一个月不写代码，可谓是很无谓的损失了。
更夸张的是，由于老板考虑部署的时候，立足点都是——用户太多怎么办，压根没考虑过没用户的问题。所以他开始就自己买机器进行IDC部署。偏偏普通服务器他又觉得太贵，所以还自己装服务器。贝壳再跑了好几次电脑城，买服务器装。虽然采购还是按照采购流程走的，但是又大概一周不干程序。服务器终于全部搞定上线了，贝壳大概一个月花掉了。几个月过去，老板发现进度跟不上计划，就先推迟了发布计划，然后找大家紧急开会。结论是，他加速做需求，我们加班搞定代码。可是有用么？完全没用。下面几个月糊里糊涂，贝壳都不记得自己做了点啥了。发布计划一推再推，贝壳一点信心都没有，就辞职走人了。
后来听说，在长达一年多的开发后，他们还是搞定了系统，并且正式上线销售。但是只有几个客户愿意付钱。坚持了一段时间，老板看实在赚不到钱，只有关门走人。
回顾整个里面的问题，关键是外行领导内行。做顾问的教授是内行，但不是搞互联网的，又没时间。老程序员名义上是经理，却不能否决提议。实际上是最不懂互联网的老板自己在做决策，导致最关键的几个问题上，压根没有发现决策是错的。次之的问题，是为了省钱而浪费时间。程序员出价太低，招的都是新手。买oracle舍不得买原厂带服务的，非要自己搞。服务器都不买现成的，自己组装。这里面能节约的时间，绝对不是花钱能买到的。里面还有什么老板策划需求拍脑袋，听风就是雨，甚至要求我们做一个子功能，叫做&amp;quot;中国地图在线”之类的小事就不提了。
虽说不想埋怨老板，不过贝壳确实在那家公司浪费了生命中的八个月，除了自学linux和oracle安装外没有剩下任何有用的技能。现在这段事情也被贝壳当作一个教训，很多事情不是看起来好就好的，如果事情看起来不靠谱，早点割肉退出不失为一个好的方案。</description>
    </item>
    
    <item>
      <title>关于IT雇员的一点话</title>
      <link>//blog.shell909090.org/blog/archives/1752/</link>
      <pubDate>Thu, 24 Mar 2011 14:31:35 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1752/</guid>
      <description>IT是个很大的圈子，没人敢说什么都懂，也没人什么都懂。我们都有碰到不明白的时候，都得去查资料。一个人力资源方面的有趣的问题是，公司该不该为查资料的时间付钱呢？\
技术上说，IT人员查资料是一个自我学习的过程，公司既不从中受益，也就没有为此支付薪水的必要。然而我们都忽略了一件事情，就是你招聘的员工，究竟是一个新手呢？还是一名领域上的专家。如果是领域上的专家，我得说这个技术上的说法是成立的。因为你在招人的时候，就已经知道对方的身份。并且，可以合理的假定，对方基本不用去查找资料，或者学习一些新的东西。当然，实际执行的时候，偶尔还是会发生这样的事情，不过这就不重要了。
然而多数公司没有这样的好运，好运这个词包括招聘的价格和高昂的招聘运作过程。天天投简历尚找不到工作的人也许无法理解，一个公司要招聘一个靠谱的员工到底有多困难。在IT的某个子领域，例如某种数据库大规模集群性能优化。能够谈的上足够专家，有一定经验，从而避免大部分的学习和资料查找的人，在中国的人力市场上大约也就是几千人。平摊到广袤的中华大地上，在上海的专家不足一千，不少还在大公司里。当一个公司真的需要一个能做事的人的时候，几乎没有可能找个专家过来，甚至在比较生僻的领域中连有一定经验的人都极为抢手。即便是比较通俗的java程序员，专家的招聘难度虽然不高，但是工作成本却不低。雇用一批专家来写程序是件很低效的事情。
大多数公司会雇用一批合适的人，这批人通常是高校毕业，有工作经历。这些经历可能是学校中的，也可能在小公司工作了一年。无论如何，他们会使用工作中所需要的技术，却绝对不能称作熟练。他们没有足够的经验写出工业化的程序，而且会花费大量时间查阅资料，自我学习。也正是如此，公司支付的薪水也是非常低廉的。
好，我们回到最初的问题上。我认为对于这些普通员工，公司实际上是以降低价格的方式，来让他们为学习买了单。如果再要求他们不能在工作时间查阅资料自我学习，无疑是苛求。相反，对于这些尚未成熟的程序员，最好增加公司培训，以补充高级程序员的缺口。当然，实际执行的时候必须考虑到培养成本和违约问题，考虑一些比较可控的培养方式。在中国常见的情况是，程序员培养好了，人也跑了。
说到这里，想起一个台湾朋友和我说的。虽然我们（指台湾员工和大陆员工）的能力差不多，但是台湾人，新加坡人拿的就是比大陆人多。有些人就觉得是有歧视，其实不是的。老板要求的是一个稳定的人来做事，他和我说好了两年不能离开，我就准备工作两年。他们老板我也聊过，的却向我抱怨过大陆这里招到人，培训好了人就跑了的情况。正是因为我们每个人的小小聪明，造成我们的整体信用不佳。老板不敢用，也不敢培养大陆的员工，总觉得有一天会被他们放鸽子。这种情况下我们发展到领域高阶职位就越来越难。很多东西必须是坐在那个位置上才会学到那些东西，就是所谓的“居移体养移气”。对于员工来说，长期在一些低端职位做一辈子，也是学不到高阶位置所要的东西的。大陆员工不比别人笨，但是人家一出来就做到管理者位，我们则是坐在了工位上。于是在此后几十年的人生长跑中，差距就越拉越大。
怎么办？我不是教人怎么办的，我只是说行业里面的一些现象。</description>
    </item>
    
    <item>
      <title>社区的基础规则和原因</title>
      <link>//blog.shell909090.org/blog/archives/1735/</link>
      <pubDate>Sat, 19 Mar 2011 22:03:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1735/</guid>
      <description>1.社区中的常规事务由个人申请，申请到的人全权处理问题。
2.在申请前，需要在社区公共平台呼叫请求。大致类似于&amp;quot;我要做某事了，有没有人在做或者能够提供帮助，请联系我&amp;quot;。
3.如果有人对贡献者所做的工作有异议，可以请求修改或者复议。
4.如果仍旧不满意，可以申请替换贡献者。经过全社区成员投票后就会变更贡献者。
5.如果不能明确归属的事情，或事情本身就比较重要，则由全社区成员投票。
6.如果具体操作者在不确定做法的时候，可以发起讨论和投票，获得社区意见。
为什么社区通常具有以上工作模式？
首先，社区的原则是自愿。通常社区是不会为个人的工作支付薪酬的。因此，谁愿意做什么事情，做到什么质量，完全是不可控制的。这也就是为什么社区事务是由个人申请的，因为并不能向社区中的具体人员指派工作。当一个问题比较严重的时候，也只能由资深社区人员呼吁有没有人志愿解决，而不能强行分派。这是社区为各个软件公司所诟病的特性之一。
为什么申请前需要在公共平台呼叫请求？这样首先防止了工作冲突。尤其是上游发行一个新包的时候，如果没有呼叫请求(debian社区好像叫做ITP)，就会出现两个打包者重复工作的问题。其次，如果前任因为某些因素放弃了继续处理，也许他能给你一些额外的帮助。尤其是兼容性问题上的帮助，这样比较有助于保障一致性。
为什么通常事务由申请到的人全权负责？因为一个事务会牵涉到非常多和复杂的细节问题。例如一个包的临时文件位置是使用/tmp还是/var/tmp，依赖库是使用gcc4.1还是gcc4.4。这些细节问题要一一搞定，社区没有那么多时间。如果志愿者是个熟练的人，往往问题的决策会采用比较通用的方案，社区会无条件接受志愿者的方案。当志愿者的方案比较糟糕，或者至少说有待推敲的时候。如果有人用的不爽，就会提出异议，或者更进一步提出解决方案。如果没人关心，那就让他去了。
为什么对于仍旧不满意的问题，只能替换贡献者，而不能强迫贡献者接受方案呢？因为，上文阐述了，贡献者是出于自己的自愿，来帮助社区的。强迫他们接受某个他们所不习惯的想法首先并不尊重他们，招致他们的强烈反感。其次，这些方案可能扰乱他们的工作思路。所以从这个角度来说，当志愿者愿意接受你的方案时自然好说。而如果万一他不接受，要使得自己的想法实现只有让全社区基本同意，你，或者其他人接替这个志愿者的部分工作。
为什么社区在决定性的问题上，采取贡献者民主投票的方式呢？因为，如前我们看到，社区的发展是每个贡献者提供自己的力量共同发展的。这样的社区一定会有不协调的情况。而让冲突升级，导致社区分裂，是不利于社区发展的。可以看到，社区是要讨好贡献者的。更多，更强力的贡献者，社区就能够有更好的发展。所以，采取民主投票的方式，是征求最多贡献者的同意，让他们支持社区，愿意继续为社区作出贡献。并且期待不同意的贡献者，能够理性的作出一定妥协，接受社区的大多数意见。
当然，由于意见未能统一而倒置社区分裂的情况常有发生，尤其是社区同时拥有两位强势的领导的时候，并且他们的意见碰巧相左的时候。但是在大多数时候，贡献者会考量，自己是否值得为了某个意见放弃整个社区。考量的结果往往是接受社区的结论，但是保留自己意见。这种行为会保留社区中最多的人，并且可以期待剩下的人能够接受。这一原则，我们称为&amp;quot;尊重大多数贡献者&amp;quot;。而社区中，部分事物自主可决定的规则，只是因为社区假定你的行为会被大多数贡献者接受。
我们可以看到，社区在发展中采取了很多自主判断假设和市场机制。社区需要假定你的行为是被大多数贡献者所能接受的。社区假定你能够分辨什么是&amp;quot;比较重要&amp;quot;的事情，从而需要征求多数意见。什么是你不需要劳动社区帮忙的事物。在正常的世界中，我们的假定通常都是成立的。debian社区大部分打出来的包并没有人提出异议。对于社区中文名定名或者下一开发版代号之类的问题，通常也是社区协商确定后再行处理的。因此，我们的社区通常工作良好。但是在某些特例下，例如有人无法理解什么问题是重要问题，哪怕大多数的人对这个问题的认识并没有困难。或者，更进一步说，有人捣乱。在这些特例下，社区往往会陷入一种比较混乱的状态。国外经常有所谓&amp;quot;民主效率低于专制&amp;quot;的结论，就是这个现象的集中爆发和体现。</description>
    </item>
    
    <item>
      <title>在中国，高薪养廉是个伪命题</title>
      <link>//blog.shell909090.org/blog/archives/1628/</link>
      <pubDate>Thu, 02 Dec 2010 10:23:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1628/</guid>
      <description>高薪养廉的基础逻辑是什么？公务员薪水不够高，就无法维持公务员的廉洁，所以需要给高薪。
恕我直言，在哪里，这都是个伪命题。我们可以看一下这个命题前半部分的逻辑，应用德.摩根率后，我们的结论是“公务员廉洁，他的薪水必定够高”，而不是“公务员薪水够高，就可以维持公务员的廉洁”。在中国，关于后者，有个再直观不过的反例。中国被判刑的高级公务员的涉案金额是多少？上千万算少的了吧，虽然这些钱不能算薪水。但是一个人，弄个千万还不能维持自己的生活么？如果可以，怎么会出现超过千万的贪腐的呢？
高薪养廉的基础，是公务员无法通过权力获得灰色收入。在这种情况下，如果只维持低薪，干的比狗累，活的比猪惨的工作势必会搞到没人想去。哪怕维持社会上的平均工资，公务员也是没有任何吸引力的。拿一样的钱，被一个老板盯着和被一群老板盯着是完全不同的两个概念。如此一来，要维持有足够的人来进行工作，势必需要将公务员的工资提高到正常工资以上。
新加坡在这类基础上，提出了一个类似保险的概念。通过加重查处贪腐的力度，和执行高强度的惩罚机制来抑制腐败。而且规定公务员很大程度上的工资都会被转移到公积金和养老金中，一旦被查出来，这些钱都会被归零。我们可以想见，高强度的惩罚机制会严重的吓阻人才进入公务员领域。花了公家2000要判刑四年？鬼才愿意去干。在这种重刑下，为了能保持公务员人数，唯一的路子只有“高薪”了，这才是高薪养廉的原始逻辑。
在中国，先把权力监督机制和执行高强度的惩罚做起来再说高薪养廉。</description>
    </item>
    
    <item>
      <title>ubuntu release party</title>
      <link>//blog.shell909090.org/blog/archives/1599/</link>
      <pubDate>Mon, 01 Nov 2010 09:34:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1599/</guid>
      <description>会开完了，流水帐就不记了，总结几点问题，以后注意。
1.抽奖程序可以当场写，逻辑一定要事先验证。这次抽奖程序的逻辑出现了重大误差，所有值抽完后才去更新命中集合，导致样本空间和总空间相差不大的时候重复中奖。
2.人无任事事不应人。志愿者不知道应该做什么，求助者不知道应该找谁。那天Thomas说他忙不过来，但是其他人又聚堆聊天就是个明证。
看上去找个专门的人进行前台咨询是个很有道理的做法，最好找个MM，问明白求助者的意图后推给合适的志愿者。
3.位置错误。大会上的人基本分成两群，一群是lug里面的，或者在圈子里面的熟人。另一帮则是专门跑过来的新手，还有当地的学生。前者在左侧大门聊天，阻挡后者的视线。大会的基本目地就是增进交流，聚众聊天无可厚非。但是聚集在显示屏前位置很不合适，这主要是因为圈子里的人基本在第一排入座，互相一找就聚在了显示屏前。
这种问题纯是现场场地问题，下次应该找个不干扰的开阔地给圈子里的人扯淡用。
4.秩序混乱。在一等奖领奖的时候，出现了一个人上去拿了东西，发现给错人的状况。
主席还不知道cheng说了一点很要精确的观点，我们没有事先登记。类似大会应当设立前台登记并发放名片卡和编号，这样做有几个好处。首先是组织方获得了潜在的用户名单，其次是大家互相交流的时候比较直接，至少知道对方怎么称呼，最后是抽奖的时候不会出现自行核对号码的难题。这次是按照座位号，没有出现太大混乱只能说受众素质还不算太低，或者我们的奖品他们不感兴趣。否则以中国人的聪明，只要座号相似，大家上去浑水摸鱼主办方也是有口难言。
5.缺乏引导。这个问题最严重，主要是30人的三等奖领取混乱，礼品发放混乱和哄抢。
礼品发放混乱和哄抢和三等奖的领取混乱是类似问题，都是组织者没有合适引导。Thomas认为这是个素质问题，我觉得这应该是组织方问题。任何open party，对应低素质人群是基本预案。中国人的一大毛病是只会听别人口号行事，没人喊口号就不知道该怎么动了。三等奖的时候大家还不错，总算都是从左边上台。虽然情况稍稍有些凌乱，还在可接受的范围内。要是有几个右边上台的，情况就更乱了。而且没人说的话，台上的人也不知道要不要留一下，让下面拍个照什么的，还是直接下去。奖品发放也有类似问题，没人告诉拿奖品的人，奖品数量，怎么排队，怎么退场。就看到半个场子的人一拥而上，Thomas瞬间被淹没了，然后在那里狂喊大家守秩序，有点素质。问题是这时候，谁知道秩序是什么东西呢？通常应当事先告诉拿奖品的，有多少奖品，从右边排队，领取后不要停留，左边快速退场，并且派人规劝。虽然即使这么做了，也不一定保证顺利，但是场面功夫还是要做的。
总结一下几点可改进的要点：
1.事先一定找人发卡片，让用户填写后挂在自己身上。组织方可以自行留录副本。
2.找个专门的，不影响活动的区域给志愿者。
3.找个前台MM，所有问题都找她，她再介绍专家。
4.事先验证抽奖程序的逻辑，这个是我的问题，自行解决。。。
5.除了主持人外，要有适当的人作为台下的协调和引导者。
不过总体来说，这次release party的效果还不错，社区组织发生混乱本来就在意料之中。多来几次组织者有经验就好了。
另外，事后我们集体跑去Thomas(不是台上的鬼鬼小朋友，而是Debian的DD，他的名字是法文，s不发音)家里扯淡吃东西，打德州扑克打到三点。贝壳第一次玩，赢光了其他所有人的钱，哈哈哈哈哈哈哈哈。</description>
    </item>
    
    <item>
      <title>不靠谱</title>
      <link>//blog.shell909090.org/blog/archives/1506/</link>
      <pubDate>Mon, 18 Oct 2010 10:51:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1506/</guid>
      <description>在公司中，有这么几种不靠谱行为，粘上就容易身败名裂，具体程度和人品以及不靠谱程度有关。以下排名分先后。
1.自以为是的客户需求。主要是说由程序员来搞的需求，以为搞的挺好，其实客户完全不鸟你。
2.老板定的开发周期。不用说，就像色狼为美女挑的泳装，肯定太紧。
3.废物员工。不怕神一样的对手，就怕猪一样的队友。不但没有贡献，只会拖后腿。
4.迫于压力不写文档，延后文档或者仓促写。都是废品产生的先兆。
5.过于激进的架构设计/技术选择。听起来挺好，问题是，您能玩的转么？
6.指手划脚的客户。神一样的对手。
7.钱不是问题。问题是没钱。</description>
    </item>
    
    <item>
      <title>代码过程管理</title>
      <link>//blog.shell909090.org/blog/archives/130/</link>
      <pubDate>Thu, 05 Aug 2010 14:39:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/130/</guid>
      <description>无论是做产品，还是做项目，无可避免的要碰到代码过程管理的问题。这个问题主要是平衡产品质量，生产速度，开发投入的关系，并且设法增大乘积。
通常来说，质量，速度，投入三者是互相矛盾的，有的时候还要加上风险。质量越高，速度越快的生产过程，其投入也就越高。但是这几个关系并非单纯的并行替换关系，正如人月神话中所说的，人月这个单位暗示人和月是可以互换的，但实际不是。项目中主要碰到的问题往往是，在控制质量不变的情况下，增加投入不能提高速度。在控制速度不变的情况下，减小投入不能降低质量。偶尔，我们想方设法找到了一个方式，能够很好的满足质量-速度-投入的三元平衡，但是时灵时不灵，这就是风险元的问题了——通常情况下我们不会碰到。
作为平衡三者的起点，你不能从项目/产品的开始才考虑这个问题，而是必须从招聘/团队组建的时候开始考虑。一个不靠谱的人就会破坏整个团队，所以在招聘的时候，保持宁缺勿滥的思想。通常的项目/产品并不需要一堆天才，你只要一堆能够良好执行计划的员工就行了。靠谱的人的有几个要点，能够比较好的进行沟通，良好的计划制定和执行能力，大量的编码训练。有的时候我们往往以工作年限来衡量一个人的编码训练，实际上编码训练和工作年限并没有特别大的关系。好的项目经理/产品经理，应该能从编码的设计和实现中，嗅出编码训练的程度。
坚持只招聘合适的员工，事实上是以增大人力资源成本来解决速度-质量问题。因此通常只会被用于质量不变的情况下，增加投入提高速度。不幸的是，要实行这个步骤往往必须在项目的开始前进行计划。因此项目的正确做法不是添油战术，而是减油战术。减油战术的要点是强迫项目使用它天然能够使用的最多人手，使得项目处于人力资源相对充足的状况。再设法控制每个人的工作周期，不要让被分配的人做和他特质不吻合的工作。例如程序员完成编码后，不要让他去做文档/测试的工作，而是提前撤出项目。如果项目顺利，逐步撤出闲置人手组建其他项目，并保持项目依旧按时完成。如果项目仍旧不顺利，至少我们做到了我们能做的最快速度。
同时，这个战术涉及另外一个问题。我们都知道，越大的项目，需要的人手越多。而越多的人手，每增加一个人所能提高的效益就越低（俗称边际降低）。因此，平衡三者的另一个要点是切分项目，使其拥有完美的边界。假如一个系统，我们需要12个人工作半年。我们将其切分为两个相对独立的子系统，每个系统分配六个人，通常不用半年就可以完成项目。正常来说，项目所需资源随着复杂度增加往往是三次方到四次方增加的，而项目切分有助于使得前者随着后者线性增加。切分的优劣只取决于其边界的清晰程度和复杂程度，和需要多少人手，如何分配等等问题皆不相关。
在完成上述几个步骤后，我们就拥有了完美完成项目的一个起点，合适的成员，充足的人手，适当的边界。不幸的是，通常我们无法做到这么完美，成员不都是适当的，人手是不足的，需求是修改的，所以边界是模糊的。那么在整个代码过程中，我们依旧有一些可以做的事情。
首先是问题的早期发现，方法是代码规范，单元测试和交叉检查(cross check)。通常建议将人手编排成水平交错的一个环，按照顺时针方向，由一个人检查另一个人的代码。交叉检查有三重目的，帮助新手学习编码，抑制不小心和设计失当所造成的错误，当其中一个人无法工作时有人可以接手其工作。虽然这将付出一定时间，但是可以比较好的在前期发现和控制问题。同时，按照逆时针方向，编写另一个人的单元测试代码。单元测试有助于隔离问题范围，减少在实现中的一些无聊问题。
其次是问题的快速沟通和持续聚焦在工作上。强迫所有人每天写下需要处理的问题(todo list)，然后每天勾掉解决的问题。这方法可以从各种GTD书籍上看到细节。同时，每天召开快速例行会议。将当天处理掉的todo list，碰到的问题和解决方法读出来。快速的沟通方便在早期把握员工的心不在焉，同时也方便其他员工发现潜在的可能与其相关的问题。
最后就是快速文档和后期文档相结合。在项目过程中提倡快速文档，即写下某个问题相关的精简描述和姓名，方便其他人联系你即可。在项目完成后，逐步补充文档，细化条目成为完整的文档。</description>
    </item>
    
    <item>
      <title>领导的艺术</title>
      <link>//blog.shell909090.org/blog/archives/96/</link>
      <pubDate>Tue, 23 Feb 2010 17:19:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/96/</guid>
      <description>啥都不说，先上背景阅读。
帕金森定律
英国著名历史学家诺斯古德・帕金森通过长期调查研究，写出一本名叫《帕金森定律》的书。他在书中阐述了机构人员膨胀的原因 及后果：一个不称职的官员，可能有三条出路，第一是申请退职，把位子让给能干的人；第二是让一位能干的人来协助自己工作；第三是任用两个水平比自己更低的人当助手。这第一条路是万万走不得的，因为那样会丧失许多权利；第二条路也不能走，因为那个能干的人会成为自己的对手；看来只有第三条路最适宜。于是，两 个平庸的助手分担了他的工作，他自己则高高在上发号施令，他们不会对自己的权利构成威胁。两个助手既然无能，他们就上行下效，再为自己找两个更加无能的助手。如此类推，就形成了一个机构臃肿，人浮于事，相互扯皮，效率低下的领导体系。
曾仕强似乎说过，一个能干的干部起什么作用？一个能干的干部只能证明他的所有下属都是白痴。
所以，从上推导，我们只要找一堆傻瓜当干部，公司就能兴旺？</description>
    </item>
    
    <item>
      <title>关于程序的一点想法</title>
      <link>//blog.shell909090.org/blog/archives/416/</link>
      <pubDate>Sat, 13 Oct 2007 07:06:16 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/416/</guid>
      <description>以下内容六牙四皂小姐可以看看，至于看的懂看不懂不负责。
程序届有个说法，只有你想不到的，没有我做不到的。当然，程序是基于数学的。如果违反了数学的基础理论，程序还是无法实现的。可程序又不同于数学。说穿了，程序有一个时间，成本和环境的限制，有的时候还有法律问题。理论上说，任何一个水平足够的人都可以写一个windows出来。但是，首先是一个人写需要多少时间。其次是这些时间，还有其他投资(例如电脑)所造成的成本。然后是这个windows所能运用的环境。当然windows也许没有这个问题，可如果是程序就必须考虑适用系统(Windows,*nix)，字长(32bits,64bits)等等限制。最后，一个和windows一样的系统是否会侵犯了微软的版权？
对于程序员来说，可能这些都不是问题。程序员面对的是明确的目标，环境，解决方法和框架。他们要解决的是按照构思来实现功能，并且按照算法来构建代码。例如一个播放器，对程序员来说可能就是一个确定的接口，向里面写入固定格式的数据。或者引用某种算法读取压缩数据，解压为通用数据进行播放。或者是实现解码器的注册和管理。这些都是已经被严格确定了的目标。程序员有一个固定的环境，一个统一的框架。解决方法或者是被说明的，或者是不言而喻的。
可是由一个抽象的需求来获得一个明确的目标，并且确定环境和实现方法由谁来做呢？一般这些人被称为需求分析师和系统构架师。需求分析师的工作在于帮助用户确定需求，分析需求的可能性产出(例如播放器中是否需要一个屏保屏蔽功能)，分析系统的目标环境。这些任务更多的是出于用户角度考虑的，主要是我需要做什么(what,
why)。系统构架师则是一个对称的职务。其主要职能在于确定如何使用目标环境中的各种技术实现目标需求，使用这些技术完成目标需要多少时间，多少成本，是否引发法律问题。等等等等。这些问题更倾向于从程序员角度考虑，主要是怎么做(how,
when)。
当然可能没有这种职位，但不可能没有这种职能。有的时候分析和构架是由项目经理兼任的，有的时候是由客户驱动的(尤其是外包的时候)。至于完全没有的时候，就只有将需求分解为零散的问题，对问题求工具了。理论上说这是一种很好的方法，强大的bash语言体系其实就是由一堆解决细节问题的工具组成的。问题是，这种情况下，对于工具的使用者就提出了很高要求。往往会把工具的使用者变成另外门语言的使用者。例如我们看电影，一般用户只是点开就看而已。如果是针对问题求解，可能我们会出现一个播放容器，一个编码分析器，一个视频解码管理系统，一个音频解码管理系统。最后还需要一个注册器来关联适当属性的播放容器和某种文件类型。从软件结构角度，这样的软件有利于构架和编写。可从用户的角度，这是最差劲的播放器。事实上，mplayer就属于这种播放器。我们用起来觉得简单是因为一些高手制作了一些预先设定的包，将所有组件关联起来。
我们回到原本的问题上来。如果用户驱动了系统的构架，那问题自然不大。只需要制作方评估系统规模，然后按照规模给出成本和时间。双方讨论一个可以接受的成本和时间，东西就可以做了。至于客户变更了系统，那自然有相关的人员会重新评价，给出新的成本和时间。问题是如果约定不清晰，可能会造成比较大的麻烦。例如客户认为他们给出的解决中必须实现某个东西，而程序这里认为是最好实现某个东西。那就扯不清楚了。因此一般建议编程人员向客户要求一份详细的制式计划书，然后双方签字确认。根据合同法规定，如果制式合同中出现纠纷，应当被解读为不利于提供方的方式。倒过来显然是不行的，既不能指望编程人员提供计划书，也不能指望客户不会对计划书随便解释。
如果是由非客户的分析和构架人员来做系统构架，那么情况就复杂了。问题实质上其实变成了五方会谈。客户方，代表客户方的需求分析师，制作方，代表制作方的系统构架师，还有程序员。看起来有点重复，但是其中都有利害关系的。客户方希望需求分析师提出尽可能多的需求，因为这样才能产生好用的软件。系统构架师则希望需求分析师提出尽可能少的需求，这个才容易制作和维护软件。制作方希望系统构架师提出尽可能高的成本和时间预算。这样有充裕的时间制作，不会制作失败，还可以多赚钱。但是客户方不会喜欢很高的成本和迟到的软件。程序员希望系统构架师给出的解决方案足够清晰，而且改动少。系统分析师总喜欢在程序员的失败中改进方案，因为简单啊。客户方希望程序员给出完整的文档和后期维护，但是程序员都不喜欢写那东西。
所以需求分析师往往会提出一堆怪怪的功能，即使这东西一般人八辈子用不到。系统构架师往往会提出高的吓人的成本和时间预算。和股指差不多吧，没几个有脑子的相信。真正的成本和时间就会在客户和制作的吵架声中被确定，并且往往成本高出正常值，时间低于正常值。程序员就在一次次的咒骂声中修改系统，并且经常忘记跟着修改文档。客户拿到手的往往是一个延期了再延期的系统。它们十有八九跑的起来，刚好可以完成预定目标。只是往往会有一些Bug，并且只有不同步的文档。系统就会在客户的抱怨声中被退回，而且客户还会追加两个需求，加上句“钱不是问题”。制作方看在孔方兄的面子上，往往也会说“保证完成任务”。系统修改的结果往往是Bug越改越多，文档越改越老，系统越改越奇怪。最后系统分析员往往会找到一个下家而跳槽，客户往往会因为钱是问题而拖帐，制作方往往会保证完不成任务，程序员往往会抱怨天天加班，唯一没问题的需求分析师往往是客户亲戚兼任的。
到底是哪里出的问题？</description>
    </item>
    
  </channel>
</rss>
