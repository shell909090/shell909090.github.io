<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>crypt on Shell&#39;s Home</title>
    <link>//blog.shell909090.org/tags/crypt/</link>
    <description>Recent content in crypt on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Tue, 27 Jan 2015 22:19:37 +0800</lastBuildDate>
    
	<atom:link href="//blog.shell909090.org/tags/crypt/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Charlie and Dave</title>
      <link>//blog.shell909090.org/blog/archives/2720/</link>
      <pubDate>Tue, 27 Jan 2015 22:19:37 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/2720/</guid>
      <description> 公司希望弄一套双授权的安全系统，老大提供了一套算法，求大家review。如果这个方案确实可行，那么我们会做完然后开源出来给大家用。
Author and License Author: 韩拓 保留所有权利 All Rights Reserved
以下内容不以cc-by-sa3.0发布。(因为根本不是我的创作)
场景  Alice希望登录到Bob上执行操作。 两者的基本控制协议为ssh。  假定  攻击者名叫Mallory。 如果Alice的私钥泄漏，管理者必须有权停止Alice到Bob的访问而不需要更换所有Bob的公钥。 除去Alice和Bob外，参与通讯过程的所有机器(即下文中的Charlie和Dave)中可能随机被攻破一台。 服务都在内网，但是如果网关和被攻破的机器是同类系统，Mallory即可具有内网监听和伪造数据报文的权限。 Alice不会利用获得的Bob的权限故意执行危害性指令(但是可能被诱骗)。 Alice和Bob不会被攻破。  方案 假定有两台机器，Charlie和Dave，Dave和网关不得是同类系统。根据假定4，两台机器不会同时被攻破。
 Alice通过SSL和Dave建立连接，上报自己的用户名，需要访问的设备和帐号，并提交一个临时生成的ssh pubkey(username, account, host, pubkey)。 Dave根据预先设的IP-username-sslkey验证用户身份为Alice，并且根据ACL确认其具有访问权限。 如果通过验证，那么Dave用自己的key，通过SSL联系Bob上的某个程序，将Alice的pubkey提交到Bob的合适帐号上(account, pubkey)。 Bob通过sslkey验证提交者确系Dave，将pubkey临时加入account中。 Bob完成此事后，通过Dave向Alice返回成功。 Alice通过SSL和Charlie联系，上报自己的(username, account, host)。 Charlie根据预设的IP-username-sslkey验证用户身份为Alice，并且根据ACL确认其具有访问权限。 如果通过验证，那么Charlie用自己的key，通过SSL联系Bob上某个程序，为Alice开通到Bob的22端口的tcp盲转发。 Alice利用开启的tcp通道，和自己的临时ssh private key验证登录Bob。 在Alice连接Bob上的程序后，删除alice留在Bob上的临时pubkey。  验证 假定Charlie被攻破。
 方案1-5没有影响。 Charlie拥有能够在任意一台机器上开启盲转发的权限。 但是Charlie并不能影响Dave去添加pubkey。  假定Dave被攻破。
 Dave拥有在任意一台机器上添加pubkey的权限。 但是Dave并不具有打开到任意一台机器ssh端口的权限。  </description>
    </item>
    
    <item>
      <title>用户友好的密码</title>
      <link>//blog.shell909090.org/blog/archives/2430/</link>
      <pubDate>Thu, 13 Jun 2013 15:19:31 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/2430/</guid>
      <description>用户友好的密码 何谓用户友好的密码？我是指在密码中尽量不给自己找麻烦，又能正常使用。
 不包含空白字符。否则你会烦恼有哪个空白字符，有几个的问题。 不包含特殊字符。否则会烦恼怎么输入。 不使用容易混淆的字母。不容易输入错误。 方便手机输入。  尽量少包含大写字母。 只包含容易在手机上输入的符号，或者不输入。   手机上容易输入的符号 在android上，以下符号可以在google输入法中直接输入。
@*+-=/#()&#39;&amp;quot;:?!~  总计15个。估计加上iphone后会更少。如果要用符号，建议从这些里面取，会减少你很多密码输入的烦恼。
容易混淆的字母  Il1 0O 连续的mn 连续的wv  强度规范 我把密码管理规范里面的结论总结一下，略去推导，凑凑数，把密码级别排列成以下几个：
 弱密码：不希望别人看到，然而别人看到并没有直接损失的内容。熵应当在20bit以上，五年修改一次。 中密码：不希望别人看到，别人看到会对你产生损失的内容。熵应当在33bit以上，两年修改一次。 强密码：有价内容。熵应当在45bit以上，一年修改一次。同时作为弱本地密码规范， 本地密码：熵应当在58bit以上。  每个级别之间大约差12bit的熵。初始熵强度至少20bit，低于这个水平就很难说这是一个密码了。
强度估计 以最容易使用的密码计算，符号应当最多包含26个字母+10个数字，排除l10这3个。每一位有33种可能，熵大约是5多一点。
 弱密码：至少4位。 中密码：至少7位。 强密码：至少9位。 本地密码：至少12位。  更强一些的密码可以用52个大小写字幕+10个数字，排除Il10O这5个。每一位有57种可能，熵大约是5.8。
 弱密码：至少4位。 中密码：至少6位。 强密码：至少8位。 本地密码：至少10位。  建议 网络：
 弱密码：4位小写字母+数字，5年修改一次。 中密码：7位小写字母+数字，2年修改一次。用于保护大部分内容。 强密码：8位大小写字母+数字，1年修改一次。保护重要内容。  本地：
 低：8位大小写字母+数字。 高：10位大小写字母+数字。  注意避开Il1O0，以及其他可能的混淆方式。</description>
    </item>
    
    <item>
      <title>加密学中一个规定的来历</title>
      <link>//blog.shell909090.org/blog/archives/2066/</link>
      <pubDate>Mon, 16 Jan 2012 03:24:54 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/2066/</guid>
      <description>为什么密码学中总有个假定，算法是对方已知的，密钥是可以更改的？
因为在很久以前，密码算法是靠人工运算的，更改算法每次都需要培训一堆人，很麻烦。所以变态的需求催生了变态的解法——算法彻底公开，靠密钥保密。
还记得很多谍战片中的“密码本”么？如果在现代，那就只一个记载着256个字符的纸条。因为整个过程其实地球人都知道，双方只是相差一个纸条上的256个字符而已。
觉得这点东西不靠谱，随便记忆一下就搞定了？你想想，以前的密码本也可以照相阿。是重建一个密码本，并且分发给各处安全，还是重建一个纸条并分发方便？
现代？其实还是很有意义的。因为很多遗留系统/硬件模块中的算法会长达10多年不变，如果依靠算法保密来保护安全性，哪天泄露了不是开玩笑的。上千万的硬件模块，没有人维护的遗留系统，都要整死人的。
而且算法本身也必须足够强，如果没有公开算法，“足够强”这个事情本身就是含糊不清的。没有人见过你这个算法，没有人讨论，谁知道是不是“够”安全呢？md5以前一直作为哈希的标准，我们都觉得够安全了，但是哈希碰撞的研究使得现在基本都推荐sha256了。同样，DES也不要再用了，换成AES吧。</description>
    </item>
    
    <item>
      <title>哈希冲突漏洞的原理和对策</title>
      <link>//blog.shell909090.org/blog/archives/2052/</link>
      <pubDate>Wed, 04 Jan 2012 03:59:57 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/2052/</guid>
      <description>cpug上面最近在讨论一个严重级漏洞，漏洞的相关资料如下： ERT-VN:VU#903934 CVE-2011-4815 CVE-2011-3414 CVE-2011-4838 CVE-2011-4885
上面主要讨论的是这么一个概念，当用户post一个数据，而且这个数据又是一个form的时候，应用需要先将form解析为dict，然后才能方便的使用。例如a=1&amp;amp;b=2，可以解析为{&#39;a&#39;:&#39;1&#39;, &#39;b&#39;:&#39;2&#39;}。之所以1和2是字符串，是因为只有用户自己才清楚这个数据的类型。
通常情况下，这个form的key都是随机的，生成的hash碰撞概率很低，因此dict的默认实现——hash table没什么问题。但是当攻击者恶意构造数据的时候，情况就完全不同。我们首先讨论一下hash table的实现——开链法和二次探测法。
所谓开链，就是指对所有同余hash，将他们挂到一个hash表项上，形成一个链表。而所谓二次探测，就是在第一次hash冲突后，再进行一次hash，作为第二地址。
开链法对碰撞冲突是有先天缺陷的，因为同余碰撞的构造远比hash碰撞的构造简单。假定hash
table有11个表项，那么平均11次尝试就可以得到一个元素，和原始元素hash同余。如果选用这样的恶意key序列，在执行构造的时候，hash
table就退化为了链表。链表的插入复杂度是O(n\^2)级的。而作为攻击者，为了获得n个hash同余对象，所需消耗的复杂度做如下估量。首先考虑hash table length和n同阶，因此以n作为hash table长度。这样每n次尝试就可以获得一个恶意元素，获得n个元素的复杂度为O(n\^2)级。
也就是说，即使是sha256这样强的hash算法，只要保证哈希函数特性，对同样的值得到同样的哈希，就无法保证开链法的安全。
而二次探测法对这个是有先天抵抗的，二次探测法的第一次碰撞并不难构造，但是第二次哈希后依然保持同余的构造难度就由n增加到了n\^2，多次碰撞的构造难度以此类推。虽然我没有完整的计算过这个值，但是猜测难度量级应当是O(n*n\^n)级别的。这个级别基本就不用玩了——前提是哈希算法必须是安全的。
由于为了节约计算过程，因此python和php的hash算法都没有采用md5之类的高散列算法，而是一个很简单的算法。我摘抄一下Python2.7.2中的这段代码。python_string_hash.c
static long string_hash(PyStringObject *a) { register Py_ssize_t len; register unsigned char *p; register long x; if (a-&amp;gt;ob_shash != -1) return a-&amp;gt;ob_shash; len = Py_SIZE(a); p = (unsigned char *) a-&amp;gt;ob_sval; x = *p &amp;lt;&amp;lt; 7; while (--len &amp;gt;= 0) x = (1000003*x) ^ *p++; x ^= Py_SIZE(a); if (x == -1) x = -2; a-&amp;gt;ob_shash = x; return x; }  按照&amp;lt;python.</description>
    </item>
    
    <item>
      <title>密码三文的补充</title>
      <link>//blog.shell909090.org/blog/archives/2044/</link>
      <pubDate>Tue, 27 Dec 2011 10:01:11 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/2044/</guid>
      <description>前两天写了两篇关于密码的文章，其实没说什么，都是程序员的常识和经历。实话说比较有意思的是大家的反应。
一个是，大家为什么纷纷盯上了第一条？我在写的时候，主要考虑的最多的是第五条，就是网站本身方便盗窃其他网站资料，或者为网站本身提供便利。具体可以看某个投诉知乎的帖子。但是来的人几乎无一例外，都在和我讨论第一条。我不知道理由是什么，大家都觉得政府这么值得怀疑么？实际上，除非政府觉得你有资格收集密码，否则基本没有听说密码必须明文存放的潜规则。你想想，你在国内搭建一个小论坛，需要备份明文密码么？
上级要求明文密码的过程大概是怎么发生的？我听一个朋友聊天的时候说到，网管部门要他们系统上某个用户的密码原文，还必须是原文。当然，作为管理部门，是不需要解释原因的。他们表示，密码都是md5之后的。做不成，对方也没有什么表示。后来老板说，设计系统的时候，密码就用明文吧。从这个闲扯中反推，我大概能窥见事情是怎么发生的。不过神奇的是，这个简单的事情，怎么会发展成“网管部门有保存明文密码的要求”的，我描述的太模糊了？
另一个是无所谓的忧虑。我发现很多过来的搜索都是“哪家银行明文保存密码”，还有朋友加我gtalk问我google是否安全。实话说我觉得大家太多虑了，而且考虑方向还错了。与其考虑谁明文保存密码，不如先无良的假定“你们都是坏人，密码都是明文”。然后再想，我的钱是不是还安全？我的系统是不是还安全？我要不要关注这个安全？你指望对方设计的时候使用了hash，多重hash，salt，还不如指望自己的密码强度足够，而且符合使用规范。
密码是什么？从信息学角度说，密码是某个密码空间中的一个随机值。你和服务器约定，提供这个随机值，服务器就验证你的身份。从这个角度说，每两个实体间验证身份都需要一个独立的随机数，而且这个随机数空间还必须够大。现在的主要问题，是大部分人对这个值的选择太过有规律，太过简单，而且更危险的，对所有场合使用同一个值。如果真的需要使用同一个密钥，除非你的密码体系是公钥体系。否则即使是challenge-response模式，也有差分攻击这个问题。
另外顾虑google的那位朋友就有点神经过敏了。当年google退出中国的理由是什么？被攻击。作为一个被攻击后，事情没人知道的情况下，反应这么大的公司，无论如何比其他闷声不响的公司更加重视安全，也应当更加安全吧？你们知道索尼的网站也有密码泄露么？你们知道国内网站在这次之前有多少入侵事件么？在事情没有曝光前主动反应的，google是最大，最严重的一家。如果他不可信，我觉得要找另一家可信的公司就更困难了。</description>
    </item>
    
    <item>
      <title>网络安全——你需要知道的东西</title>
      <link>//blog.shell909090.org/blog/archives/2038/</link>
      <pubDate>Fri, 23 Dec 2011 12:00:41 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/2038/</guid>
      <description>首先，我也不是专家，如果里面有什么错漏，欢迎补充。补充和转载请注明我的blog: http://blog.shell909090.org/blog/，我会根据你的发言在上面直接修改，没同步过去可不赖我。
要安全的使用网络/服务，你所需要注意的头两个问题就是你的安全级别和客户端的安全级别。对于零级密码，你随便在什么客户端上输入，都没有关系的。但是网银之类的最高级别密码，你不能在不可信机器上输入。什么叫不可信？别人的机器，你要相信这个人的技术和人品。自己的机器，你要在上面装了杀毒软件，没有执行过各种奇怪的程序/小游戏。这才叫可信的终端。如果你的密码在别人机器上用了，回来马上修改密码（不要在对方那里修改，没意义）。最好的方法，就是找一台旧电脑，专门装一个系统，装杀毒，用来使用网银和各种安全应用。别用深度定制版的操作系统，别人用过就重装。
当然，大多数的人都觉得，这样好麻烦啊。好吧，你可以无视这条规则——只要你对下面的各种病毒隔离和恢复措施做的够到位，对自己的技术够自信——至少我还没有这个自信。或者你可以认为我在危言耸听，彻底无视我的建议。大部分的情况下，你都是对的。这些事情都是徒劳的白做工。不过很低的概率下，你会中招——自己考虑。
其次，不要使用不可信的服务/产品。这条的执行力度自己考虑。一家公司，曾经做过流氓插件，你用不用他的产品？一家公司，曾经被央视曝光，你用不用他的产品？一家企业，敢于劫持客户的数据，将内容替换成自己的广告，你用不用他的服务？很多时候，我们都是别无选择，只能听天由命。不过当你有的选择的时候，尽量使用名声比较好的公司的产品。也许你觉得——这个不重要。好吧，Who care是最大的无力。
接下来，你要注意你的个人信息。被各个地方窃取使用个人信息已经很无奈了，你自己再爆出去就是无语了。你有没有在开心上公布手机号？有没有公布自己生日？有没有写自己的邮箱地址？有没有说过自己的家庭地址？这些信息都会被用于社会工程攻击，例如伪装你朋友的邮箱给你的邮箱写信，说借我二百。。。别笑，从开心上很容易收集这样的数据，伪装和发送也很自动。
后面一点对一些普通人可能比较困难——你要区分什么是可以信任的，什么是不可信的。下面的事情你权当笑话去听，是否照做自己判断。
1.来电号码是不可信的，来电无法验证身份，短信和电子邮件也不行。如果你的一个朋友来电或者发消息说让你干什么事情，认证身份的最低办法是打回去。更加通用和安全的方法是共同知识验证——哎，大学的时候，我们隔壁宿舍摔断胳膊那哥们当时干啥摔断胳膊来着？伪装者怎么知道TM那倒霉孙子胳膊是怎么断的？通常人人上也不会说这个吧——除非丢的正好是人人帐号。
2.传票是邮寄到家的，公安局找你都是上门或者通过街道。如果有人电话给你说是某法院/公安局，你不妨要他的电话和部门名称，然后打114查号，再打过去。通常情况下，不管也行——真有问题他们会上门找你的。
3.网站什么都不能说明，即使那个网站里面有所谓的标识。例如qq.c0m（假如这个注册的出来的话）不代表腾讯，这个上面有人说你中奖一点意义都没有。即使来源真的是qq.com，那也不代表事情是真的。同样，靠谱的方法是要他的号码和部门，114查证后打过去。
4.400电话打过去都不可信，你要是打一个400电话，和打一个民居没什么区别。对方有个声音很好听的小姐接听，还有——请稍等，我为您转接一位同事——也一点意义都没有。号码来自百度也没意义。
5.用114电话比用百度的好处是，百度给钱就可以瞎排，这个都上央视了。114目前我还不知道有什么竞价排名的东西，所以你找一个电话多数都是靠谱的。注意，这个不绝对。
6.手机这东西少借给别人，尤其是不熟悉的人。里面多个窃听器发信器你都不知道是谁干的。现实中没那么玄乎，也就是拿你的卡号申请动态令牌，申请前找你借五分钟手机而已。
7.软件怎么判别是否可信？通常来说，敢开源的都是比较可信的，毕竟里面干了些什么大家都看的到。闭源的软件和服务就看你是否信的过这家公司了。
8.对于别人推荐的玩意，尤其是朋友推荐的玩意，你最好确定一下确实是本人推荐的。即使是，我也保留的打开——技术上说，就是专门找台机器来运行。
9.有的时候，要敏感。你打给一家订票网站，他们需要你的身份证和信用卡号，给不给？实话说，这是个风险，而且不小。很多人的问题不是评判失误，而是根本没意识到这样做的风险。要知道，目前一代身份证还没有完全废弃，万一对方拿你的身份证号伪造了一张身份证，然后申请重置密码之类的事情。虽然能不能成两说，但是这两个号码同时泄露给一家网站总归是个风险。同样的还有携程——去年我曾经向他们的客户经理投诉，他们的电话语音系统居然要我人工报卡号，身份证之类的。我说如果是电话输入系统还好说，人工操作万一你的接线员记下来怎么办？这个你能保证么？今年大家打携程电话去看看？虽然我没有完全信任携程，但是电话系统比人工系统的安全性总是高那么一点点——除非他们故意在设计时捣糨糊，明明是电话录入系统，还是能让操作员看到全部卡号。
其实万千方案归结到后来都是八个字，多听多看，谨小慎微。会来看这篇blog的都是多听多看的，那么只要谨小慎微就好了。哪怕这谨小慎微有的时候显得有点小人和扭曲——不敢用别人的电脑上自己的帐号，不敢打开别人给的软件，不给别人玩自己的手机。到底多谨慎，看你自己觉得自己多重要。要是觉得一人吃饱全家不饿，就算全国密码泄露也与你无关。如果你觉得自己还是有点身家，有些该坚持的问题上还是要坚持一下。
最后说一点无奈的事情。即使你上面的事情全部做到，有很多事情还是无可奈何。例如携程的问题，他们有一个业务是只需要输入卡号后四位就可以订票，很明显，这是记录过全部的卡号才可以做到的事情。如果他们的数据库泄漏，攻击者是否就可以直接从中划帐呢？外推考虑这个问题，你会发现所有输入过信用卡号的公司，无论他们是否可信，你都要假定他们保存了你的卡号信息。所以事情就只能信赖银行的信用卡系统，包括大笔消费警告，未经手消费复核，先行赔付等等。只有消费后能够复核的信用卡公司，才是可以信赖的公司。
PS:
另外做一点广告。全国各家涉密公司，如果你们不希望你们的管理员/操作员随意接触高级管理帐号，希望能够审查谁接触过用户账户信息，你可以用我们的系统。http://www.shterm.com/。我们目前做的是堡垒机密码托管，除了一个最高管理者外，管理员都不知道自己使用账户的密码是多少。同时，访问过用户账户信息会留下无法清除的记录，事后可以审查。
注意：普通用户上这套系统没用！</description>
    </item>
    
    <item>
      <title>关于密码——你们不知道的很多事情</title>
      <link>//blog.shell909090.org/blog/archives/2035/</link>
      <pubDate>Thu, 22 Dec 2011 23:32:27 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/2035/</guid>
      <description>1.hash密码安全么？
只要你的原始密码不大复杂，hash密码也完全没有安全性可言。不信？echo &amp;lsquo;abc&amp;rsquo; | md5sum，去www.cmd5.com，看看有没有。同样，拿你自己的密码试试看？
注：null同学对此提出了异议，表示这个网站的可信性也值得怀疑，不要输入你自己的密码。我考虑过后觉得有道理。从基本安全性上说，网站只能收集密钥，无法收集用户，所以密码泄漏的风险不大。从我个人来说，一个网站如果爆出hash泄露，基本等同于密码泄漏。所以本质上避免问题的方法是一次一密。但是鉴于国内很多网站还是直接使用了hash（尤其是md5）保存了密码，在这个网站上输入了密码等于将自己的密码加入了字典，从而减低了安全性。
在此，向所有被我忽悠的同学诚挚致歉。如果你在里面输入过密码，建议你将密码改为一次一密。即每个网站使用不同的密码。通常一次一密的同学不会再把自己的密码到这个网站上进行搜索了吧？
2.国内哪些网站不是明文密码。
我说出来你信么？再说，配合1，这个问题重要么？一次一密，经常修改才是王道，长度和频率看这篇文章《密码管理规范》。另外，现在记得去公布出来的密码表里面搜一下自己的密码。
3.一次一密就安全了么？
差了远了去了。你有没有在别人机器上登录的经历？你可以信任他么？你自己家里装的一堆插件你都相信么？你确定他们对你的银行密码没有兴趣？你要知道，银行开发安全插件的人和做恶意插件的人是同一个圈子的人——不会攻击就不能防范么。而且我们阴谋论一点说，你就确定这些软件商没有接到上级指令要求加入后门？现在你还敢在自己家里的机器上装中国软件么？QQ，迅雷，这些都算大软件，看着的人比较多。你自己可以搜他们抓你行为上传的文章——用谷歌搜。其他小站点的各种软件呢？你装了多少？
4.还有哪些比较低级的情况？
当年，有一个网站，提供一个功能。你可以在他的网站上直接登录其他邮箱。相信我，这可比这次的问题严重多了，那可是一收集一批阿。
5.为什么我以前都不知道？
要和你说我们有安全问题，你还用不用了？
再说我和很多人说起过这些问题，他们当年的态度都是——没关系，反正没人会对我的信息感兴趣的。我估计这次，还有不少人会说——没关系，反正我没有CSDN帐号/人人网上面的数据看到就看到咯。
很多人第一次知道安全问题的严重性，都是在他们丢了钱之后。往往都是莫名其妙，钱怎么丢的？
6.那银行呢？
银行还是相对安全的，不过你要确认银行有以下几个功能。登录失败警告功能。五次登录失败自动锁定账户，要隔天由本人解锁，解锁后最好强制更换密码。关闭网银和电话银行功能，不拿着本人身份证经过24小时以上申请不能打开。密码丢失需要一周以上的时间才允许重设。大额取款通知用户功能。
听上去很麻烦？通常来说，越麻烦的银行越安全。以上功能都有了，并且使用了，那么银行本身而言，还是比较安全的。
7.可是我要用网银。
那你用U盾，而且不要用水货版的。我07年选择招行的理由是，招行是唯一当时我觉得没有安全问题的银行。现在这个列表应该加入浦发，并成为首选——对linux友好而且不容易破解。但是不要用只有手机动态密码的模式。
有些U盾就是密码文件隐秘的放入的一个U盘，这种U盾我都可以复制出一堆来。用上这种U盾，最多满足你自己的心理因素。
而且，更好的方法是对信用卡申请网银，而银行卡关闭（如果银行支持的话）。这样的话损失最大不超过一张信用卡可用额度，我目前的信用卡而言，最多一次损失几千——总好过几万的学费吧。同类的思路可以选择支付宝，你一次打个1000进去可以用一阵，丢了只有这1000。
8.你知道U盾的正确用法么？
U盾应该在需要的时候才插上去，用完立刻拔出。虽然说不像拆炸弹，不过还是插入时间越短越好。
因为很偶尔的情况下，入侵者刚好在看你的电脑。发现U盾后，可以指挥你完成登录的网银系统进行交易。但是网银交易必须以U盾为基础，拔掉他们就干不了坏事了。
9.为什么手机不是安全设备。
手机安全是相对的，只能说比电脑安全。你以为手机就安全？首先，智能机上面已经满足了恶意软件存在的基础。例如小米——虽然我很喜欢他——你确定雷布斯没有在小米里面加入后门，截取你的密码再偷偷转发？现在没有——以后呢？同样，你确定你信得过苹果？将来苹果也不会出现安全漏洞？
即使退一步说，你的手机很安全。来，把手机给我，不要看它，然后告诉我，手机里有多少软件可以读取你的本机信息，有多少可以读取短信？即使是完全安全的系统，我只要写个小游戏，号称因为需要短信分享，需要操作你的短信。你会怀疑么？我趁着你不注意，读取你的手机，和泄露出来的卡号-手机信息交叉比对。对你的卡号申请动态密码，然后让我的程序偷偷的拦下来短信，不让你知道，发送到服务器端。你是不是丢钱丢的莫名其妙？
相信这条写到这里，九成九的用智能机的朋友已经满脸汗了——妈的这些程序能读取我的银行卡动态密码？技术上说，真可以。
普通手机用户也别高兴，我没记错的话，GSM协议已经被破解了。就是说，我可以在你旁边拿个设备直接接受你能收到的短信。这TMD叫安全设备？
10.那你说的keepass？
这东西能在手机和电脑上运行，就肯定不安全。数据文件放在硬盘上的时候没问题，即使入侵者拿到也没办法。但是你输入密钥的时候有keylogger就完蛋了。
所以我只在linux和android上用，虽然android不安全，但是目前我还不知道有keylogger。
11.妈的，我还有什么安全的。
这个真没有，RMS说过，安全是个笑话。让用户来完成安全更是笑话中的笑话。当然，没有用户的安全意识，银行/网站再努力也没用。但是本质上说，应当以侵犯隐私去起诉泄密单位，而且应该打下来是巨额赔偿。
然后这个事情就会变成，各家单位纷纷表示，我们不对免费用户的信息安全负责，并且推出免责条款。然后又是扯不清的糊涂帐——如同我们今天的EULA一样。
只是在景德镇，你连操作第一步的机会都没有。还是用脚投票，放弃一些实在不安全的公司吧。例如业界很知名的某个做恶意软件出身的公司，还有某个买了这个公司的前身的大搜索软件商。某个以动物作为Logo的公司，还有被国家大哥曝光多次的某家公司。凡是业界已经臭了名声的，最好都别用。
12.日子还过不过了？
淡定，我明天还会写一篇，你要注意的东西。虽然不说一定安全，不过普通用用问题不大的。</description>
    </item>
    
    <item>
      <title>密码为什么明文存放</title>
      <link>//blog.shell909090.org/blog/archives/2032/</link>
      <pubDate>Thu, 22 Dec 2011 11:02:49 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/2032/</guid>
      <description>很早就写过一篇blog，说到过，你的密码应当一次一密，至少某些密码泄露时不至于波及太广。结果这次CSDN不幸中枪。我不去讨论多少人急急忙忙修改密码，多少人数据泄露，单说说为什么很多时候密码是明文存放的。
就我有记忆以来，我写应用就从来没有明文存放过密码。最起先是md5方式存放。md5可以让你找到hash值，有的时候也会被用于穷举。但是无论如何，md5密码本身比明文安全很多。后来改成了challenge-response验证模式，也是用md5做的hash后进行c-r的。再后来，md5的碰撞冲突的论文出来，后面用的多数都是sha256了。从头到脚，我就没做过密码明文存放，并且，我认为这是正常程序员最起码的修养。（当然，明文存放的代码不是没有，不过那是调试模式）
但是现在我所知，很多系统的身份验证都是密码明文存放的，为什么？其实我不大理解。不过有时候问起，有些人和我说了几个我觉得不是搪塞的理由，现在抄录如下，告大家知。
1.不用明文密码没法应付检查。大家知道互联网审查，有时往往会一个电话过来，要XX用户的密码。如果你没法给出，上头就认为你不配合，事情各种难搞。作为审查机构的老板，当然没必要知道明文密码的危害。他们只知道，我要密码，为什么不行。所以，悲崔的程序员们就往往会得到一条死命令，保存明文密码。
2.压根不知道明文密码有什么问题。中国的互联网有太多的没基础的新人，从石头的缝隙中顽强的生长出来。这不是坏事，坏事的是这些人往往会在一些基础问题上出现奇怪的毛病。例如有些程序员，写程序很快，但是居然从来不知道密码明文存放会导致什么问题。更神奇的是，这些人中，有一家银行&amp;hellip;
3.自信暴棚的混帐。有些人的自信总比别人强，而且强在莫名其妙的地方。例如：我的服务器肯定是没问题的，所以我的密码一定要明文存放。如果不，就是质疑我的技术。
实话说，这种人真是少数中的少数。
4.遗留系统。很多系统设计的时候因为某个其他理由，使用了明文密码。等后来这个理由不存在了，密码系统升级成了一个困难。因为密码系统太重要了，所以在没有太大利益的情况下，总是倾向于不修改系统。但是有什么足够利益来推动系统修改呢？用户安全问题在发现前不是一个问题——好比这次的CSDN，不是被暴出来的话就根本不会被当作一个问题。系统的管理者，每个人都没有足够的动力去修改系统。
5.世界的阴暗角落。有的时候，程序员/老板明文存放的理由，是为了方便盗窃用户其他网站资料。例如我所知的某钓鱼案例，你注册网站，就提供很多免费服务，网站看起来也很靠谱——除了后来突然爆出这家网站其实暗地中用你的生日/密码猜解信用卡/银行卡密码，大家才突然发现，这家网站其实根本没有在美国注册，而是一个听都没听说过的国家。
而且很多网站提供从其他网站导入之类的功能，更加的危险。以前经常爆出twitter密码被窃取，主要就是因为OAuth开放以前，twitter上的第三方应用需要提供原生密码，导致很多小应用的目的其实就是收集密码&amp;hellip;
6.为了给用户提供方便。这个理由和上一个很类似，不过不是为了某些险恶的目的。而是客户经常要求——为什么我不能做XX事，为什么我不能blahblah。好吧，为了让你能，我们就必须保存明文密码。
明文密码的保存原因很多，不过结论都是一样的。在任何网站/服务上，你绝对不能使用同一个密码，零级密码除外。尤其请注意，不要在两家银行使用同样的银行卡密码/网银密码，原因不说。
从未来进化的角度说，密码的未来进化趋势是核心授权体系。就是你要向某个网站验证身份，只需要向身份验证商验证，剩下自动完成。现在的openid就是一种解决方案。密码都没了，还谈什么泄露呢？同时，实体交互和授权的精细划分也是一个趋势。某个网站访问别的网站的数据的时候，会形成一个访问令牌。这个令牌对需要访问的内容详细写明，并且需要用户授权。OAuth就是这个趋势的代表。另外一个趋势是利用某个足够安全的设备作为以上两者的终端载体。目前这个设备用的是手机，可是——手机不是一个足够安全的设备。也许这会是下一个XX门的隐患吧。
参考：《密码管理规范》</description>
    </item>
    
    <item>
      <title>密码管理规范</title>
      <link>//blog.shell909090.org/blog/archives/1915/</link>
      <pubDate>Thu, 22 Sep 2011 10:26:25 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1915/</guid>
      <description>下面是贝壳自己总结的密码管理规范，大家可以参考一下。
概念解说
 网络密码和本地密码。网络密码通常很难暴力攻击，尝试速度受到网络限制，而且尝试一定次数后还可能被管理员发现。而本地密码则相对比较容易攻击，我假定本地密码攻击可以达到每秒测试2\^30个密码。
 密码长度推定使用如下计算方式。使用年数乘以攻击频率，得出攻击者在密钥使用期限内能尝试的最大次数。为了安全起见，尝试范围不应当超过总体密码空间的一定比例。以此推算出密码空间大小，进而推算出信息位数，然后还原为密码位数。
 数字密码，字母密码，数字字母混合密码，大小写数字混合密码。数字密码的信息量是3.3bit/位，字母为4.7bit/位，混合为5.17bit/位，全混合5.96bit/位。
  密码原则
 一次一密。除了零级密码，不要为多个系统设定一样的密码。有些系统并不像我们想像的安全，一旦这个系统出问题，被还原原始密码，就会牵连到其他系统。
 定期更换。没有什么密码能用一辈子。
 写下来。因为一次一密，所以我们会有大量的散碎密码。不写下来是不保险的，写下来是不安全的。折衷一下，还是写下来，保存好吧。推荐用高级密码加密低级密码的方法，例如keepass。
 生成型密码。用一个特定字符串+网站名，做sha-1然后取最后8位。这样的密码满足一次一密，不容易破解，不需要写下来，唯一的问题是你要现算&amp;hellip;
  零级密码
 零级密码是有些不需要保护的情况下，又非设定密码不可。对于这种情况，你只能设定一个不算密码的密码。例如常用机器的用户密码。这些密码可以通过livecd/liveusb轻易修改，因此没有一点保密价值。
 零级密码不需要安全性和保密性，因此好记就行。例如111，222，选一个常用的，爱用多久用多久。
  低级密码
 低级密码是用于保护一些你不希望别人看到，然而别人看到并没有直接损失的内容。例如家里机器的性能数据，普通相册的访问密码。这些内容被别人看到不会产生伤害，然而无成本的放出这些内容有潜在的风险，或是你自己主观意愿希望保护，内容安全性要求又不特别高。
 我假定低级密码在网络上会受到100次/年的攻击，本地密码会受到1小时/年的攻击，可用时间五年，穷举空间不超过总密码空间的1/1000。
 网络密码的攻击信息量为log2(100 * 5 * 1000) =
  18.93bit。使用数字密码应在6位以上，字母，混合，全混合应在4位以上。
 本地密码的攻击信息量为log2(2\^30 * 3600 * 5 * 1000) =  54.10bit。使用数字密码在17位以上，字母在12位以上，混合在11位以上，全混合在9位以上。
 结论，低等级的密码长度小，使用数字也并不难记。推荐使用4位以上字母（反正混合使用长度也没有下降），不要使用常见组合还有单词。推荐方式是将自己喜欢的一句英文首字母简写前后颠倒使用。例如：I  will be back，对应密码bbwi。
中级密码
 中级密码用于保护一些你不希望别人看到，别人看到会对你产生损失的内容。例如你的帐薄，日记等等。中级密码使用时，最主要的风险已经不来自于密码本身，而是使用密码的环境。包括电脑是否安全，中途网络是否安全，旁边人的肩窥攻击。
 我假定中级密码在网络上可能会受到10000次/年的攻击，本地密码会受到100小时/年的攻击，可用时间1年，穷举空间不超过总密码空间的1/100000。
 网络密码的攻击信息量为log2(10000 * 1 *100000) =</description>
    </item>
    
    <item>
      <title>gnupg密钥签署原理和过程</title>
      <link>//blog.shell909090.org/blog/archives/1903/</link>
      <pubDate>Wed, 07 Sep 2011 10:52:29 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1903/</guid>
      <description>gnupg的密钥基础运用比较简单，有能力跑过来看我blog的应该都比较清楚了。不过最近接触了gnupg密钥的一些复杂运用，才发现——这玩意，居然能构造类似于PKI的复杂密码体系呢。
gnupg的密码体系和PKI类似，又有区别。PKI密码体系有数个根节点，负责验证服务。然而gnupg没有这种根节点，一切都是以社会关系网络运作的。更加复杂，也更加接近自然社会体系。
首先是gnupg的基本密码原理，公钥和私钥对。利用私钥签署，公钥验证。公钥加密，私钥解密。这是最基础的两种用法，我们略过不谈。密钥签署的问题提出来源于，我如何相信我得到的密钥，真的来自他所声称的这个人？
例如，我得到了来自Linus Benedict Torvalds的一封邮件，上面说blahblah。当然，听起来应当高兴，不过暂缓，这个信真的是linus本人写的么？这时候，我可以导入linus的公钥，验证签名——当然，如果有签名的话。不过问题又来了，你如何保证得到的是linus本人的公钥，而不是某个试图破坏系统的人伪造的呢？
好吧，为了解决这个问题，gnupg设计了互相签署机制。当我签署了某个人的公钥，并且将我的签署上传到公钥服务器（或者发送回给本人）的时候，我就为这个人的真实性做出了背书。例如，当我为thomas做了公钥签署，然后上传到了公钥服务器。然后thomas向某个他并不直接认识的我的朋友发送了一封邮件——例如发送给了julia。julia收到信的时候，会从服务器上下载thomas的公钥，然后看到我的背书。如果julia相信(trust)我，那么gnupg就会自动完成验证。当然，将公钥上传到服务器会略微降低安全性，所以如果限于安全考虑，我没有上传到公钥服务器，而是传回给本人。那么thomas就必须在给julia发送邮件的时候，附上公钥。julia一样能看到公钥上我的签名。
下面是如何操作。
首先你必须获得公钥，以下是从公钥服务器上下载的方法。
gpg --keyserver &amp;lt;keyserver&amp;gt; --recv-keys &amp;lt;Key\_ID&amp;gt;  而后，你需要看到这个公钥的fingerprint。
gpg --fingerprint &amp;lt;Key\_ID&amp;gt;  再然后，就是比较困难的部分。你需要和这个公钥的拥有者碰头，找个地方喝个咖啡，或者一起出来玩什么的。然后，查看他的有效证件，和本人对照，并且取得他本人认可的fingerprint。
这点非常重要，不要轻易的使用线上fingerprint交换来替代这个过程，也不要随意的为别人进行签署。你必须*确定*你签署了本人的密钥，线上获得的key，是完全可能被修改的，这是对所有信任你的人的负责。
再然后，就是简单的签署。
gpg --default-key &amp;lt;Key\_to\_use&amp;gt; --sign-key &amp;lt;Key\_ID&amp;gt;  最后，上传公钥，或者传回给本人。以下例子是上传到服务器的，不过记得先征求对方同意——除非你原本也是从服务器上取得的公钥。
gpg --keyserver &amp;lt;keyserver&amp;gt; --send-key &amp;lt;Key\_ID&amp;gt;  至于revoke什么的，暂且就不说了。
其中最麻烦的，就是上述过程中，两个人碰头的部分。为了简化这个部分，gnupg使用者经常有种gnupg
keysigning party[2]的聚会，互相交换和签署密钥。
reference:
[1].The GNU Privacy Handbookhttp://www.gnupg.org/gph/en/manual.html
[2].GnuPG Keysigning Party HOWTOhttp://alfie.ist.org/projects/gpg-party/gpg-party.zh-tw.html</description>
    </item>
    
    <item>
      <title>从快递说非对称密码学</title>
      <link>//blog.shell909090.org/blog/archives/1686/</link>
      <pubDate>Tue, 25 Jan 2011 11:07:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1686/</guid>
      <description>这两年快递评价很差，听说有基层员工冒充客户签名偷货物的。今天我们不说快递的问题，只是简单的讨论一下，如果快递公司管理层有心改变这种局面，他们有什么办法。
首先采用的方案是要求基层员工送货到门，必须本人签名，核对签名等。不过这对冒充客户签名没有任何帮助。因为基层员工一旦参与此事，什么送货到门的规矩，本人签名的规定，都是一句废话。核对签名是个废话中的废话，因为在仲裁的时候，基层员工得到的签名不对，并不能作为他故意将货物交给别人的证据。还不明白？如果客户不提前留下签名，最后的送货员可以辩解说，我又不知道收货人签名张啥样，给签就给收呗。如果客户提前留下签名，那么送货员可以仿冒一个。
同样，密码也有一样的困境。如果给送货员密码，等于没有防护。如果不给，等于没设定。
对于这种现象，可行的解决方案有二。
一种是让每个送货人携带一个终端，当客户取货的时候，必须输入预先设定的密码。如果密码持续试错，则该件锁定，交由收货人重新设定密码。这种做法的好处是原理简单明了，又能达成目标。送货人如果想要冒充收获，就必须反复尝试密码。多数情况下都是无法试出的，于是收件人收到一个警告，要求重设。这样的密码试出机率几乎是0。而收件人自己设定一个密码就可以收件，如果忘记可以重设。
但这种方法弊端也很明显，送货人要多携带一个终端，并且收件时必须保证终端通畅。不说终端部署的费用，在很多地方，指望通讯通畅是一件非常奢侈的事情。
第二种方法，就是让收货人提供一个问题，自行保留一个答案。这个问题和答案必须有几个特征。1.知道问题，是无法推出答案的。2.可以很简单的验证答案是否解答了问题。3.评判标准简单，不存在模棱两可的答案。4.问题和答案都便于生成和操作。
我们来看一下，为什么这样可以阻止送货人冒充客户收货。如果送货人要冒充收件人收货，就必须知道问题的答案。但是根据1，他是推不出答案的。而当收件人收货的时候，他给出的答案是很容易验证的。当然，其实这样就满足了要求。但是如果没有4条件，这个过程只能做一次，对于大量重复的快递工作是没有任何帮助的。
如果忽略去第四点，我们可以提供这么个问题和答案。一个1000位的质数和1000位的质数相乘，大概能得到一个1999-2001位的合数。这个合数能唯一的分解因数，求两个因数。问题很简单，但是根据目前的水平，要解出这个问题需要大量的计算资源。至少一个计算中心跑个几年是跑不出结果的。很明显一个送货的不可能随随便便解出这个问题的答案。但是如果收件人提供了两个质数，我们不说输入难度，要验证两个数相乘是否得到合数只需要一台手机一两秒的时间。至于一个数是不是质数，有一个概率算法叫做Robin-Miller算法能够解决（当然，实际用的都是略有变形的），验证起来也不过是几秒的时间。
这个方案无疑是很不错的，但是有一个致命的问题。要进行答案验证，就必须输入两个质数和合数。加起来大概有4000位的数据，输入起来会让人绝望的。在实际的快递中，这种方法没有任何应用价值。
但是对于类似快递的电子邮件系统，电子商务交易，在实际操作的时候数据交换和计算设备都绝对不是问题。因此，这类方法在电子商务上有非常重大的用途，说是电子商务的基石也毫不为过。
这类算法就叫做非对称密码算法，所谓非对称，指的是加密和解密过程使用的两个密钥不相等，又互相关联。其原理是当今世界最顶尖数学问题之一的“P和NP问题”，位列希尔伯特23问题和千禧年八大数学问题之中。能同时列入的都是对世界产生深远影响的重要数学问题，例如黎曼猜想。其实从理论物理角度，有一样东西更容易满足非对称验证的特性，就是两个处于纠缠态的基础粒子。如果我们忽略两个纠缠态量子怎么传递的问题，理论的想象，其中一个基础粒子跟随箱子，而另一个基础粒子在收件人手里。验证就是非常简单的问题了。干涉一个基础粒子到某个特定偏振态，使用一束光同时通过两个粒子。如果两个粒子处于纠缠态，那么光子在通过两个粒子的时候，粒子一定处于同一偏振状态。如果是非纠缠态的两个粒子，则光子输出的时候会比纠缠态量子有更大的吸收幅度。这个系统最完美的一点是，纠缠态的量子是绝对无法复制的东西，除非违背量子力学。不过从实际角度考虑，不说我们尚未成功在实验室里做到这一系列事情。单是让箱子携带一个基础粒子就是一个扯淡到不能再扯淡的事情。
当然，在快递中没有采用非对称算法的主要原因并不是因为实现困难，而是管理层根本无心改变这种局面。关于这个问题，我们在另一篇“快递战争”中讨论。</description>
    </item>
    
  </channel>
</rss>