<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Windows on Shell&#39;s Home</title>
    <link>//blog.shell909090.org/tags/windows/</link>
    <description>Recent content in Windows on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Wed, 08 Feb 2012 01:44:01 +0800</lastBuildDate>
    
	<atom:link href="//blog.shell909090.org/tags/windows/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>windows下那些好用的免费程序</title>
      <link>//blog.shell909090.org/blog/archives/2086/</link>
      <pubDate>Wed, 08 Feb 2012 01:44:01 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/2086/</guid>
      <description>大部分开源，不开源的特别注明。
firefox或者chrom替换掉IE。
不解释了。本公司UED坚持认为在windows下使用IE是一类人格缺陷，有这种缺陷的人应当被自然淘汰。我当然不支持他人格缺陷的论点，我认为是智力缺陷。
Everything(不开放源码)
文件搜索工具，肯定要装，平时不消耗资源，需要的时候闪电一般的把你需要的东西找出来。这个东西会彻底的改变你文件管理的习惯。
klite codec
还在用腾讯/暴风影音？我推荐klite codec。这个玩意里面内置了Media Player Classic - Home Cinema作为播放器，并且把常用的解码器组件都装上了。基本好用。当然，所谓基本，和商用播放器的一堆花哨功能不同。klite的功能还是略差的，比较偏向基本功能的稳定。不过好在，有的地方klite更强一点——例如没有烦人的广告和插件，性能和稳定性都很不错，而且有些生僻格式也做了支持。实际上，我觉得出问题最多的还是这些生僻格式和wmv。
mplayer
比klite还强的播放器，和vlc并称最强播放器之二。就是太难玩了。
另外，我不推荐在windows下用vlc，不太稳定。
MediaCoder
转编码不错，除了rmvb格式外都很好转。压个片给手机的时候很方便。
putty(英文版!)
远程命令行工具，基本是做linux开发的不二选择。即使我没事用windows也习惯装个虚拟机，跑个linux，然后用putty连上去。当然，putty肯定是要用英文版的，具体自己google吧，不要baidu。
foobar2000(不开放源码)
音乐播放器，替换千千静听和酷狗的。确实是超级强的定制工具，居然支持从zip/7z中加载音乐。这样我下的音乐包都可以直接用了，不用解压。
launchy
启动工具。有更好的启动程序可以给我介绍一下，我现在用的是launchy。按热键，敲几个字母，就可以启动程序了。而且这个是linux/windows支持的，两者习惯完全一致。当然，如果你stick在某个系统上，可以找找更适合的软件。
honeyview(不开放源码)
漫画工具，主要是还在维护。能用的漫画工具也没几个了，comicviewer不维护了，acdsee根本是个庞然大物。
peazip
压缩工具，挺不错的。现在大多数都用winrar了吧？一个是这玩意需要破解，不然就乱弹窗。作为一个程序员，我实在不好意思破解。另一方面，这个东西对samba的支持不好，在win7下，他没法打开samba共享出来的文件，而且某些文件会乱码。peazip可以解压我要用的全部格式，包括rar。并且可以生成我要的大部分格式，包括linux格式，不包括rar。这个主要受限于copyright问题。
不过peazip对某些比较奇怪的字符支持不如winrar，有时会不认识一些日文压缩包。这个问题对honeyview等程序都存在，我认为是这些压缩包自己的问题。
Foxit(不开放源码)
pdf阅读工具，国产软件，比adobe的强。不过细节总是做的不是很好。例如书签不够强大，注记功能不足，不支持zip文件读取等。不过要不用foxit，就要用回adobe，你自己看着办。</description>
    </item>
    
    <item>
      <title>千千静听被百度收购了，WTF</title>
      <link>//blog.shell909090.org/blog/archives/2082/</link>
      <pubDate>Mon, 06 Feb 2012 03:00:24 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/2082/</guid>
      <description>我挺喜欢千千静听的，这玩意被我调整到习惯和winamp差不多。自从winamp变成一个庞大的怪物以来，我一直用的这个。
不过在win7上，我一直删除不掉百度插件。每次我请他们出去，他们又会装上。后来我启用了严格的UAC，并蓄意把目标文件夹标记为没有人拥有权限，发现了问题——千千每次启动都查找并试图重装baidu插件。我开始以为是我下载的版本不对，被捆绑了其他组件。然后我去他们官网，下载了一个最新版本。安装的时候，我留意到发行者是baidu online&amp;hellip;。OK，问题看来不是我下载的版本被恶意捆绑，而是原始版本就写入了这个代码。
用过firefox或者比较正规的软件（包括微软那个IE）的人都可以留心到，在关于页面中，可以看到这个软件使用了哪些开源组件。这个大部分是因为这个库的版权限定要求使用者必须列出库的名称。不过这点在中文软件上就做的比较差，也许是根本不拿授权当回事吧。
但是，在软件内打入和软件功能无关的其他组件，那是另一回事情。个人认为，一个程序如果在安装包内捆绑插件，让用户选择安装，我还能接受。毕竟很多软件作者也要吃饭，做插件推广是一条路。如果捆绑强制安装，那就有流氓之嫌了。如果捆绑完了不算，还在每次启动的时候都检查插件是否还在，那就是确定无疑的流氓。
当然，千千的行为比这个更糟糕（我不选择说更流氓）。千千主页上没有任何地方说明千千归属了百度旗下，只有最下方有一条&amp;lt;千千静听联手百度娱乐推出“百度新歌汇”&amp;gt;的新闻,以及最下方有百度软件世界的连接。我也是从UAC的警告中发现，千千的软件包是用winrar打的（不知道是否是正版），而签名则是Baidu。至于选择，软件安装的时候的却有选择，不过即使选择了“不安装百度工具栏”，“不将hao123设为主页”也没用。还是会有一个叫做BaiduMusicCtrl的东西伴生安装进去，每次ttplayer启动时伴生启动的就是这个。说是和音乐有关的东西么，我在IE的插件和系统启动项中都找不到这个东西的影子，不知道是干吗的。千千删除的时候也不会跟随删除，不过可以找到独立的“百度音乐控件”项目，并且手工删除。更神奇的是，我在主页上找不到任何关于此事的说明还不算，连软件的发行授权都没有。没有发行授权，这软件我们用着算怎么回事呢？
我又安装了一遍千千，找到了软件使用协议“版权归属所有者所有”。这不是TM废话么。
OK，很多人在我说，中国人不大在意版权，这句话的时候，要我拿出证据。现在就是一个明证。从整个过程中，我感觉到的并不单是恶意捆绑这么个事情，而是对版权和授权的一个漠视：
1.没问你要不要，总之给你捆绑安装百度音乐控件，每次千千启动时自动启动更新。
2.被百度买了，页面上什么关联都没写。
3.关于授权，这个软件什么都没写。（另外，写授权的时候不要写“保留一切权利”，这是句屁话。你最起码得度让使用权，否则发行软件给别人就是故意诱使别人犯罪。千千的“保留知识产权”还是正确的。）因此，不要问我如果你把千千放到你的主页上会如何——这算再发行，合法不合法就看作者定义了——虽然我觉得他自己都不一定觉的出区别。
现在改用了foobar2000，很满意。这个东西可以接受samba共享系统，并且支持从zip/7z中读取文件。我很多下载的zip音乐包就可以直接使用了。虽然界面简陋很多，不过用起来更顺手。千千还是留给度娘控吧。</description>
    </item>
    
    <item>
      <title>NSIS在64位下安装时无法写入注册表的问题</title>
      <link>//blog.shell909090.org/blog/archives/1980/</link>
      <pubDate>Mon, 14 Nov 2011 15:54:50 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1980/</guid>
      <description>最近公司碰到一个问题，NSIS在64位下安装时无法写入注册表。
首先，这个问题不是UAC没有权限的问题，因为我使用administrator安装依然有问题。其次，问题和win2008没关系，只出现在64位上。
问题在哪里呢？在写入注册表前，SetRegView 64，写入后换回32，问题解决。
真TMD的。</description>
    </item>
    
    <item>
      <title>论不同系统和客户端的证书管理</title>
      <link>//blog.shell909090.org/blog/archives/1773/</link>
      <pubDate>Wed, 13 Apr 2011 15:54:41 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1773/</guid>
      <description>上面刚说完x509证书链系统，现在我们说说各种系统和客户端下的证书管理吧。理论上说，系统只要保留一份根证书系统，其余的会自动进行计算。但是杯具的是，不同系统的不同应用，使用的是不同的数据库。这导致你的根证书导入之路漫漫而修远。
windows系统：
1.系统证书管理
在运行中输入certmgr.msc，就可以看到证书管理系统了。根证书管理在“受信任的根证书颁发机构-&amp;gt;证书”下面。对证书文件进行查看，导入，然后导入到这个区域，就可以变成根证书了。要吊销一份证书，删除是不行的，因为会自动加回来。加入“不受信任的证书”好像也无效。我找到的比较实用的方法是右击看属性，“停用这个证书的所有目地”。再试试看？证书应当无效了。
2.firefox
火狐的证书系统是独立于系统证书的，因此在windows中做的修改对firefox无效。需要到“选项-&amp;gt;高级-&amp;gt;加密-&amp;gt;查看证书”中（windows下在工具菜单下），在“证书机构”选项卡，导入证书，而后启用所有用途，让证书生效。如果要吊销，跑到同一个地方，删除证书，或者编辑，取消所有用途。需要注意的是，当你删除证书后，再次查看证书列表时，证书会回来。但是此时编辑证书，可以看到，所有用途都被取消了。
3.chrome
chrome在windows下使用系统证书，因此不要用chrome自身的证书管理系统，直接修改系统证书就可以。
linux系统(debian)：
1.系统证书管理
运行dpkg-reconfigure ca-certificates，会出现让你配置系统证书的界面。这是系统的证书数据库，自动配置的话好像不能添加，只能取消。你反选某个选项后，/etc/ca-certificates.conf中，对应这个选项的行在行首就会出现!。此时系统内就不再认可这份证书。因此推测，如果你需要自己加入一份证书，需要将证书添加到合适位置，编辑/etc/ca-certificates.conf，加入路径，再执行dpkg-reconfigure ca-certificates或者update-ca-certificates进行更新，此时程序会更新/etc/ssl的某些内容，证书就安装上去了。
2.firefox
同样是独立于系统的配置，基本操作和windows差不多，不过linux下面“选项”在“编辑”下面。
3.chrome
linux下面的chrome可以在“首选项-&amp;gt;高级-&amp;gt;证书管理器”中，选择“授权中心”。导入后修改权限即加入。注意需要使用禁用，而非删除对应证书，来阻止某些证书。
这里面说的加入证书，基本是加入自己的证书。至于移除，基本说的是cnnic。cnnic证书有什么危害？目前没有。如果你相信中国的互联网是世界上最开放的互联网，那么下面一堆不看也罢。不过，如果你不相信中国政府颁发出的证书，还是移除的好。在系统内保留一个不受信任的根证书，可能受到证书替换钓鱼。简单来说，你访问一个安全网站的时候，这个网站的证书是如何颁发的，你留心过么？在地址栏网站logo那里右击，查看证书，再找到证书链，你就可以看到，这个证书属于谁，是谁颁发的，这样一个链条。想象一下，你在用gmail的时候，心血来潮看了看域名证书，发现颁发者是CNNIC SSL（google的颁发者是Thawte）。很明显，你访问的网站不是真的gmail，而是一个伪装的网站，将你的请求再转到gmail服务器上。这个网站没有gmail的证书，不过用CNNIC签了一个。于是你的所有请求，收到的邮件内容，发出去的内容，全部被公开了。你也不知道这个替换什么时候进行的，由于安全验证可以通过，系统也没有警告你。是不是有种看到日本恐怖片里面，贞子爬出屏幕的感觉？
当然，这个是一个特例，有点危言耸听。因为对于某些国外CA，证书也是乱发的。基本只要交钱，给一份材料复印件，一样可以通过审查，得到一本CA证书。然而，这种证书通常比较容易被发现，CA也会很快吊销这些证书。如果不是这样，这些CA往往也会被各种系统加入吊销名单。不过对于蓄意产生的CA证书么，就难说的很了。附上一个用于检测CNNIC证书的网站，https://www.enum.cn/。
另一个风险证书则是comodo，早些时候，这个公司被黑客入侵，导致黑客给自己签发了一堆证书。虽然目前这些证书已经被吊销，不过这种安全公司让人一点信任感都没有。最好果断删除。</description>
    </item>
    
    <item>
      <title>hack comix for windows use gbk as filename code</title>
      <link>//blog.shell909090.org/blog/archives/1727/</link>
      <pubDate>Mon, 14 Mar 2011 09:44:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1727/</guid>
      <description>Comix is a python application to view comic. it use pygtk as GUI library, so technically, it can be used under windows. But unfortunately, it has code problem under windows. OK, 2 fix it, open src/filechooser.py:214.
gbkpath = paths\[0\].decode(&#39;utf-8&#39;).encode(&#39;gbk&#39;) self.\_window.file\_handler.open\_file(gbkpath)  done.</description>
    </item>
    
    <item>
      <title>linux下使用windows共享打印机打印</title>
      <link>//blog.shell909090.org/blog/archives/1676/</link>
      <pubDate>Wed, 12 Jan 2011 16:42:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1676/</guid>
      <description>废话不说，上干货，六牙四皂小姐，猫咪退散。
http://www.openprinting.org/printer/HP/HP-LaserJet_1010
这是我的机器型号和驱动
aptitude install cups foomatic-filters smbclient hpijs hplip  访问http://localhost:631/
添加你的设备，并测试。</description>
    </item>
    
    <item>
      <title>linux虚拟化简介</title>
      <link>//blog.shell909090.org/blog/archives/1670/</link>
      <pubDate>Thu, 06 Jan 2011 10:14:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1670/</guid>
      <description>又是科普文，行家免入。
关于虚拟机的一些比较充分的讲解，可以看这里（http://zh.wikipedia.org/zh-cn/虚拟机比较）。下文是对linux下希望实现虚拟化和被虚拟化的情况提出一些简洁的说明。
1.windows下虚拟出linux。
不在意版权的人可以装个vmware 6.0以上，在意版权的装virtualbox开源版。字符界面通常分配128M内存，512M交换分区。图形界面512M内存，1024M交换分区。硬盘大小视各个发行会有所不同。对于多数工作用的系统，建议使用debian stable安装后升级到testing，稳定好用，最主要是简洁。128M内存512M交换8G的磁盘，足够系统安装和大部分的开发/运行。
2.linux下虚拟windows。
啥都别说，装virtualbox吧。破解vmware是很蛋疼的一件事情，装ESX就更蛋疼了。建议，XP512M内存以上，要稳定使用至少1G。倒是页面文件，只要512M就差不多了。硬盘至少准备16G以上，否则安装程序加运行数据，十有八九会空间不足。
3.linux下虚拟linux。
主要可用方案分为四类，系统虚拟化，半虚拟化，全虚拟化，硬件虚拟化，分别介绍。
4.linux下虚拟一些比较怪的东西。
这是职业玩家了，例如minix，或者freenas。改天写写后者，挺不错的一个创意。
1.全虚拟化
vmware是这种技术的代表。全虚拟化的特征是可以运行完全不同的系统，例如linux下运行windows。virtualbox是开源中做全虚拟化做的比较好的一款软件。当然，即使是全虚拟化，也必须是同一类CPU，例如32位虚拟64位CPU就不给力了。要虚拟不同的CPU，是CPU虚拟化，例如bochs和pearpc。速度大约是真机器的几十分之一，除了调试程序外没别的用途。
全虚拟化比较适合玩玩其他系统，其他可以选用的方案有，vmware，virtualbox，virtual pc，qemu。
2.半虚拟化
Xen是这种技术的代表。通过修改的真机内核和客户机内核来支持虚拟化。优点是效率比全虚拟化高，缺点是客户机必须是可以修改内核的，这将windows排除在外。但是从理论上，可以在linux的xen上运行freebsd系统，两者都是开放内核源码的系统。
半虚拟化技术一般被拿来做VPS比较多，基本没有其他可选用的方案。
3.系统虚拟化
OpenVZ是这种技术的代表。这种技术通过系统内核级别的代码修改来支持虚拟化。优点是效率比半虚拟化更高，缺点是客户机和服务器必须是同一个内核。因此真机和客户机都必须是linux（或者其他相同系统，例如freebsd），但是可以是不同发行（例如真机debian客户机centos），而且客户机不能自由加载内核模块。
系统虚拟化也被用来做VPS，但是这种VPS有强烈的超卖可能，因此不推荐使用。反倒是在同一个公司内，因为某些原因需要将多个程序部署在多台设备上，每台设备所需的资源又不多的时候，比较适合用。其他可选用的方案有jails，vserver，virtuozzo。
4.硬件虚拟化
kvm是这种技术的代表。当然，vmware workstation，virtualbox等也可以支持这种技术。这种技术是未来虚拟化的大趋势。
硬件虚拟化，是使用CPU和其他硬件的特殊设计，辅助虚拟化的进行。通过硬件虚拟化，虚拟机的执行效率往往可以达到和半虚拟化相似甚至超过的地步，而不需要客户系统的特殊配合。从设计理论上说，完整的硬件虚拟化应当可以在客户机上再执行全套的硬件虚拟化，如VM/370。但是目前Intel和AMD的家用CPU系列只支持在真机上创建一系列虚拟机实例，这些虚拟机的内部是不支持硬件虚拟化的。
硬件虚拟化可以用在VPS/机器切分/新系统尝试等各种环境中，其他备选的方案有，vmware workstation，virtualbox，virtual pc，qemu。</description>
    </item>
    
    <item>
      <title>QQ和360之争</title>
      <link>//blog.shell909090.org/blog/archives/1609/</link>
      <pubDate>Mon, 08 Nov 2010 21:55:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/1609/</guid>
      <description>两个流氓狗咬狗，老子一个都不用了。老子是Linux用户。。。</description>
    </item>
    
    <item>
      <title>论同时的双系统－－准虚拟对双系统的进一步扩充</title>
      <link>//blog.shell909090.org/blog/archives/49/</link>
      <pubDate>Mon, 12 Jan 2009 01:04:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/49/</guid>
      <description>熟悉贝壳的人都知道，贝壳是个linux爱用者，不过因为工作关系，经常要使用windows。贝壳在自己的笔记本上使用了linux/windows混合双系统，并通过共用磁盘的方式共享数据，解决这个问题。但是长期的使用表明，这种解决方案存在几个巨大的瑕疵。首先是系统切换时间常，因此长期在一个系统中工作，而很少触及另外一个系统。其次是稳定性差，windows下一旦崩溃，进入linux后就需要检测数据盘，80G的数据慢慢扫描，感觉晕到死。那么是否有一种方案，能够同时使用两个工作级系统（注意，不是实验级，贝壳成功的在windows下的vmware里跑了一个oracle，这个可以说是实验级的典范。然而工作级系统的要求和实验级完全不同）。
从系统发展史的角度来说，我们可以预见，将来的系统将是脱离硬件的。首要的原因就是和硬件不相匹配的各个层级的计算能力需求。现在系统发展有两个极端，一个是虚拟机，试图将一个硬件整体分离，运行多个系统。另一个是高性能集群，试图将多个硬件合并，运行一个系统。从根本上说，这是因为高性价比的硬件集中在了一个性能区间，而实际的性能需求却是完全分离的，因此我们才会出现如此两类完全背离的需求。而现在有大量宝贵的人力浪费在了系统和硬件结合，系统稳定性问题上，这无疑是对将来发展的一个巨大瓶颈。虽然无法预知将来的技术发展会以何种方式解决这个问题，然而可以预见的是，解决硬件和性能的背离将是人类计算机发展史上一个重要的里程碑，解决这个问题的人必定会在计算机历史上留下重重的一笔。
同时，更进一步，贝壳揣测，将来的解决方案将是系统硬件调度/驱动和系统软件管理分离。一个软系统拥有一个用户表和一个硬件表，硬件表上写他可能有10个键盘，两个显示器，或者一堆其他设备。系统借助某个可信方案，管理了一系列虚拟抽象设备和真实设备形成的映射。作为系统层以上的软件，我们只要关心如何操作这个虚拟设备即可。而实际上，我们可以通过管理参数和对应关系实现各种需要。例如我们可以将多个机器的硬件管理核心加入一个系统，形成集群。或者我们可以在一个机器的硬件管理核心上加入多个系统，形成虚拟机。这个基本是分布系统的观点。如此一来，系统层软件就无法得知也无需得知自己是在到底运行在什么环境下。只是这个系统设计方案对高性能要求的子系统（主要是显卡）相当不利。
从揣测回到现实，为了实现一个工作级系统（幸好，还不是工业级），我们需要为系统制定一些评判标准，以判别各个方案的优劣。我们首先能想到的评判标准就是速度，一个慢吞吞的系统解决方案是没有任何实用价值的。当然，这个速度是有差异的，可能是linux快一些，windows慢一些，或者相反。我们假定实际的需要是windows快一些，因为linux可以通过定制进行加速。
我们的第二个评判标准就是稳定性，经常会崩溃的系统不比慢吞吞的系统好到哪里去，甚至会更加让人讨厌。虽然工作级系统并没有工业级那样高的要求，然而高负荷稳定，宕机平均频率低于3天/次还是要保证的。而后我们还希望两个系统可以做到数据互通，即两个系统间的数据尽可能的共享，至少要做到文件和邮件的共享。最后，我们希望解决方案简单易用，便于实施和维护。
而后，我们列出了一个原始方案，和以下几个改进解决方案，并给出优劣评价，谨供大家参考借鉴。同时我们在其中还补充了一些无法实际解决问题的虚拟化解决方案，并且说明无法使用的原因，供适合的人自行选用。
原始方案，windows+linux+数据分区。此种方案是最中规中矩的，性能最高的方案。具有对硬件最好的支持，最容易的维护。如果需要运行游戏（尤其是魔兽，WOW），这也是唯一可行的工作级方案。稳定性评价属于尚可，主要由于ntfs在linux的稳定性并不好，ext3在windows需要使用非官方驱动，和某些（就是avast）驱动不兼容。数据互通比较方便，通过数据分区可以轻松的共享文件和邮件。
windows虚拟方案，vmware+虚拟分区。这种方案是改进方案中唯一可以跑游戏的，因为虚拟机随时可以关上。性能上满足windows快 linux慢的要求，虚拟系统显示性能良好，也可以通过文件共享部分的解决数据共享问题（文件共享方便，邮件共享困难）。稳定性很好，基本没有什么不稳定的问题出现，操作和维护都不困难。然而之所以一开始这种方案就被排除在外，主要是因为这种方案无法让linux驱动实体硬件，无法通过机器启动。这样也许对一些跑起来玩玩的人或者是内核工程师/测试员比较有用，然而如果要在linux里面进行大量工作，编译程序，运行服务，这种方案就力有未逮。因此这个方案可以说是一个实验级方案，而非工作级。
windows虚拟方案，vmware+实体硬盘。速度一般，windows快linux慢，基本和上面一个方案一样，唯一的区别就是linux也可以被实际驱动。然而这也成了整个方案的最大败笔，因为linux的驱动灵活性不如windows，因此无法经受这种系统切换的动作。举例来说，真实的机器上，硬盘是sata的，作为sda识别和使用。而虚拟机上则是IDE的，被识别成了hda。于是启动环境一变，就需要修改大量配置来调和这个问题。又例如，在真实机器上，X使用fglrx驱动，而虚拟机下面要用mesa。如果我在/etc/xorg.conf中不指定驱动，那么真实机器的驱动也会变成 mesa，导致性能下降。如果指定驱动，又会导致虚拟机内X无法运行。诸如此类的问题林林总总，需要大量细节修正，因此维护复杂，稳定性差，不建议正式使用。在贝壳机器上更严重的，出现了虚拟机内和虚拟机外争抢数据分区的状况，这种情况下数据分区实质是被当做盘阵用了。使用非专用的磁盘作为底层共享存储，并在上面运行ext3系统，这是及其危险和愚蠢的。
linux虚拟方案，xen。速度超快，但是上来就在贝壳的机器上暴出几个问题，因而没有继续测试。首先是安装xen后x无法启动，出现fglrx驱动无法加载的状况。其次是xen要求使用虚拟盘启动，可贝壳经常需要跑到windows下面打游戏。因此在简单测试后被剔除出局。感觉这种方案的最大问题在于配置管理太过复杂，debian下面已经很轻松了，只需要安装对应内核，使用工具建立虚拟机，但是依旧感觉麻烦到一塌糊涂。相信这种方案在专业级服务器领域应当有不俗表现。
linux虚拟方案，openvz。这种方案压根就不适合贝壳的状况，因为这个虚拟方案要求宿主和客户必须是同一CPU同一系统（不要求同一linux发行）。主要用于希望将一个主机切分成多个独立的同构主机，以达到分离管理的目的（例如业务服务器和数据库服务器分离）。需要做大型网络管理/虚拟主机业务的人可能会对这个虚拟方案感兴趣。
linux虚拟方案，vmware。速度一般，linux快windows慢，视频效果不错。vmware毕竟是商业公司，视频驱动挺齐全的。但是内核驱动的编译麻烦到死，首先是要求编译器版本和主内核编译器版本一致，于是贝壳去搞了个gcc-4.1，然后连接了上去。下面又是内核头定义出现版本差异，搞到现在还没有搞定。谁能搞的定的给个参考，最好是debian上的解决方案。
linux虚拟方案，kvm。这个是贝壳目前使用的方案，基本比较理想。速度很快，和xen基本差不多，显示速度不如vmware（理论上说装好显卡驱动应该会好点，不过贝壳找不到CLDC5446的XP驱动，那是Win32和Win95时代的显卡）。linux快windows慢，但是还在可忍受范围内。稳定性很好，只要测试通过，运行中到目前为止没有死机（当然很多参数是加了之后开机即死机）。数据可以通过samba互通，邮件也同样可以互通。然而使用samba无疑复杂很多，而且性能并不太好。只是从稳定性上说，让linux自己去驱动ext3总比半吊子的windows驱动更好，同时也不会出现争抢的问题。易用性上还算可以，无论是内核编译还是系统使用都不太难，最大的麻烦就是网络配置。根据贝壳的测试，在真实机器上superpi运行100W 位需要45秒，虚拟机内需要54-60秒，尤其在换用kvm-72.2后反而更慢了（54下降到60，折合真实机器83.3％下降到75％）。
总体来说，贝壳更倾向于使用全开源的准-全虚拟解决方案kvm，主要因为他简便易行，对系统影响小，不改变现有系统。同时性能高，稳定性好。主要需要解决显卡效率问题。如果以上问题无法彻底解决，贝壳打算换用linux下的vmware，想办法搞定他的内核模块。</description>
    </item>
    
    <item>
      <title>一些关于盗版、黑屏、开源的事情</title>
      <link>//blog.shell909090.org/blog/archives/44/</link>
      <pubDate>Mon, 03 Nov 2008 14:04:00 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/44/</guid>
      <description>大家都知道，微软搞黑屏了。贝壳暂时就这个事情不发表评论，而是先说一些其他的事情，然后大家再回过头来看这个事情怎么说。
首先是软件的版权区别。开源软件，自由软件，免费软件，共享软件，收费软件，盗版软件，这些我们经常说的名词究竟有什么意义，有什么相同和区别？
首先，大家要了解一个事情，上述对软件的不同称呼，其实是不可并列称呼的。免费收费，是指软件的付费方式，开源闭源，是指源码的公布方式，正版盗版，是指是否侵犯版权。这些其实是不同的事情，只是很多事情有前后的因果关系，因此大家容易混为一谈。一般我们可以将软件分为是否收费，是否开源，什么版权三种分类方式。分清其中的区别有益于阅读下面的内容。
开源软件是指源代码开放的软件系统。多数情况下，开源意味着免费和自由，但是也存在收费的例子。例如许多大型系统（好像有些UNIX就是，但现在具体什么情况，贝壳没有用过，也没有看过软件协议），其源码对使用者开放（注意，开源并不代表对所有人开放，只要使用者有权获得源码即可。当然，如果范围缩小到使用者中的特定群体有权，则不算开源，例如微软的不可泄露协议），但是属于绝对的收费系统。大家很容易理解这里面的原因，既然源码已经开放，那么多数人都可以轻易写出类似的系统，在这种情况下还要坚持收费就愚蠢了。除非源码庞大，需要相当的水准和时间来理解，这样才能保持收费。当然，更多的情况是开源免费，收取专家服务费。
这里中间还要插入一句法律问题（怎么感觉写成法律普及文了），目标软件的作用是给予使用，源码的作用是表达思想，这是公认一致的原则。换言之，如果你发布的是病毒目标，则是违法。如果你发布了病毒源码（当然，要排除恶意发布），则是研究之用，不属于违法。当年DeCSS的审判之所以被判定无罪，即是基于上述原则。
免费软件是指授权方式是不要钱的。现在免费软件的很大一个来源是来自开源社区，然而并非只有开源了才免费，共享软件和试用软件就是其中的两个典型。共享软件的作者允许你可以免费的使用它的软件，但是并不开源。试用软件的作者允许你在一定期限内免费使用软件或其中的一定功能（其实试用软件的完整授权也不一定要用钱，写个邮件把作者夸一顿或者给他做些事情，例如翻译软件，一样可以获得授权）。这些软件虽然免费，但是往往会因为有其他的原因而选择闭源。例如微软的Process Explorer，就是属于共享软件的典型。这个软件原属于sysinternels的作品，后被微软收购。如果是开源软件，搞不好要和微软打官司，也不可能被收购。而Winrar则是试用软件的典型，大家都听说过Winrar推动检查中国大型公司内使用非授权产品的例子吧。这个例子难就难在取证这个软件产品超过了使用期限，因为大多数人可以通过重装来避免提示。
自由软件是一个非常复杂的概念，要理解需要了解一些西方法律精神。自由软件现在在中国基本被视同为开源软件，其实两者是完全不一样的两个东西。自由指的是你拥有软件的选择权，包括是否使用，是否修改，是否散发，是否改善，具体可以参考这个文档（http://www.gnu.org/philosophy/free-sw.zh-cn.html ）。为了保证以上权力，开源是必须的，然而开源并不代表你拥有以上权力。我们在上文提到过，是否开源和什么版权是两个事情。开源软件可以选择收费版权，也可以选择非收费版权，但是禁止你修改，再散发软件。这些都不属于自由软件的范畴。
自由软件的起因来自于上世纪70年代出现在美国的自由潮。受到自由潮的影响，当时很多软件大牛都是黑客精神（不是现在这堆脚本小子讲的黑客）的拥护者。他们认为人类学习和使用软件的自由不言自明，他们拒绝为他们的帐户加上密钥，并且以破解软件系统为乐。他们所写的程序也是免费分发。很难想象，在上世纪70 年代的时候，很多现在具备极大影响力的项目在当时只是几个人看不爽而随手做的一些小程序。很多自由项目直到现在还无人可以超越，发挥着重要作用。
自由软件运动是天赋人权观念在知识领域的延伸，目的是推动知识的扩散。因为知识产品都有一个学习的概念，新手需要不断的观摩和学习成熟的系统才能成长。然而如果允许其他人无限制的学习，那么新知识的发明就无法给创造者带来利益，从而导致没有人愿意发明创新。因此专利法规定专利的存在，给予了发明人一定时期的权限，使其可以从中获利。而同时规定了专利期限，使得新手可以学习。（贝壳注：现在的很多专利期限动辄50年70年，实在是太长了一点，10年到20 年的期限应当是合适的）而自由软件在创造伊始就放弃了自身的专利权，给予了其他人学习和改进的权利，因此被认为是软件业的第一推动力。尤其是近些年，在 GNU的推动下，出现很多很优秀的软件产品。当然，其中大部分是和普通人无缘的。例如flex分析器，emacs编辑器。
盗版软件这个词很不好界定，因为有两种界定线。一种是收费软件不付费使用，一种是违反软件使用授权。从范围上说，后者比前者更广泛，因为付费主要是取得软件使用授权，不付费一定违反了授权原则。而违反授权则不一定是不付费，也可能是试用软件超期（违反试用授权中期限限定），未授权可以修改而进行修改（这个尤其多出现在使用源码库的时候），违反最终用户协定（在共享软件中常见）。一般我们说的时候都指前者，但实质上，后者也属于软件权违法的例子。我们不妨用违法软件来称呼后者，而用盗版软件来称呼前者。
盗版软件是否是自由软件思想影响下的产物？绝对不是。我们上文说了，自由软件运动的主要目的是普及软件知识，那么破解软件成果如何普及软件知识呢？无法自圆其说。也有人说这个是打击收费软件，以扩大开源软件的影响力。这就要讲到西方的毒树毒果理论，这个理论认为，非法手段（毒树），无论为了什么目地，其产生的结果一定是恶意的（毒果）。开源软件有着自己的适用范围，不需要也不可以通过这种方式强行介入收费领域。再者说，如果没有收费软件来为大型项目提供资金，没有大型公司来消化软件人才，那么程序员的将来也就无法保证，更谈不上进一步普及和推进计算机研究发展了。
盗版软件只是一些不喜欢付费或者根本不拿版权当回事情的人，为了自己的利益编造出来的一堆谎言。例如微软的这次黑屏，很多人都在抵制，都在骂微软。我们可以想象一下，如果微软的产品出来的时候就带着黑屏措施呢？他们照用不误，最多就是搞一下破解。Winrar也带了保护措施，用的人照样一堆堆，破解照样满天飞。微软只和合法购买者订立了合同，保证不会侵犯他们的权益。非法使用者从根本上就没有依据来保障，你的系统即使上了Windows就当场机器爆炸，也无法控告人家。
其实本质上说，贝壳也是违法软件使用者。在这个社会里面，看清每个软件的版权，然后一点不差的照做是完全不可能的，可能的只有知道行为违法后想法弥补。使用盗版windows则是因为贝壳根本是linux用户，但是同事全是清一色的windows，沟通不方便而被迫使用。既然我不是主动高兴买的，就上个盗版得了，被发现最多回到linux下结束（中国的法律对个人侵权行为只纠正行为）。使用盗版windows，我们人人知道违法，但中国的法律基于告诉乃论，就是所谓的民不告，官不纠。自己知道怎么回事，回去闷声发大财就算了，明明是违法者，还跳出来义正词严的指责受害者，做人不能太CNN。
就如同我在MSN名字中写的那样。我虽然不赞成你黑屏，但是我捍卫你黑屏的权力。</description>
    </item>
    
    <item>
      <title>一些使用firefox的技巧</title>
      <link>//blog.shell909090.org/blog/archives/435/</link>
      <pubDate>Mon, 10 Mar 2008 13:33:31 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/435/</guid>
      <description>在linux下和windows下共享同样配置/插件。这个很简单，上面的blog中有篇文章说到thnunderbird在双系统下共享同样邮件的问题，firefox也一样解决。能用linux的人不会查不出配置目录位置吧。
节约内存技巧。
firefox虽然号称小巧，然而很多时候我们发现他的内存消耗也非常惊人。在贝壳的机器上，有的时候会高达150M，基本等于普通编辑器/播放器的10倍。事实上，不是firefox浪费内存，而是默认的内存配置是针对&amp;rdquo;机器上只开firefox&amp;rdquo;设计的。如果你机器内存小，或者需要同时开其他程序，最好自己配置一下firefox。
首先就是fasterfox，关闭其中的&amp;rdquo;增强预读&amp;rdquo;，这东西很消耗内存。然后是内存缓存，调整到32M吧。一般一个网页上所有文件差不多1M-2M，32M够把20个网页的所有内容缓存起来，再多就不大正常了。根据贝壳自己的猜测，渲染动作应当是动态进行的，否则内存根本顶不住长文本的渲染。这样在浏览的时候，从后台抓取内容，动态渲染的速度就非常重要，因此强烈推荐不要小于8M。否则连5个页面的内容都不在内存中命中，还玩个P阿～
还有渲染中的&amp;rdquo;启用快速返回&amp;rdquo;，将内存中的保留页面数调整小，贝壳用的是3。当然，这个只适用于firefox1.5。
其次是session manager，将&amp;rdquo;撤销关闭&amp;rdquo;尽量减小。反正贝壳减小到了1个窗口3个页面。这些页面在关闭后还是继续消耗系统的内存，因此越小越好。当然，小到多少是要看你的具体需要了。
最后，少用插件，少启用插件，除非你真的需要。长期不需要的就禁用，或者干脆卸载。
内存回收技巧。
很简单，觉得不够了，关了再开。反正有session manager，正在浏览的网页根本不会有影响。
同时打开大批网页技巧。
最好使用Tree Style Tab，这样方便。另外，如果需要打开一个页面的所有连接，可以这样做。先察看页面信息，选择&amp;rdquo;链接&amp;rdquo;-&amp;gt;&amp;ldquo;全部选择&amp;rdquo;-&amp;gt;&amp;ldquo;复制&amp;rdquo;，然后开一个文本文件，把内容粘贴进去。可以看到内容其实是一堆的页面链接。当然，如果页面内有js做的链接指向，可以试试用Convert javascript or onclick to normal links这个greasemonkey脚本转换成目标链接。然后，把这个文本文件改名成htm，打开。通常情况下应该是一堆无法点击的文字，不过你可以用Linkify ting来把文字转换成一堆链接。然后……一个个点过去吧。
上面是使用greasemonkey解决的方法，当然，也有更简单的方法。你可以安装flashgot，然后新增一个下载管理器，名字叫做firefox。路径就指向firefox的执行文件路径，参数不用动。平时用你喜欢的管理器，需要打开全部链接的时候，更改为firefox，然后&amp;rdquo;使用flashgot下载全部链接&amp;rdquo;。当然，缺点是对付不了js脚本，除非你加载Convert javascript or onclick to normal。
不过鉴于内存状态考虑，建议不要同时打开大量页面。维持在10-20个上下最好。</description>
    </item>
    
    <item>
      <title>Process Explorer的潜在内存泄漏</title>
      <link>//blog.shell909090.org/blog/archives/426/</link>
      <pubDate>Thu, 31 Jan 2008 19:21:06 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/426/</guid>
      <description>贝壳最近碰到一个郁闷到死的问题。机器经常出现硬盘狂转，系统响应延迟。系统弹出一个错误，然后死机。贝壳开始猜测是硬盘驱动问题，升级驱动N次，无效。然后再猜测是ext2fs的问题(贝壳用这个驱动挂载linux下面的盘的)，看来看去，不是。最后，贝壳确定了，这是内存泄漏了～～～
问题是，这时候可没人跳出来推荐喝什么口服液的。贝壳系统中永远挂着一个procexp，看内存状态的。这东西是sysinternals的产品，后来被微软收购了。功能强大，很多系统调试，杀马都需要用到。于是贝壳就用这个工具看哪个程序的内存泄漏，可是看来看去看不到。准确说，是没等贝壳看到，系统就先死透了。最后贝壳多次尝试，发现了一个死机的规律。当mysql开启的时候，procexp就会随时发生异常死机。这是一个重要的提示，要么mysql内存泄漏了，要么procexp内存泄漏了。究竟是哪个呢？贝壳用了同属于sysinternals开发的pstools系列工具，仔细检查了异常发生时候的内存状态，确定，Process Explorer存在内存泄漏的风险！
看来sysinternals被微软收购后，旗下的工具也出现了微软的一贯特色。以下是一次内存泄漏后，终止mysql服务后抓下来的内存状态输出。如果不终止mysql，不等我抓系统就挂了。
Process memory detail for HOME-B2326348D0:
Name Pid VM WS Priv Priv Pk Faults NonP Page
Idle 0 0 28 0 0 0 0 0
System 4 800 52 0 0 10120 0 0
smss 772 3748 48 172 1648 223 0 5
csrss 828 68132 1464 2304 3768 13748 6 144
winlogon 856 61528 580 8536 8684 5143 39 96
services 900 37724 804 2256 2404 2740 7 65</description>
    </item>
    
    <item>
      <title>弄死MSN的共享文件夹</title>
      <link>//blog.shell909090.org/blog/archives/425/</link>
      <pubDate>Sat, 26 Jan 2008 22:43:47 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/425/</guid>
      <description>MSN8的共享文件夹功能根本就是一个废物功能，速度慢，不习惯，而且用处不大。最恶心的是，没有卸载选项不说，手工卸载后一开MSN一重起还会回来。NND，看我怎么弄死他。MSN虽然是微软自己的产品，但是也需要遵守微软的API行为。改变资源管理器的行为是用COM组件注入到exlporer中实现的，没有使用驱动层的东西。那么我们就设法阻断DLL文件的注入加载。
首先，regsvr32 /u是不行的。因为MSN一启动又会注册上，除非你不用MSN。删除文件也不行，因为会再生成一个。那么，我放着文件不动，把内容清空，然后再删除NTFS权限怎么样呢？即使是微软的产品，也不会强制说我的更改无效，然后自己胡来一套吧。
首先，关闭所有MSN有关软件，在运行中输入cmd开一个命令行窗口。然后，用process explorer(现在这东西也是微软的产品)终止explorer进程(系统自带那个应该也行，不过我没有测试过)。这步顺序非常重要，因为我们要先阻断COM组件的加载，否则无法对文件实行更改。所以我们要先打开一个CMD，然后再关闭explorer。否则一旦关闭explorer，开CMD就难了。而没有CMD，要去删除文件就要多费一些手续了。
我们现在在CMD中切换到MSN所在目录，删除fsshext.8.1.0178.00.dll啥的文件。这个文件名会根据你安装的版本而变化。而后启动explorer(在CMD里面敲explorer就好)，这个时候COM组件已经没有加载了。于是我们建立一个文本文件，改名叫fsshext.8.1.0178.00.dll，放到MSN的目录里面，再删除所有人的访问权限。删除的方法是文件上右击，点属性，安全，高级，取消&amp;rdquo;从父目录继承权限&amp;rdquo;的勾选，然后点删除。如果看不到安全选项卡，检查以下项目。工具，文件夹选项，察看，使用简单文件共享(推荐)，取消他的勾选。微软的东西，最好表随便勾。
根据我的测试，这时候你随便重起电脑，MSN的组件说加载不上就加载不上。同理也可以应用到3721之类的流氓组件上，只要抢先建立了同名的文件，并且阻断了权限，这些组件就会无法使用。如果你进一步做了分离权限(日常不使用管理员账户)，即使安装程序作者知道这种方法都无法应对。如果可以的话，就说明微软存在漏洞了。</description>
    </item>
    
    <item>
      <title>Linux和windows共享邮件</title>
      <link>//blog.shell909090.org/blog/archives/417/</link>
      <pubDate>Sun, 04 Nov 2007 22:59:14 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/417/</guid>
      <description>总算能发正常的文章了，前面发出来的老是不会断行。庆祝一下。
很多人像贝壳一样使用双系统，Linux加windows。贝壳的Linux用的是Debian，最近其中的xfce4出现一些问题。使用的时候老是死机，这日子没法过了。所以贝壳就稍微下了点功夫，先弄个好用的windows凑合一下。
windows下最难办的恐怕就是邮件了，到不是说不能收。只是windows下一个邮件状况，Linux下一个。未免讨厌了点。就算有导入导出可以转换，你想转换多少次呢？
下面贝壳就说一种方法来对付这种状况。
首先你的系统盘应当是ntfs，否则这方法不能用。然后在windows下安装ext2ifs来读取linux的home目录，假定是d:\username.mozilla-thunderbird。windows下安装类似版本的thunderbird，然后看看你的C:\Document and Setting\username\Application Data\Thunderbird下面，是否有一个profile.ini？有就对了。删除这个目录(我没说错)，然后去下一个叫做junction的软件，微软出的。这个软件可以将ntfs的某个目录映射到一个目标上去，对这个目录的访问就等同于对这个目标的访问，就好像linux下面的符号链接一样。下面知道我要做什么了么？
junction &amp;quot;C:\Document and Setting\username\Application Data\Thunderbird&amp;quot; d:\username\.mozilla-thunderbird  然后启动thunderbird，他首先会检查你系统中插件的版本可用性。然后你的Linux下邮件就可以用了。
简单吧？</description>
    </item>
    
    <item>
      <title>windows service的C&#43;&#43;封装实现</title>
      <link>//blog.shell909090.org/blog/archives/338/</link>
      <pubDate>Wed, 20 Dec 2006 20:09:10 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/338/</guid>
      <description>windows系统服务入口的封装类，service是基类，service_manager是管理类。支持UNICODE，可以多服务封装在一个程序里面，过程当然都是自动的。拥有自动防错系统，在服务异常退出的时候会去关闭服务，而不是开着服务直接没了进程。写一个类，继承service，然后在哪里出一个实例，就可以了。service中有很多虚函数，可以重载了监听对应事件(我应该写的比较明白吧)。get_service_name，返回UNICODE的字符串指针，定义服务名称。注意是纯虚函数，必须实现。get_dependence，也是返回UNICODE的字符指针。指明这个服务依赖什么服务。get_service_type返回服务类型，其实也就是是否可以交互。get_contral_accepts，支持的信号(例如是否可以暂停)，默认可以暂停。on_start开始时候调用的函数，下同。
使用方法
#include #include &amp;quot;service.h&amp;quot; class test_service : public service{ public: virtual LPTSTRget_service_name (); virtual DWORD on_start (DWORD argc, LPTSTR * argv); virtual DWORD on_stop (); virtual DWORD on_shutdown (); }; LPTSTR test_service::get_service_name () { return _T (&amp;quot;test_service&amp;quot;); } DWORD test_service::on_start (DWORD argc, LPTSTR * argv) { return service::on_start (argc, argv); } DWORD test_service::on_stop () { return service::on_stop (); } DWORD test_service::on_shutdown () { return service::on_shutdown (); } int _tmain (int argc, _TCHAR * argv[]) { test_service ts; if (argc == 1) service_manager::start (); else if (!</description>
    </item>
    
    <item>
      <title>Windows和Linux之争</title>
      <link>//blog.shell909090.org/blog/archives/326/</link>
      <pubDate>Fri, 06 Oct 2006 22:56:15 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/326/</guid>
      <description>在网络上大家经常能看到争论Linux和Windows哪个更实用的帖子。两者无非抱持两种论点，Linux胜在价格和灵活性，Windows胜在简便和可用。一般来说都是说，不论怎么说，Linux可以如何如何而Windows不行。或者是，Windows可以什么什么而Linux不行。
总体来说，Windows擅长于桌面应用而Linux擅长于服务系统。Windows最大的资本在于品牌和延伸。Windows的品牌和可乐的不同在于，可乐的品牌仅仅是牌子，是虚拟价值。一旦可乐公司全部烧毁，那么能否靠可乐的牌子重新站起还是一个问题。但是Windows的牌子还附带了用户对于UI操作方式的粘滞。一旦M$烧了，别人也是很难抢这个蛋糕的。Linux长处在于免费，就单机成本来说，Linux远远要低于Windows。但是这是不完全的运营模式。一个不赚钱的项目？如何吸引别人？
我不考虑Windows和Linux哪个更好，而是考虑另外两个问题。他们是否有存在的必要，以及他们谁更适合我。
大家想必知道，POSIX标准下还有Linux，BSD，Solaris的分别。如果今天不是WL之争，是否会出现UL之争呢？我不知道，历史无法假设。不过我相信，多个公司多种模式的混合竞争，会造成好的效应。很多Windows项目，都潜在的为Linux项目提供了资金(至少M$养活了很多程序员)。而很多Linux项目，又为Windows项目提供了技术和支持。最重要的是，没有Linux的追赶，windows就会无限制的膨胀，垄断，守旧，出现问题。而没有挑战Windows的需要，Linux也不会不断进步。
很多人往往把Windows和Linux等同到开源软件和商业软件。其实这是不严格的。软件往往分为商业软件，试用软件，共享软件和免费软件。商业软件是指代码封闭，作为公司的一个资产。可以转让，可以有条件开放。软件收取使用费用，并且出品公司对于功能提供保证。这样的一类软件。试用软件是商业软件的特殊版本，指限制或者取消了部分或全部功能，准许用户合法免费有限使用的一种特例。代码可以封闭也可以开放(但即使开放也往往是部分代码，甚至是理论代码)，通常是全部软件的一个部分，或者是修改版。往往可以通过缴费来变成商业软件。共享软件指软件作者保留软件的所有权，但是免费的发行软件，不收取费用或者仅仅收取手续费。源码可以封闭也可以开放。免费软件指作者按照源码形式发布软件，并且放弃源码所有权力。一般有有条件发布和无条件发布。GPL就是一种发布条件，虽然作者不继续拥有代码所有权力，但是这些代码不得进入商业领域。而无条件的免费软件，所有者放弃所有权力，任何人可以合法的运用其中的代码。
由此来看的话，大致是商业软件和试用软件一个阵营，共享软件和免费软件一个阵营。然后，Windows上有大量的共享软件，例如Winamp，这已经是Windows得以生存的一个基础了。Linux上面也有很多的商业软件，例如MAYA。往往是属于免费阵营的共享软件稳固了Windows的存在基础，给Windows系统提供了大量的功能和定制。而属于商业阵营的MAYA等为开发4Linux的软件，而为Linux提供了大量的资金。
至于哪个更适合我(注意，这里的我，可不是贝壳本人)，则要看系统的功能，成本，特性而定了。首先是成本问题，M$曾经提出所谓总体拥有成本。即，Windows通过一次购买就可以低成本的运行，而Linux一般都是要为机器配备高水准的管理员。所以管理员水平的上涨引发的费用应当被计入成本中。而且Windows系统对于操作者是基本不用培训的，而Linux需要培训操作者，因此也会产生成本。
问题在于，Windows一次购买1000台机器的时候，大约40W是的纯软件成本。如果原来是需要配置3个网管，现在要配置5个高水准的。那么原来大约需要12W一年，现在需要25W一年。如果3年内需要购买升级产品，则会导致Windows的成本反而高。问题在于，Windows也是会购买升级的，所以软件的成本也会平摊在每年上。当运行的机器多了，就会导致网管的工资上升不算啥的状况。而且注意，其中还不包括因为要在Windows上工作而需要购买的其他软件，例如Office。如此计算下来，单纯从配置的平均拥有成本讲，Windows不占有优势。
不过在雇员培训上，Windows就非常有优势了。现在会Office的雇员满天飞，不会才奇怪。因此可以说是无成本的。然后不会的人找起来反而困难，加上培训，每人成本就要高出100-200。而且非Windows环境和Windows环境交互上比较麻烦，所以这个成本还要更高。从这点来说，一般企业都不适合用Linux。什么企业适合呢？1000台以上机器，雇员学历偏高，在和他人交互上需要他人配合的企业。其实去了企业就可以明白说是政府了。
特性上说，Linux奉行的是专业分工合作的模式。由一个软件完成一个非常专的部分，例如排序，或者下载。然后通过交互通道来协调各个软件，达到一个复杂软件的构成。例如一个邮件软件，可以在里面加入HTML，加入加密，加入VIM编辑。定制性非常强，对于和某些常见任务接近但是细节上有区别，又强调细节必须实现的特殊任务。往往可以非常简单快速的完成。例如同样一个从Internel上面抓专利信息形成数据库的工作，Windows下要专门写程序，而Linux下面可以通过连接lynx|sed&amp;gt;来完成。
然而这对于使用者水平要求非常高，如果不熟悉系统，根本无法做到。对于学校，专家来说，使用Linux是非常方便的。而对于正常用户来说，Linux可就是鸡肋了。
windows的特性是大而全，思考是基于用户傻瓜的模式。固然没人愿意说自己是傻瓜，可是做傻瓜考量的软件总不做天才考量的软件好用。简单来说，windows不追求低成本，不追求好用，只追求用户最简单可以用。可见，随着电脑普及，windows这种思路是无法持续的，或者至少是要萎缩的。
最后一个是功能，Linux的功能和windows总体评价来看差不多。不过Linux的软件更多是专业用的，例如免费的符号表达求解。而windows更多是娱乐的，例如游戏。因此要实现有限功能的人可以自由选择，例如办公环境。需要专业的人最好用Linux，需要娱乐的人最好用windows。
综上来说，对于政府，学校，专家，需要专业软件的人，建议选择Linux。而对于中小企业，需要娱乐的个人，最好选择Windows。</description>
    </item>
    
    <item>
      <title>Runas系统管理方法</title>
      <link>//blog.shell909090.org/blog/archives/283/</link>
      <pubDate>Wed, 25 Jan 2006 06:09:25 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/283/</guid>
      <description>一个系统，做一个管理员（不是administrator），做一个受限用户。然后用受限用户，不用管理员。做一个链接。
C:WINDOWS\system32\runas.exe /user:user C:WINDOWSsystem32cmd.exe  然后启动后输入管理秘密，就可以用管理员身份来做管理了，启动注册表编辑或者啥都很方便。</description>
    </item>
    
    <item>
      <title>IE屏蔽方法</title>
      <link>//blog.shell909090.org/blog/archives/282/</link>
      <pubDate>Sat, 21 Jan 2006 17:47:02 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/282/</guid>
      <description>IE这个东西讨人喜欢讨人嫌，很多时候没有它不行，有了又容易中各种东西。下面的研究就是怎么样来控制IE的各种行为。首先是屏蔽IE的开启
cacls &amp;quot;C:\Program Files\Internet Explorer&amp;quot; /P admini:N /E  这条语句的目的是屏蔽administrator对浏览器目录的访问权限，访问权限都没了，浏览器自然开不了了。不过这只适合于用户手工开启浏览器，如果系统自动弹出，浏览器还是照样开的。例如我们亲爱的MSN，所以还要加下面这条。
cacls &amp;quot;C:\WINNT\system32\BROWSEUI.DLL&amp;quot; /P admini:N /E  这条屏蔽的是IE的界面（UI），所以凡用IE界面的东西全部弹不出来。像刚刚我就差点无法写新的日志。所以用这两条语句重新开启访问权限。
cacls &amp;quot;C:\WINNT\system32\BROWSEUI.DLL&amp;quot; /P admini:F /E cacls &amp;quot;C:\Program Files\Internet Explorer&amp;quot; /P admini:F /E  这里要特别说明下，admini在我的机器上指administrator，而我机器上的administrator则是一个连guest权限都没有的空账户，专门用来诱骗攻击的。各种账户的情况大家可以根据自己机器自行修改。
上面屏蔽了IE的UI，但是内核还是可以访问的，所以在FireFox里面用IE插件可以载入IE的解释系统，外壳则是FireFox的。如果要真正保证安全就使用这个语句。
cacls &amp;quot;C:\WINNT\system32\MSHTML.DLL&amp;quot; /P admini:N /E  这个语句屏蔽的是IE内核入口，所以下面所有的IE行为全部都会变成下载。有啥网页也全都是下载而不是解释出来显示在网页上。至于解除代码，自己想吧。</description>
    </item>
    
    <item>
      <title>C&#43;&#43;语言跨系统编程</title>
      <link>//blog.shell909090.org/blog/archives/263/</link>
      <pubDate>Wed, 23 Nov 2005 03:38:06 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/263/</guid>
      <description>首先我们给这个话题增加一个基础，就是您的C++代码没有用到native的部分。具体哪些部分我会列出让你慢慢检查的，不过用到了还想跨平台，你做梦去吧……
我们假定你代码是在windows的VC++下面写的，因为VC++的转换过去有点麻烦，反向的转换基本可以自动生成。
首先请检查你的头文件依赖性，如果是引用了标准的头文件，那么不需要额外的设定。一般g++的设置中都会自动设定标准的头文件和库。如果引用了某个自己写的文件，那么请检查相对路径是否正确。尤其请着重检查大小写。因为windows不会管大小写的，但是却会将大小写带入*nix。
另外VC++中有一个头文件预编译的加速选项，默认是开启的。将stdafx.cpp(which is empty)预编译次，就得到了stdafx.h的编译结果。在*nix里面我目前还不知道怎么支持，所以stdafx.cpp可以不用理会。
然后请检查标准函数，部分VC++声明在STDLIB.H中的函数其实是VC自带的。用这种函数的结果就是编译100%的失败。遇到这种函数可以自己写一个代替，反正一般都不是特别麻烦。
另外一般不需要关心数据类型和端点型，多数库文件中都会自动处理。不过两种情况需要手工干预。一个是程序中使用了windows特有类型例如DWORD或者linux特有类型le32。这样用typedef重新定义就好了。还有就是跨平台的时候连同芯片类别一起跨过去。这样就要手工确定所有库文件会自动处理数据类型，并且人工定义一组会使用的数据类型扩展宏来处理跨平台的问题。最明显的例子就是int在不同平台的大小问题，对此还有一个特殊的建议就是使用char short long来代替，这三者在所有系统上的长度是相同的。
下面是使用sh脚本来编译代码。其实可以使用make文件来做的，不过俺不会。所以用sh来做好了，反正一般跨平台的程序都不会过于复杂，凑合下就过去了。
g++的编译对象一般是cpp文件，如果是一般的可执行文件，那么编译的指令是g++ *.cpp -o oufile。我这次编译的对象是共享库，所以指令是g++ -shared*.cpp -o outfile。
g++处理extren的比较特殊。如果extren在编译成目标文件时还没有指定链接到哪个符号，那么g++就自动将这个定义为从动态库中引入。不过多数情况下，这应该会出错的。所以要多个cpp文件一起编译，或者使用-c编译到.o文件后再ld起来。否则单个cpp的编译结果根本无法使用。
如果需要使用少量native的方法，也可以按下面说的方法跨平台。
在VC++中定义一个win.cpp，其中将native的方法封装成函数。在主程序中使用C++标准函数和这些函数。
在linux中定义一个linux.cpp，然后用linux的native函数实现对应的函数。在编译的时候略过win.cpp。
VC++中工程引入的时候不要加入linux.cpp。
这样可以保证在两个系统下分别对应不同的函数，当然更好的方法是使用平台相关宏。
附录1，windows下的专有编程技巧：
使用了nativeAPI的绝对无法移植，它们有的甚至无法跨越2000/XP的差异。
使用windowsAPI的，一般不可以移植。这类API多数声明在windows.h中。
使用winsock的没有希望啦，要用socket2才可以。winsock的特征是WSAStartup。
使用了__try{的无法移植，而try{可以。前者是SEH的捕获模块，后者是C++异常捕获模块，在windows下异常捕获是用SEH实现的，不过linux下面不是。linux根本没有SEH。
使用了windows或者VC专用宏的无法移植。
使用C++库和std库的可以移植，包括cout。
使用STL可以移植，不过注意平台差异性。
附录2，linux项目在VC++中引入的方法。
新建一个工程，然后copy所有源代码到工程下面。再然后添加文件到工程，然后F7编译。over</description>
    </item>
    
    <item>
      <title>论windows的版本</title>
      <link>//blog.shell909090.org/blog/archives/211/</link>
      <pubDate>Wed, 28 Sep 2005 05:00:35 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/211/</guid>
      <description>一下资料基本是按照我脑子里面的记忆整理的，对于大家选用OS可以当做参考。不过不对不要说我不负责，把资料email我份我改就是了。
1.windows1.0版，1986年出品，有人用的话给我备份一个，收藏用。
2.windows3.2简称win32，此版本不是32位，不要搞错。现在基本用于磁盘启动的系统修复盘，不知道的请去无忧启动论坛。
3.windowsNT4.0以下，用于以前的服务器，和novell并称。目前不多用。
4.windows95，就是chicago。微软得意之作，奠定OS界destop应用霸主地位的产品。分两个版本，目前已经全部停止支持。
4.1.windows95，95年出品，sn固定，根本不用破解（事实上我连干吗要sn都不知道……）。
4.2.windows95OEM2，OEM版，97年出品，俗称win97。因为不是所有硬件都可以跑所以没有正式release。
5.windows98，称霸五年的重量系统。具备所有操作系统特性（唯独除了“她是个独立系统”），流行时间非常长。当前还在很多旧机器中运行，虽然已经停止支持。她的API被纳入win32本地子模块（CSRSS支持）的标准API群。详细论述请看Jeffery
Richter的Advanced windows programming。基本分三个版本。
5.1.windows98 frist
release。最初发布版，版本号忘记了……SN很有特征的。
5.2.windows98 2222A版。最流行的版本。
5.3.windows98 第三版，其实就是2222A集成了最后的所有补丁。
6.windowsME，不是Mobile Edition，而是Millionium
Edition，千年版本。可能为了千年虫发布的吧。不过太过花哨，兰屏满天，贝壳用了不久就换回win98了。目前已经无疾而终。
7.windows2000，windows的标准版。其后的所有版本其实都是修改版，例如XP版本号5.1，2003版本号5.3。（表问我5.2哪里去了，那个应该在上面，是2222A）具备当今所有成功OS的特征，独立OS（总算去了dos了……），微内核消息系统。多层驱动模型，抽象硬件层，高级网络支持，多子系统，兼容POSIX（不过从来没听说有人用过噢），com和RPC……等等等等。具体分四个版本。主要有SP2和SP4两个补丁版本。
7.1.windows2000professional，号称专家版，其实个人用的啦，偏偏小孩的，目前SP4还支持中（快停止了吧……）。
7.2.windows2000server，服务器版本，支持二个CPU，SMP。4G内存，高级并行能力等等……主要用于小型服务器搭建和AD的Directory。
7.3.windows2000advanced
server，高级服务器版，贝壳的版本。基本和上面一样，不过管理功能好点。
7.4windows2000DataCenterServer版，目前无中文盗版。贝壳有幸拿到过英文复制版，好激动阿……这个东西的竞争对手一般是AIX或者Solaris之类的。支持64CPU的SMP，有Culter能力，多少G的内存忘记了，还有OOXX的N多强大功能。可惜无论多强劲，一旦给服务器装上，三天两头在server上面看到兰屏一定很好玩……
8.windowsXP，目前用的人最多的版本。MM比2000好很多，不过界面还是太花哨了。要界面花哨，学习java的awt和wsing就好咯，要你M\$插嘴干吗？这个比以前多了一个激活的东西，关系到使用和升级，麻烦的要死。基本分SP1和SP2两个补丁版本，Home和Profrssional两个发行版本。发行版本差异基本没有，就是微软小气，限制了功能而已。其实说来上面的2000中前三个版本也是一样，除了windows2000DataCenterServer使用专用内核外，别的只有注册表差异而已……
8.1.原版激活版，用标准SN安装的XP可以用三十天，在此时限内用算号器计算出号码，再用批量验证器验证。得到的SN如果是005-008子段，没有被M\$封锁，就可以再安装成为原版激活版。以后使用连M\$都认不出来，只要不是太多人使用导致被封锁……号称最完美版本。
不过windows的SN是椭圆曲线算法的（类似RC系列），当代计算机九分钟算一个出来，平均一百个中一个能用的……也号称最麻烦版本……
8.2.windowsXP俄罗斯破解版。要说俄国人的hacker水平就是强，kaspersky的破解就是俄国出品嘛，windowsXP最早也是，StarForce也是。哎……中国阿……
离题了，说到哪里了？对咯，俄罗斯的破解其实是修改文件，用于SP上面就要出问题。俄罗斯破解的SP1或者SP2都是强制修改版本号的结果。你自己看看文件就知道了。
8.3.windowsXP联想版，需要修改BIOS打上联想的标志。NND我自己养猪干吗给你按戳，不用……
8.4.windowsXPVLKSP2版，也称为大上海政府版，注意在DVD上安装时容易出问题。由于是用于批量安装的，没有SN，也没有激活，当然，更新也是有限的……
9.windows2003，M\$用于服务器的版本。同样是要激活的，不过没有用过所以知道的不详细。大致来说有Reset5.0，按照服务注册的激活方法。俄罗斯破解（又来），原版注册。具体情况只有微软晓得了。
10.windowsPE，Pre-Installnation
Edition。是用于光盘启动等等的超微型版本，一般使用XP内核。ERD拯救系统和snoopy等等就是基于这个系统。这个内核用于在光盘等地方启动一个超微缩的NT系统，然后可以从容的挂载NTFS，执行安装等等。
11.windowsCE，这个是用于嵌入式的版本，有至少四个版本（我知道四个）。一般用于PDA，叫做PPC（Pocket
Personal Computer）。贝壳有幸用过……不好用……
11.1.windowsCE最早的版本，没啥玩头啦。
11.2.windows Mobile 2003，我现在用的版本。
11.3.windows Mobile 2004，先进噢，没用过，系统限制没法升级。
11.4.windows Mobile 2005，听说而已，我没有亲见。
总算结束了，目前微软还没有新的产品挤压我的脑浆……</description>
    </item>
    
    <item>
      <title>windows系统四、五</title>
      <link>//blog.shell909090.org/blog/archives/195/</link>
      <pubDate>Fri, 15 Jul 2005 10:27:02 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/195/</guid>
      <description>四，内核对象和句柄
调用API的过程中，有必要区分调用的目的和对象。说的通俗点，就是为什么调用和对谁调用。例如打开哪个文件，或者终止什么进程。调用的目的是根据不同的API和状态或者属性参数而变化的，而调用的对象则是根据句柄而选择的。
句柄大致分为内核句柄和对象句柄两种。一般来说，申请打开句柄时需要你传入安全令牌的就是内核句柄，内核句柄具有可继承性（inherit）。而像窗口等等东西就是对象句柄。SDK编程中，程序根据句柄的不同而操作不同对象，实现程序的种种目的。可以说，句柄和API组成了程序对下层的接口。
而在系统实现中，句柄则是某个内核对象，这个对象在系统中有个编号。句柄实际返回的多数是这个编号。大家可以申请两个句柄出来玩玩看，一般都是09XX之类的数字。从大小上看还属于NULL地址段（具体请看jefferey的windows核心编程），所以多数就是内核对象表项编号。这种一般以非内核句柄居多，因为这种句柄的特性可以从一个进程直接传递到另外一个进程。而有的则是某个在进程地址空间（这里插句，windows中进程和线程的区别可以理解成为，进程拥有独立空间和句柄，线程拥有独立CPU调度）内的某个数据块。这个块指向了某个确定的内核对象，这种句柄数字上一般大于4M。一般以内核句柄居多，进程间不可以传递只能继承。（其实也可以传递的，不过要用API主动复制，而不是Copy句柄过去了事）
五，通讯方法
通讯方法，通俗的讲，任何程序必定涉及和其他程序的通讯。windows中的通讯肯定是要通过API实现的。具体方法最简单的是消息通讯。需要对方的线程ID（进程ID没用的），或者进程创立的windows句柄。如果使用sendmseeage发送消息，接收方又是本线程创立的窗口，则将窗口处理函数作为子例调用（因为sendmessage是阻塞调用，本线程阻塞了来调用本线程的派生，当然，也只能，直接调用）。否则将消息挂到对方的接收区域去，然后要么阻塞，要么直接返回。（注意到为何sendmessage给本线程要直接调用了吧。阻塞的线程是无法通过messageloop的。）
如果不高兴使用消息，那么可以使用文件映射。这个方法本来是自虚拟内存中引入的，后来渐渐用来做文件的系统缓冲处理，也用来处理系统通讯。将一个文件同时映射到两个进程空间，则任何空间的变化会引发另外一个空间的变化。注意所谓文件的变化和虚拟内存一样，是未必写入磁盘的。使用这个方法需要注意同步问题。
另外，这个方法有个变形。可执行文件是PE格式时，文件载入内存时会自动做文件内存映射。此时设定属性，让某个section自动的作为同步映射，这样所有的自这个文件派生的进程在此section上是内存共享的。具体还是可以看jefferey的windows核心编程。
再差就是使用管道了，管道是用来套接标准输入输出的。去找找CUI界面重定向的问题就知道管道的用途了。除了定向到网络上，管道还可以定向到text框中。例如VC编译的时候……
再傻点？你两个程序各申请一个winsock通讯好咯，OLE，COM，都随便你用的阿。不过拿电脑间互相通讯的东西做进程通讯，你一定是头壳坏去了。</description>
    </item>
    
    <item>
      <title>windows系统二、三</title>
      <link>//blog.shell909090.org/blog/archives/194/</link>
      <pubDate>Thu, 14 Jul 2005 19:42:10 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/194/</guid>
      <description>二，从程序到内核 程序是被CreateProcess载入的，中间过程就略去不说了。不过程序为何可以在不同系统上运行呢？
首先每个程序会调用一系列的库函数，具体视使用语言和编译工具，编程框架而定。程序或者框架会调用系统的API，这个部分是SDK编程的内容。具体调用哪个API，在什么DLL里面，传入啥参数，在所有windows系统中都是一样的。不过每个windows系统对于具体实现就完全不同了。调用的API会在程序文件中载明。然后系统会将每个DLL载入进程空间，于是就实现了具体和系统的链接。每个DLL最终都会调用int 2eh（或者SYSENTER）陷入系统来完成各种使用。这部分就是内核的事情了。由刚刚的程序载入（每个系统都相同的动作），到内核实现（每个内核都不同的事情）。中间具体的过程就是系统附带的DLL的所完成的。
三，MM，不是美媚
MM是MemoryMangermant的简称，而非美媚。windows的内存管理在程序来看是透明的，因为对于程序来说，地址空间是连续的。主要原因是系统通过段寄存器索引了某个表，通过此表来映射你的“连续”内存地址到真实内存地址上来。当然，也有可能映射到了硬盘上的某个区域。Windows的每个内存块都对应某个硬盘上的区域。不过如果在内存中，则区域保留等待写入。如果不在内存中，需要的时候读出来而已。在你“透明”访问内存的时候，段寄存器会访问这张表（实际一般不访问，表的项目会在首次访问的时候载入某个缓冲用的快速寄存器），而后映射到真实的内存地址。如果“真实”的内存地址不存在，则会发生异常。windows的异常捕获会直接将硬盘内数据调入，然后继续程序执行。所以在访问内存过程中，程序看来是“透明”的。</description>
    </item>
    
    <item>
      <title>windows系统一</title>
      <link>//blog.shell909090.org/blog/archives/191/</link>
      <pubDate>Wed, 13 Jul 2005 23:59:26 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/191/</guid>
      <description>一，启动
任何一个系统，一般都从启动讲起的。这里讲启动本来从NTLDR讲就好，可是怕有人不懂，所以简略概述加电后系统的启动流程。
系统加电后，会将CS:IP（注意不是EIP）设定为FFFF:0000。然后开始BIOS自检流程（Power-On Self Test,POST），最后初始化0地址的中断向量表，将引导盘CHS(0,0,1)读入系统0000:7C00开始执行。我们假定这是硬盘（软盘的没有MBR这步），并且没有安装LILO到MBR（否则流程不大一样）。于是MBR会先读取分区表（Disk Partition Table,DPT），寻找活动分区并且载入其第一扇区到000:7C00位置执行。这样MBR等于一个透明层，无论哪个分区（逻辑磁盘不行哦）获得了活动分区，其引导区（OS Boot Record,OBR）都可以当做自己是被BIOS读取执行的。而后如果是9X系统，引导区会读取系统文件（FAT32）头部来执行。这个就是我们非常熟悉的DOS启动流程。同时插句话，如果您无法format一个DOS系统盘出来。那么先彻底格式化（注意彻底，否则FAT遗留信息会让你失败）磁盘，然后COPY IO.SYS上去。照样可以产生系统盘，当然这种BT非常规手法只有了解系统才干的出来……
如果是NT系统嘛，就会按照某种方法载入NTLDR这个文件。具体方法我也不清楚。因为NTLDR文件没有位置要求支持NTFS和FAT两种格式。按理这么一来引导代码会超过引导区的容量。根据分析NT系统的引导区内容总共有六个连续扇区，分布在头六扇区中。当然第一个扇区还包含了文件系统相关信息BPB（BIOS Parameter Block，研究MFT的还有一个Extend）。这样的大小还是无法容纳整个文件系统的支持阿？要解决除非我愿意反向引导代码，不过为了这么一个问题反向引导代码……等我有空再说吧。
下面NTLDR会进入保护模式，设置了GDT,LDT等等东西，并且彻底支持了NTFS和FAT的读取（引导区只要能从两个格式盘上马找到一个文件就好）。然后会根据BOOT.ini中内容决定如何进行引导，如果出现文字，还可能需要bootfont.bin字体文件。一般来说，会直接调用NTDETECT.COM来检测硬件变化，继续系统加载过程。这个就是我们经常看到的黑色屏幕上有东西从左到右闪的那个……
后面的东西就是微软内部的资料，众人根据推理分析得来，所以不是很准确。不过可以肯定，后面的东西全在system32中打转。根据分析，首先加载的是NTOSKRNL.EXE（单处理器）或者NTKRNLPA.EXE（SMP，对称多处理器）。这个东西就是windows的微内核，由它导出了windows全部NativeAPI的实现。然后是SMSS.EXE，这是进程管理器，也可以说是头个系统派生的进程。后续所有进程可以视为它的子例。由它派生了CSRSS.EXE和WINLOGON.EXE。后者接管了系统的很多部分，例如GINA。它派生了SERVICES.EXE进程，系统开始加载各种服务。最后在登陆后由GINA启动EXPLORER.EXE。出现桌面等操作界面，启动基本完成。按照上述分析，多数服务的宿主进程都是SERVICES.EXE的派生进程（有特例，例如贝壳手里的RaidenFTPD守护进程就是先由SERVICES.EXE派生，再两次派生所成的）。而多数应用程序的进程都是EXPLORER.EXE的派生进程（当然，或者再派生进程）。EXPLORER.EXE负责的内容包括了开始菜单等等，所以除非你通过某个服务去启动程序，否则都是它的子孙。（特例包括Process Explorer工具作为Ctrl+Atl+Del启动时，是WINLOGON.EXE的子例。所以在上面启动一个CMD就成了服务派生，无服务身份。还有MSN弹出的邮件或者Space都是作为某个服务的派生的，所以也不是EXPLORER.EXE的子例。）</description>
    </item>
    
    <item>
      <title>Windows系统引论</title>
      <link>//blog.shell909090.org/blog/archives/190/</link>
      <pubDate>Wed, 13 Jul 2005 23:15:09 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/190/</guid>
      <description>最近在开linux系统，找找发现资料那个叫……哎。到不是说少，linux号称开放源码，想要什么没有阿。问题是精论系统结构和意义的很少，一般都是讨论某个技术点如何如何的。没有大略的瞻观（当然，也有可能是英文，贝壳的E文水平看了等于没看到）。而一般系统中要做某个应用，除了经验，就是根据系统的运作方法、构架、原理等等去模拟。例如了解了file
HANDLE这种东西后，自然会就如何将一个HiddenConsole的Output转Dump到一个windows的text中产生想法。或者了解了[\.]()系列文件后，自然会想到如何制作的ISO。当然，其实还有ATAPI的方法。如果了解了winsock的层实现流程，自然会知道防火墙如何实现。所以了解一个系统，无须了解内核的每句代码（对于windows，根本无法了解。即使是linux，了解了全部也要数年。届时你了解的也该淘汰了。）。系统主要了解其构架和思想，关键部分才了解实现。
现在看linux系统，犹如隔纱而望。当然，系统的命令我了解了不少（其实了解了ls和man已经差不多了）。但是每个命令是哪里的？系统的目录如何设置？什么配置应该看什么地方。linux载入进程是如何实现的。（估计这个是ELF的范畴，不过肯定要先啃过内核在看的懂。否则就如同我当年不知道NativeAPI的时候看NE和PE一样）
所以现在写一个windows系统引论，希望抛砖引玉。毕竟windows的资料全，了解时间长。所以难保还有哪位大大也写过类似文章，大家姑且看之吧。</description>
    </item>
    
    <item>
      <title>实践NTFS格式解析</title>
      <link>//blog.shell909090.org/blog/archives/185/</link>
      <pubDate>Sun, 03 Jul 2005 23:04:20 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/185/</guid>
      <description>刚刚在想NTFS格式的问题，感叹没有个实例拿来看看。然后在看小说的时候不知道怎么回事，想到点子上了。不由骂自己白痴，这个问题其实早就解决了阿。直接用CreateFile去读[\.c]():文件不就好了……
OK，明天写个程序看看NTFS的实质……也许还有别的用途，再说了。
另外写个想法，也许NTFS中很多MFT表项没有被某个目录引用成为文件，而其引用计数大于一（这样会被chkdsk查出来吗？等于0会吗？会删除吗？表问咯，偶都不知道……）。这样就会造成系统空间的神秘减少。例如上次系统文件复制时候空出来的硬盘，上面全空，但是使用了400M多的空间。估计就是这么搞出来的。具体要察看chkdsk的机理才知道，因为偶的硬盘经常chkdsk的。如果是属于能查的出来的错误，肯定就不会延迟到换硬盘才发现。可能是chkdsk不检查这个……
另外回头准备看看内核的机制，试试记录或者反木马能不能提前挂在内核态上……嘿嘿，里席必争，咏春的要诀……
这次仔细看了MFT的格式。有点心得，先写下来。
首先是从MBR定位到每个BOOT区的BPB，这样才可以获得BPB中的\$MFT和\$MFTMirr的LCN。并且会获得卷因子（多数都是0x08吧，4k的簇）。\$MFT的LCN多数是4，定位就是32(0x20)。而后就会定位到MFT表上去。
MFT的表项分析起来是遵循链式结构的，不过为什么有那么好的性能和抗崩溃能力呢？可能在于USN和LSN吧。每个表项有个头部（详细看linux的ntfs/layout.h去），指明了大小，关联了相关MFT表项和上下MFT表项，以及这个MFT表项的全局属性。由其中可以引出首个属性的相对偏移。
每个属性都有个公用的属性头部，这个头部说明了属性的类型和大小，还有属性是否直接存储，如何存储等等信息。由上个属性可以推知下个属性偏移，所以属性应该是链式存储的。不知道这里是否具有超长链溢出的问题（长度超过最大值的一半）。
另外，在文件名称属性中具有引用目录项目，所以上面猜测的可能无法成立。不过引用目录和硬连接是违背的阿……下次再分析好了，困了困了……
OK,继续分析。根据刚刚的阅读，一个文件可以分散在多个MFT中，而后就会引入一个叫attribute
list的属性。这个属性指明了每个属性属于那个MFT引用中。其中VCN的换算关系比较特别，基本MFT算-1，下面依次排开，扩展MFT也算进去的。似乎一个MFT就算一簇。不过VCN和LCN的映射关系让我头痛了半个钟头，最后也没有在linux的头文件中找到。到是在NTFS.com中文件恢复上找到了说明。原文如下：
00012580 2E 00 70 00 70 00 74 00 80 00 00 00 48 00 00 00 ..p.p.t.Ђ...H... 00012590 01 00 00 00 00 00 04 00 00 00 00 00 00 00 00 00 ................ 000125A0 6D 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 m.......@....... 000125B0 00 DC 00 00 00 00 00 00 00 DC 00 00 00 00 00 00 .</description>
    </item>
    
    <item>
      <title>COM运作机理初探</title>
      <link>//blog.shell909090.org/blog/archives/184/</link>
      <pubDate>Sun, 03 Jul 2005 00:50:06 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/184/</guid>
      <description> 今天偶看本COM的书，七搞八搞还是没有太搞明白COM的机理。先把看的差不多的写出来好了，省得下次忘记了。也不一定对，整理整理思路继续学……   COM在运行的时候有一个GetClassObject的导出函数，由这个函数负责生成对象实例并且返回合适的接口。所谓接口，就是派生于一些特定的基类的纯虚类。GetClassObject先构造某个类的实例（根据UUID），然后再获得这个类中的某个IUnknown派生接口，再向这个接口查询其他接口实例（又是根据UUID），这个查询函数名字就是QueryInterface。   根据MSDN的资料显示，QueryInterface具备三个理由。一个是每个接口都要 **** Identity，二是在对象实例中的接口集必须静态，三是每个接口都要能够查询到别的在同个对象实例中的接口。三还跟了很多例子，必须成功等等的。   同样从IUnknown中继承的还有Release和AddRef。每次引用一个接口都会有计数变化，这形成了接口的创立和析构。感觉上这个很类似于iNode和MFT中的引用计数，以及dll载入中的使用计数。   简单来说COM的机理上大致就是。通过GetClassObject寻找并且产生合适的对象实例。通过GetClassObject给出的接口QueryInterface返回其他接口。由于每个对象实例中QueryInterface都是自行编写的，所以可以轻易返回其他所有对象接口。于是通过一对UUID可以定位到某个特定的Interface，用C++术语说就是纯虚基类。  </description>
    </item>
    
    <item>
      <title>抱怨</title>
      <link>//blog.shell909090.org/blog/archives/178/</link>
      <pubDate>Mon, 13 Jun 2005 21:41:55 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/178/</guid>
      <description>吃了人家的免费午餐，照例应该专程为人做做广告，致致贺词。不济也不应该抱怨连连。不过MSN的空间的却引我腹诽。过去的文章找不到……不知道是我方法不对还是什么。如果真的如此我干脆另觅它处，好过我珍贵的文章白白无人看……
OK，先放下MSN空间的问题吧。本周我分析了UPX的压缩原理分析结果亦不外如是。不过话说回来UPX毕竟不是专业的防跟踪壳，仅仅是资源压缩程序而已。好分析也没有什么值得意外的。
源程序如下，是最最出名的Hello,World.：
#include &amp;quot;stdafx.h&amp;quot; #include &amp;lt;windows.h&amp;gt; #pragma comment(linker, &amp;quot;/ENTRY:main&amp;quot;) //#pragma comment(linker, &amp;quot;/ALIGN:0x1000&amp;quot;)//这厮一上程序就变成3k党了，然后UPX就死气活样的不肯工作 #define put(x) WriteFile(hOutput, (x), sizeof(x), &amp;amp;amp;NumOfBytes, NULL) #define get(x) ReadFile(hInput, (x), sizeof(x), &amp;amp;amp;NumOfBytes, NULL) HANDLE hOutput, hInput; DWORD NumOfBytes; void main(){ char tmp[1]; hOutput=GetStdHandle(STD_OUTPUT_HANDLE); hInput=GetStdHandle(STD_INPUT_HANDLE); put(&amp;quot;Hello,World.n&amp;quot;); get(tmp); return ; }  UPX压缩下来的程序，section会变成三个。UPX0,UPX1,UPX2。其中UPX0是虚段，具备实际的段名称和段地址，但是RawDateSize是0。所以这个段在载入后是全0数据。数据和解压代码合并在了UPX1段中，由UPX1的解压代码注入UPX0的段中。看样子解压代码是附在了最后，从入口点到段实际内容结束点之间的范围。而UPX3的段最是搞笑，是一个单独的ImportTable，仅仅导入了Kernel32.dll中ExitProcess,LoadLibrary和GetProcessAddr三个函数。UPX1在解压并且注入UPX0后，会调用这三个函数来分析和获得每个导入表项的地址，然后完成导入表的动作。
换言，程序在从UPX1段JMP入UPX0段的瞬间，从UPX0段DUMP出来的数据就是正常的数据，除了要重建Section，并且重建所有DateDirectory外。
OK，下面说说压缩算法的问题。上面可以看出，压缩动作不难，但是算法我可没有能力分析和实现。所以我脑筋就动到了zip算法上去。可是根据我以前看zip文档得到的经验，zip内部分多种格式。貌似rar也分多种格式。所以我不打算挑战极限，自行写出每种算法的代码。不过我打算做一个标准的扩展接口，可以让所有的压缩算法都容纳在这一个框架内。并且可以支持多种压缩文件的格式。对上可以封装成标准的文件读写函数，然后再写一个COM组件，让所有的人都可以任意的运用（嘿嘿，写网页的人估计最需要）。至于后面要不要写一个什么东西让整个windows可以把压缩文件无缝的当成文件夹处理，那就再说了。</description>
    </item>
    
    <item>
      <title>利用API插接替换破解软件</title>
      <link>//blog.shell909090.org/blog/archives/171/</link>
      <pubDate>Thu, 02 Jun 2005 12:07:53 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/171/</guid>
      <description>刚刚在看软件破解教程，看到一个人说怎么怎么破解软件。然后突然想到，许多软件破解其实不用修改出flag或者找注册算法。只要对话框不出来，软件照常好用就可以了。OK，基于这个原理，试试用DLL注入插接API的方法RIP破解软件。
首先是对话框弹出机理。先写了个MFC程序，然后跑一跑，在运行中按着DoModel()一路F11下去，跟进了CWnd::CreateDialogIndirectPreamA云云的一个函数里面（名字忘记了）。然后就是一个API调用了。（__IMP__Creat&amp;hellip;肯定是调用别的DLL的函数了）API内容看不到……我晕。编译一个Release版的出来，然后上Ollydbg。经过跟踪，确定了窗体句柄是在USER32.CreateDialogIndirectPreamAorW里面生成的。如果没有窗体句柄呢？
貌似有两种可能，一种是没事，对话框没了。一种是报错。按照试验，Readbook至少是没事情的。哈哈，这样简单多了。整理下顺序，基本就可以做RIP破解了。
首先是用OllyDbg等等软件定位USER32.CreateDialogIndirectPreamAorW（其实USER32.CreateDialogIndirectPreamA更好，如果只用这个的话比较好确定参数类型）。然后下断点，跑到软件里面触发窗口广告……然后记录对话框的模板位置，调试的任务就结束了。因为没有啥要判断的东西，这个应该说简单到顶点了。
然后写一个DLL注入程序，运行目标程序并且Suspend。然后注入DLL，挂接API。详细参看windows核心编程，现在我们假定挂接了USER32.CreateDialogIndirectPreamA。现在有了一个自主的处理函数，只要在里面判断模板是否为特定模板就好……这个是module的一个res，理论上不是动态生成的，所以位置不变。而且一个对话框一个模板，很好认不会出错。如果是特定模板就返回NULL，否则正常调用。这样程序的提示框就永远弹不出来了。
这个其实是将软件的对话框禁止技术搬到了API层去实现，由于API层代码相对稳定，通用性强，所以破解相对简单。不过也是有代价的。如果软件无法生成对话框会导致出错……这个就没戏了。而且要写注入程序（可以写个注入的模板，或者一次写好可以多次用……），毕竟不是直接运行程序，使用不大方便。而且速度会受影响，如果程序里面对话框满天飞的话……</description>
    </item>
    
    <item>
      <title>从游戏修改到程序优化</title>
      <link>//blog.shell909090.org/blog/archives/165/</link>
      <pubDate>Sat, 28 May 2005 00:33:43 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/165/</guid>
      <description>前几天在家没事情干，就写了一个通用游戏修改器。代码很简单，利用argv参数获取传入文件位置，然后反复调用EditFile。重复映射文件，并且定位目标位置，修改指定数量的数据，然后保存。然后，我为了某些特殊目的，决定赋予程序动态运行和可扩展的功能。并且加入搜索支持。其实后者并不困难，我们只要反复调用函数对比和赋值，并且逐步推进指针就好。但是前者的实现具有一定困难，为此我不得不增加了部分程序开销，来保存一个函数指针，并且可以动态的调用。这样我们就可以实现诸如轩辕剑中的物品修改。其过程大致如下所述。 轩辕剑中的物品是一个数组，但是数组头的RVA是不固定的，仅仅知道大致位置。我们必须先定位某个物品的代码（特征代码），然后修改后面紧跟的一个WORD，实现修改物品数量。程序会自动的建立一个指针，并且逐步推进。我们的实现函数仅仅需要判断当前指针指向的WORD对象是否等于一个特定值，等于的时候进行修改就好。主体框架如下： #define NOSEARCH 0x00000000 #define SEARCHALL 0xFFFFFFFF #define RADDR(x) (LPVOID)((DWORD)RVABase+(x)) typedef DWORD (*tpEditData)(LPVOID Data); struct _RVATable{ DWORD RVA; DWORD SearchEnd; int size; tpEditData pfnEditData; LPVOID OldData; LPVOID DataBuff; }; _RVATable RvaTab[]={ {0xBA4C, NOSEARCH, 01, NULL, NULL, &amp;ldquo;x09&amp;rdquo;}, {0xBA4E, NOSEARCH, 01, NULL, NULL, &amp;ldquo;x5B&amp;rdquo;}, {0x76AB, NOSEARCH, 01, NULL, NULL, &amp;ldquo;x09&amp;rdquo;}, {0x0000, NOSEARCH, 0, NULL, NULL, NULL} }; void EditFile(LPTSTR lpPath); int CompareMemory(LPVOID mem1, LPVOID mem2, int size); void main(int argc, TCHAR* argv[]){ for(int i=1;i&amp;lt;argc;i++) EditFile(argv[i]); return ; } void EditFile(LPTSTR lpPath){ int i; HANDLE hMap, hFile; LPVOID RVABase=NULL, DataByRva, DataEndRva, DataNow; DWORD FileSize; __try{ hFile=CreateFile(lpPath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, NULL); if( hFile==INVALID_HANDLE_VALUE ) return ; FileSize=GetFileSize(hFile, NULL); hMap=CreateFileMapping(hFile, NULL, PAGE_READWRITE | SEC_COMMIT, 0, 0, NULL); if( !</description>
    </item>
    
    <item>
      <title>光盘镜像Copy、底层文件读写和CreateFile</title>
      <link>//blog.shell909090.org/blog/archives/164/</link>
      <pubDate>Sat, 28 May 2005 00:22:58 +0800</pubDate>
      
      <guid>//blog.shell909090.org/blog/archives/164/</guid>
      <description>1.CreateFile读写文件，设备，网络。
刚刚看到有人在问，知道了数据的物理位置，如何读取光盘上的数据。于是我很纳闷，这有何难。看他的意思不会是要编程进行硬件交互读取吧。如果已知数据的偏移地址，那么使用CreateFile(&amp;rdquo;\.X:&amp;ldquo;&amp;hellip;)就可以直接读取某个盘上的数据了。（Windows 2000 Support Tools中DiskProbe就是用这种方法直接读写物理磁盘的，包括可以读写0面0道0扇区，不过他用的对象是\.PHYSICALDRIVEx而已）
还有可以打开的对象包括管道（会用的人一定知道），文件（废话），Consoles（简单来说就是命令行界面），通信资源（例如COM1）。据说还可以打开内存，似乎是PHYSICMEM资源，记不得了。
以上资源的打开都有限制的，多数都比较简单，就是在打开时候使用OPEN_EXISTING标志。另外还有些当然的限制，例如光盘不能做为GENERIC_WRITE打开（我是没有试过啦，不过想也知道，光盘哪里能写。）
举例来说，这次我做的ISO镜像制作程序（ISO可以是光盘的按字节镜像），代码大致就是这样的。（以下代码都是伪代码，不要拿去编译哦。）
GetLogicalDriveStrings(nBufferLength, lpBuffer); lpRootPathName=lpBuffer; while( lpRootPathName\[0\] ){ if(GetDriveType(lpRootPathName) &amp;amp; DRIVE\_CDROM ) break; lpRootPathName+=strlen(lpRootPathName)+1; }; if( !lpRootPathName\[0\] ) return -1; strcpy(RootPathName, &amp;quot;\\.&amp;quot;); strcat(RootPathName, lpRootPathName); RootPathName\[strlen(RootPathName)-1\]=0; hFileCDROM=CreateFile(RootPathName, GENERIC\_READ,//我要做镜像，不是刻盘（不知道能不能刻） FILE\_SHARE\_READ, NULL, //你这个用户有访问能力就是NULL，没有自己去看API编程去 OPEN\_EXISTING, //必须如此,这个是打开光盘的限制条件 FILE\_ATTRIBUTE\_NORMAL | FILE\_FLAG\_OVERLAPPED, //交叠模式 0); hFileISO=CreateFile(ISOpath, GENERIC\_WRITE, 0, NULL, OPEN\_ALWAYS, FILE\_ATTRIBUTE\_NORMAL, 0); Overlap.hEvent=CreateEvent(NULL, FALSE, FALSE, NULL); do{ Overlap.Offset=...; Overlap.OffsetHigh=...; ReadFile(hFileCDROM, lpBuffer, BUFF\_SIZE, &amp;amp;NumberOfBytes, &amp;amp;Overlap); WaitForSingleObject(olRead.hEvent, TimeOut); if(!GetOverlappedResult(hFileCDROM, &amp;amp;Overlap, &amp;amp;NumberOfBytes, FALSE) ){ switch( GetLastError() ){ case ERROR\_IO\_INCOMPLETE: CancelIo(hFileCDROM); break; default: break; } //error } WriteFile(hFileISO, lpBuffer, BUFF\_SIZE, &amp;amp;NumberOfBytes, NULL); }while( 1 ); CloseHandle(Overlap.</description>
    </item>
    
  </channel>
</rss>