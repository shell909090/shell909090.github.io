<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Filter on Shell&#39;s Home</title>
    <link>//blog.shell909090.org/tags/filter/</link>
    <description>Recent content in Filter on Shell&#39;s Home</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Wed, 24 Sep 2008 17:11:00 +0800</lastBuildDate>
    <atom:link href="//blog.shell909090.org/tags/filter/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>VeryCD版电驴(eMule)存在封锁</title>
      <link>//blog.shell909090.org/blog/archives/38/</link>
      <pubDate>Wed, 24 Sep 2008 17:11:00 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/38/</guid>
      <description>&lt;p&gt;eMule是一个GPL程序，所以VeryCD的改版必须公开源码。今天听说VeryCD版有封锁的现象，所以贝壳抓源码来看看。如果大家认为老调重弹的话，不妨把文章拉到最后。&lt;/p&gt;&#xA;&lt;p&gt;源码从此处下载：http://www.emule.org.cn/download/&lt;/p&gt;&#xA;&lt;p&gt;最下方链接：http://download.verycd.com/eMule-VeryCD-src.rar&lt;/p&gt;&#xA;&lt;p&gt;贝壳下到的文件大小13,703,064字节，打包时间2008-09-11。经过贝壳查找，在eMule-VeryCD-srcsrc WordFilter发现两个文件，WordFilter.cpp 2008-03-12 09:57 13374和WordFilter.h 2007-11-20 17:56 1009。仔细阅读里面，发现有以下内容。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;void    CWordFilter::Init()&#xA;{&#xA;&#x9;HANDLE    hFile;&#xA;&#x9;DWORD    dwRead;&#xA;&#x9;int        nLen;&#xA;&#x9;BOOL    bResult;&#xA;&#x9;CStringList list;&#xA;&#xA;&#x9;//m_count = 0;&#xA;&#xA;&#x9;CString saaa = thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) + FLITER_FILE;&#xA;&#x9;CString sbbb = thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) + FLITER_FILE;&#xA;&#xA;&#x9;// 如果文件目录不对，程序移动一下，到config目录下 added by kernel1983 2006.07.31&#xA;&#x9;if (PathFileExists(thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) + FLITER_FILE))&#xA;&#x9;&#x9;MoveFile(thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) + FLITER_FILE, thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) + FLITER_FILE);&#xA;&#xA;&#x9;if (!PathFileExists(thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) + FLITER_FILE))&#xA;&#x9;{&#xA;&#x9;&#x9;// 不存在，所有的都过滤 added by kernel1983 2006.08.08&#xA;&#x9;&#x9;m_filterall = true;&#xA;&#x9;&#x9;return;&#xA;&#x9;}&#xA;&#xA;&#x9;// Open file for read&#xA;&#x9;hFile = CreateFile(thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) + FLITER_FILE, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);&#xA;&#x9;//AddLogLine(false,_T(&amp;quot;:%sn&amp;quot;),thePrefs.GetConfigDir() + FLITER_FILE);&#xA;&#x9;if(hFile == NULL || hFile == INVALID_HANDLE_VALUE)&#xA;&#x9;{&#xA;&#x9;&#x9;// 读取错误，所有的都过滤 added by kernel1983 2006.08.08&#xA;&#x9;&#x9;m_filterall = true;&#xA;&#x9;&#x9;return;&#xA;&#x9;}&#xA;&#xA;&#x9;DWORD dwSize = GetFileSize(hFile, NULL);&#xA;&#xA;&#x9;TCHAR * pszData = new TCHAR[(dwSize / sizeof(TCHAR)) + 1];            // 申请空间&#xA;&#x9;bResult = ReadFile(hFile, pszData, dwSize, &amp;amp;amp;dwRead, NULL);        // 读入文件1&#xA;&#x9;CloseHandle(hFile);&#xA;&#x9;pszData[(dwSize / sizeof(TCHAR))] = 0;&#xA;&#xA;&#x9;if(bResult)&#xA;&#x9;{&#xA;&#x9;&#x9;// 加入解码算法&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;std::string tempstr( (char*)pszData + 1 , ((int)dwSize - 1) &amp;amp;gt; 0 ? dwSize -1 : 0 );&#xA;&#xA;&#x9;&#x9;&#x9;// 查看是否是老格式&#xA;&#x9;&#x9;&#x9;char * pszData_a = (char*) pszData;&#xA;&#xA;&#x9;&#x9;&#x9;if( pszData_a[0] != 0x15 ) {&#xA;&#x9;&#x9;&#x9;&#x9;// 老格式，进行转换&#xA;&#x9;&#x9;&#x9;&#x9;CUnicodeToMultiByte wc2mb( thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) + FLITER_FILE );&#xA;&#x9;&#x9;&#x9;&#x9;tempstr.assign( (char*)pszData , dwSize );&#xA;&#x9;&#x9;&#x9;&#x9;InternalBase64::encode2file( tempstr , std::string((LPCSTR)wc2mb , wc2mb.GetLength()) );&#xA;&#xA;&#x9;&#x9;&#x9;&#x9;delete [] pszData;&#xA;&#x9;&#x9;&#x9;&#x9;// 重新载入&#xA;&#x9;&#x9;&#x9;&#x9;return Init();&#xA;&#x9;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;&#x9;vector vec = InternalBase64::decode( tempstr );&#xA;&#x9;&#x9;&#x9;char * pszt = (char*) pszData;&#xA;&#x9;&#x9;&#x9;for( size_t i = 0; i &amp;amp;lt; vec.size() ; i++ ) {&#xA;&#x9;&#x9;&#x9;&#x9;pszt[i] = vec[i];&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;dwSize = vec.size();&#xA;&#x9;&#x9;}&#xA;&#xA;&#x9;&#x9;TCHAR * pszTemp = wcstok(pszData + 1, _T(&amp;quot;rn&amp;quot;));&#xA;&#x9;&#x9;while(pszTemp != NULL)&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;nLen = wcslen(pszTemp);&#xA;&#x9;&#x9;&#x9;while(pszTemp[nLen - 1] == &#39;t&#39; || pszTemp[nLen - 1] == &#39; &#39;)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;nLen --;&#xA;&#x9;&#x9;&#x9;&#x9;pszTemp[nLen] = 0;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;while(*pszTemp == &#39;t&#39; || *pszTemp == &#39; &#39;)&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;pszTemp ++;&#xA;&#x9;&#x9;&#x9;&#x9;nLen --;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;//AddLogLine(false,_T(&amp;quot;pszTemp:%s&amp;quot;),pszTemp);&#xA;&#x9;&#x9;&#x9;//AddLogLine(false,_T(&amp;quot;nLen:%d&amp;quot;),nLen);&#xA;&#x9;&#x9;&#x9;if(nLen &amp;amp;gt; 0)list.AddTail(pszTemp);&#xA;&#x9;&#x9;&#x9;//if(nLen == 8)AddLogLine(false,_T(&amp;quot;:%d %d %d %d &amp;quot;),((char*)pszTemp)[0],((char*)pszTemp)[1],((char*)pszTemp)[2],((char*)pszTemp)[3]);&#xA;&#x9;&#x9;&#x9;pszTemp = wcstok(NULL, _T(&amp;quot;rn&amp;quot;));&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;delete[] pszData;&#xA;&#xA;&#x9;m_count = list.GetCount();&#xA;&#x9;//AddLogLine(false,_T(&amp;quot;m_count:%d&amp;quot;),m_count);&#xA;&#xA;&#x9;if(bResult &amp;amp;amp;&amp;amp;amp; m_count &amp;amp;gt; 0)&#xA;&#x9;{&#xA;&#x9;&#x9;m_filterwords = new TCHAR*[m_count+1];&#xA;&#x9;&#x9;m_kmpvalue = new int*[m_count+1];&#xA;&#x9;&#x9;ZeroMemory(m_filterwords, sizeof(TCHAR *) * m_count);&#xA;&#x9;&#x9;ZeroMemory(m_kmpvalue, sizeof(int *) * m_count);&#xA;&#x9;}&#xA;&#xA;&#x9;for(int i = 0; bResult &amp;amp;amp;&amp;amp;amp; (i &amp;amp;lt; m_count); i ++)&#xA;&#x9;{&#xA;&#x9;&#x9;CString s = list.GetAt(list.FindIndex(i));&#xA;&#x9;&#x9;s.MakeLower();&#xA;&#x9;&#x9;nLen = s.GetLength();&#xA;&#x9;&#x9;//AddLogLine(false,_T(&amp;quot;nLen:%d&amp;quot;),nLen);&#xA;&#x9;&#x9;m_filterwords[i] = new TCHAR[nLen + 1];&#xA;&#x9;&#x9;m_filterwords[i][nLen] = 0;    // 最后一个字节设为0&#xA;&#x9;&#x9;m_kmpvalue[i] = new int[nLen];&#xA;&#x9;&#x9;//AddLogLine(false,_T(&amp;quot;nLen:%d&amp;quot;),nLen);&#xA;&#x9;&#x9;_tcscpy(m_filterwords[i],s);&#xA;&#x9;&#x9;//AddLogLine(false,_T(&amp;quot;m_filterwords[i]:%s&amp;quot;),m_filterwords[i]);&#xA;&#x9;&#x9;KMP_GetNext(m_filterwords[i], m_kmpvalue[i]);    // 得到一个与内容有关的数值m_kmpvalue[i]&#xA;&#x9;}&#xA;&#xA;&#x9;if(m_count == 0 || !bResult)&#xA;&#x9;{&#xA;&#x9;&#x9;Free();&#xA;&#x9;&#x9;//m_filterall = true;&#xA;&#x9;}&#xA;}&#xA;&#xA;bool    CWordFilter::VerifyString(const CString &amp;amp;amp; sString)    // 验证字符是否合法&#xA;{&#xA;&#x9;bool bIsRm = sString.Right(3)==_T(&amp;quot;.rm&amp;quot;);&#xA;&#x9;CString sReduceString=sString;&#xA;&#x9;CString sInterpunctionString = _T(&amp;quot;（），().。·；：－《》『』～　“”〓！【】★×┇&amp;quot;);&#xA;&#x9;try // VC-Huby[2007-03-20]:满足中国国情特色,加强过滤&#xA;&#x9;{&#xA;&#x9;&#x9;int j=0;&#xA;&#x9;&#x9;for( int i=0; i&amp;amp;lt; sString.GetLength(); i++ )&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;if( sString.GetAt(i)&amp;amp;lt;=_T(&#39;/&#39;) &amp;amp;amp;&amp;amp;amp; sString.GetAt(i)&amp;amp;gt;=_T(&#39; &#39;) ) //从空格到&#39;/&#39;之间的字符减掉后再过滤&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if( sString.GetAt(i)&amp;amp;lt;=_T(&#39;@&#39;) &amp;amp;amp;&amp;amp;amp; sString.GetAt(i)&amp;amp;gt;=_T(&#39;:&#39;) )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if( sString.GetAt(i)&amp;amp;lt;=_T(&#39;`&#39;) &amp;amp;amp;&amp;amp;amp; sString.GetAt(i)&amp;amp;gt;=_T(&#39;[&#39;) )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if( sString.GetAt(i)&amp;amp;lt;=_T(&#39;~&#39;) &amp;amp;amp;&amp;amp;amp; sString.GetAt(i)&amp;amp;gt;=_T(&#39;{&#39;) )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else if( sInterpunctionString.Find(sString.GetAt(i))&amp;amp;gt;=0 )&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;&#x9;else&#xA;&#x9;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;&#x9;sReduceString.SetAt(j,sString.GetAt(i));&#xA;&#x9;&#x9;&#x9;&#x9;j++;&#xA;&#x9;&#x9;&#x9;}&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if( j&amp;amp;lt; sString.GetLength() )&#xA;&#x9;&#x9;&#x9;sReduceString.SetAt(j,_T(&#39;&#39;));&#xA;&#x9;}&#xA;&#x9;catch (...)&#xA;&#x9;{&#xA;&#x9;}&#xA;&#xA;&#x9;if(m_filterall){&#xA;&#x9;&#x9;//AddLogLine(false,_T(&amp;quot;m_filterall&amp;quot;));&#xA;&#x9;&#x9;return true;    // 检测不到文件，或者读取错误的情况下放弃过滤&#xA;&#x9;}&#xA;&#x9;if(m_count == 0){&#xA;&#x9;&#x9;//AddLogLine(false,_T(&amp;quot;m_count == 0&amp;quot;));&#xA;&#x9;&#x9;return true;    // 文件是空的时候，放弃过滤功能&#xA;&#x9;}&#xA;&#x9;CString strSearch = ((CString)sReduceString).MakeLower();&#xA;&#xA;&#x9;//vc-huby: 过滤中文字符超过15字符&#xA;&#x9;//CString sReduceString2=strSearch;&#xA;&#x9;int k=0;&#xA;&#x9;for( int i=0; i&amp;amp;lt; strSearch.GetLength(); i++ )&#xA;&#x9;{&#xA;&#x9;&#x9;if( strSearch.GetAt(i)&amp;amp;lt;=_T(&#39;9&#39;) &amp;amp;amp;&amp;amp;amp; strSearch.GetAt(i)&amp;amp;gt;=_T(&#39;0&#39;) )&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;if( strSearch.GetAt(i)&amp;amp;lt;=_T(&#39;z&#39;) &amp;amp;amp;&amp;amp;amp; strSearch.GetAt(i)&amp;amp;gt;=_T(&#39;a&#39;) )&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;continue;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;else&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;k++;&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#xA;&#x9;if( k&amp;amp;gt;=20 &amp;amp;amp;&amp;amp;amp; bIsRm )&#xA;&#x9;&#x9;return false;&#xA;//int m = sReduceString2.GetLength();&#xA;/*&#xA;  if( k&amp;amp;gt;=60 )&#xA;  return false;*/&#xA;&#xA;/*if (strSearch.GetLength() &amp;amp;gt; 20)&#xA;  {&#xA;  return false;&#xA;  }*/&#xA;&#xA;&#x9;for(int i = 0; i &amp;amp;lt; m_count; i ++)&#xA;&#x9;{&#xA;&#x9;&#x9;if(KMP_Match(strSearch, m_filterwords[i], m_kmpvalue[i]))&#xA;&#x9;&#x9;{&#xA;&#x9;&#x9;&#x9;//AddLogLine(false,_T(&amp;quot;KMP_Match&amp;quot;));&#xA;&#x9;&#x9;&#x9;return false;    // 关键词命中了，被fliter了&#xA;&#x9;&#x9;}&#xA;&#x9;}&#xA;&#x9;//AddLogLine(false,_T(&amp;quot;漏掉的&amp;quot;));&#xA;&#x9;return true;&#xA;&#xA;}&#xA;&#xA;void CWordFilter::Free()    //&#xA;{&#xA;&#x9;for(int i = 0; i &amp;amp;lt; m_count; i ++)&#xA;&#x9;{&#xA;&#x9;&#x9;if(m_filterwords[i])&#xA;&#x9;&#x9;&#x9;delete[] m_filterwords[i];&#xA;&#x9;&#x9;if(m_kmpvalue[i])&#xA;&#x9;&#x9;&#x9;delete[] m_kmpvalue[i];&#xA;&#x9;}&#xA;&#x9;delete[] m_filterwords;&#xA;&#x9;delete[] m_kmpvalue;&#xA;}&#xA;&#xA;CWordFilter::~CWordFilter()&#xA;{&#xA;&#x9;Free();&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;其中WordFilter.h的第17行有以下定义。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
