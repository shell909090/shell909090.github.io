<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Api on Shell&#39;s Home</title>
    <link>//blog.shell909090.org/tags/api/</link>
    <description>Recent content in Api on Shell&#39;s Home</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Wed, 23 Feb 2011 10:14:00 +0800</lastBuildDate>
    <atom:link href="//blog.shell909090.org/tags/api/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>gfw升级了？</title>
      <link>//blog.shell909090.org/blog/archives/1704/</link>
      <pubDate>Wed, 23 Feb 2011 10:14:00 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/1704/</guid>
      <description>&lt;p&gt;今天使用的主机上有个朋友发来消息，api用不了了。贝壳检查了一下，主机正常阿。&lt;/p&gt;&#xA;&lt;p&gt;最终，发现问题是这样的。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;shell@shell-deb:\~/tmp\$ wget &amp;lt;http://shell909090.org/apis/&amp;gt;&#xA;--2011-02-23 10:08:39--  &amp;lt;http://shell909090.org/apis/&amp;gt;&#xA;正在解析主机 shell909090.org... 74.86.182.175&#xA;正在连接 [shell909090.org](http://shell909090.org)|74.86.182.175|:80...&#xA;已连接。&#xA;已发出 HTTP 请求，正在等待回应... 读取文件头错误 (Connection reset by peer)。&#xA;重试中。&#xA;&#xA;--2011-02-23 10:08:41--  (尝试次数： 2)  &amp;lt;http://shell909090.org/apis/&amp;gt;&#xA;正在连接 [shell909090.org](http://shell909090.org)|74.86.182.175|:80...&#xA;^C&#xA;&#xA;shell@shell-deb:\~/tmp\$ wget &amp;lt;http://shell909090.org/&amp;gt;&#xA;--2011-02-23 10:13:36--  &amp;lt;http://shell909090.org/&amp;gt;&#xA;正在解析主机 shell909090.org... 74.86.182.175&#xA;正在连接 [shell909090.org](http://shell909090.org)|74.86.182.175|:80...&#xA;已连接。&#xA;&#xA;已发出 HTTP 请求，正在等待回应... 200 OK&#xA;长度：1156 (1.1K) \[text/html\]&#xA;正在保存至: “index.html”&#xA;100%\[======================================&amp;amp;gt;\] 1,156       --.-K/s&#xA;花时 0s&#xA;2011-02-23 10:13:37 (277 MB/s) - 已保存 “index.html” \[1156/1156\])&#xA;&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    <item>
      <title>实践NTFS格式解析</title>
      <link>//blog.shell909090.org/blog/archives/185/</link>
      <pubDate>Sun, 03 Jul 2005 23:04:20 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/185/</guid>
      <description>&lt;p&gt;刚刚在想NTFS格式的问题，感叹没有个实例拿来看看。然后在看小说的时候不知道怎么回事，想到点子上了。不由骂自己白痴，这个问题其实早就解决了阿。直接用CreateFile去读&lt;a href=&#34;&#34;&gt;\.c&lt;/a&gt;:文件不就好了……&lt;/p&gt;&#xA;&lt;p&gt;OK，明天写个程序看看NTFS的实质……也许还有别的用途，再说了。&lt;/p&gt;&#xA;&lt;p&gt;另外写个想法，也许NTFS中很多MFT表项没有被某个目录引用成为文件，而其引用计数大于一（这样会被chkdsk查出来吗？等于0会吗？会删除吗？表问咯，偶都不知道……）。这样就会造成系统空间的神秘减少。例如上次系统文件复制时候空出来的硬盘，上面全空，但是使用了400M多的空间。估计就是这么搞出来的。具体要察看chkdsk的机理才知道，因为偶的硬盘经常chkdsk的。如果是属于能查的出来的错误，肯定就不会延迟到换硬盘才发现。可能是chkdsk不检查这个……&lt;/p&gt;&#xA;&lt;p&gt;另外回头准备看看内核的机制，试试记录或者反木马能不能提前挂在内核态上……嘿嘿，里席必争，咏春的要诀……&lt;/p&gt;&#xA;&lt;p&gt;这次仔细看了MFT的格式。有点心得，先写下来。&lt;/p&gt;&#xA;&lt;p&gt;首先是从MBR定位到每个BOOT区的BPB，这样才可以获得BPB中的$MFT和$MFTMirr的LCN。并且会获得卷因子（多数都是0x08吧，4k的簇）。$MFT的LCN多数是4，定位就是32(0x20)。而后就会定位到MFT表上去。&lt;/p&gt;&#xA;&lt;p&gt;MFT的表项分析起来是遵循链式结构的，不过为什么有那么好的性能和抗崩溃能力呢？可能在于USN和LSN吧。每个表项有个头部（详细看linux的ntfs/layout.h去），指明了大小，关联了相关MFT表项和上下MFT表项，以及这个MFT表项的全局属性。由其中可以引出首个属性的相对偏移。&lt;/p&gt;&#xA;&lt;p&gt;每个属性都有个公用的属性头部，这个头部说明了属性的类型和大小，还有属性是否直接存储，如何存储等等信息。由上个属性可以推知下个属性偏移，所以属性应该是链式存储的。不知道这里是否具有超长链溢出的问题（长度超过最大值的一半）。&lt;/p&gt;&#xA;&lt;p&gt;另外，在文件名称属性中具有引用目录项目，所以上面猜测的可能无法成立。不过引用目录和硬连接是违背的阿……下次再分析好了，困了困了……&lt;/p&gt;&#xA;&lt;p&gt;OK,继续分析。根据刚刚的阅读，一个文件可以分散在多个MFT中，而后就会引入一个叫attribute&lt;/p&gt;&#xA;&lt;p&gt;list的属性。这个属性指明了每个属性属于那个MFT引用中。其中VCN的换算关系比较特别，基本MFT算-1，下面依次排开，扩展MFT也算进去的。似乎一个MFT就算一簇。不过VCN和LCN的映射关系让我头痛了半个钟头，最后也没有在linux的头文件中找到。到是在NTFS.com中文件恢复上找到了说明。原文如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;00012580   2E 00 70 00 70 00 74 00  80 00 00 00 48 00 00 00   ..p.p.t.Ђ...H...&#xA;00012590   01 00 00 00 00 00 04 00  00 00 00 00 00 00 00 00   ................&#xA;000125A0   6D 00 00 00 00 00 00 00  40 00 00 00 00 00 00 00   m.......@.......&#xA;000125B0   00 DC 00 00 00 00 00 00  00 DC 00 00 00 00 00 00   .U.......U......&#xA;000125C0   00 DC 00 00 00 00 00 00  31 6E EB C4 04 00 00 00   .U......1neA....&#xA;000125D0   FF FF FF FF 82 79 47 11  00 00 00 00 00 00 00 00   yyyy‚yG.........&#xA;&#xA;Data Runs need to be decrypted. First byte (0x31) shows how many bytes&#xA;are allocated for the length of the run (0x1 in our case) and for the&#xA;first cluster offset (0x3 in our case). Next, we take one byte (0x6E)&#xA;that points to the length of the run. Next, we pick up 3 bytes pointing&#xA;to the start cluster offset (0xEBC404). Changing bytes order we get&#xA;first cluster of the file 312555 (equals 0x04C4EB). Starting from this&#xA;cluster we need to pick up 110 clusters (equals 0x6E). Next byte (0x00)&#xA;tells us that no more data runs exist. Our file is not fragmented, so we&#xA;have the only one data run.&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;按照上面的说法，这个映射对也是一个链表。而且是一个非定项长非定长的链表，Null-trim的。每个段的起始一字节分成高低两个区域，高四位记录了多少字节用于记录LCN，低字节记录了多少字节用于记录运行长度。后面跟了不定长的运行长度和LCN（注意先是运行长度）。如果举$Boot的$DATA的例子来说，数值上就是11 02 00 00。描述了分区的头两个扇区，也就是Boot区，BPB表的位置。这样安排，可以使得整个分区全部规划在16个主要MFT的树型属性下面。世界完美了……&lt;/p&gt;</description>
    </item>
    <item>
      <title>利用API插接替换破解软件</title>
      <link>//blog.shell909090.org/blog/archives/171/</link>
      <pubDate>Thu, 02 Jun 2005 12:07:53 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/171/</guid>
      <description>&lt;p&gt;刚刚在看软件破解教程，看到一个人说怎么怎么破解软件。然后突然想到，许多软件破解其实不用修改出flag或者找注册算法。只要对话框不出来，软件照常好用就可以了。OK，基于这个原理，试试用DLL注入插接API的方法RIP破解软件。&lt;/p&gt;&#xA;&lt;p&gt;首先是对话框弹出机理。先写了个MFC程序，然后跑一跑，在运行中按着DoModel()一路F11下去，跟进了CWnd::CreateDialogIndirectPreamA云云的一个函数里面（名字忘记了）。然后就是一个API调用了。（__IMP__Creat&amp;hellip;肯定是调用别的DLL的函数了）API内容看不到……我晕。编译一个Release版的出来，然后上Ollydbg。经过跟踪，确定了窗体句柄是在USER32.CreateDialogIndirectPreamAorW里面生成的。如果没有窗体句柄呢？&lt;/p&gt;&#xA;&lt;p&gt;貌似有两种可能，一种是没事，对话框没了。一种是报错。按照试验，Readbook至少是没事情的。哈哈，这样简单多了。整理下顺序，基本就可以做RIP破解了。&lt;/p&gt;&#xA;&lt;p&gt;首先是用OllyDbg等等软件定位USER32.CreateDialogIndirectPreamAorW（其实USER32.CreateDialogIndirectPreamA更好，如果只用这个的话比较好确定参数类型）。然后下断点，跑到软件里面触发窗口广告……然后记录对话框的模板位置，调试的任务就结束了。因为没有啥要判断的东西，这个应该说简单到顶点了。&lt;/p&gt;&#xA;&lt;p&gt;然后写一个DLL注入程序，运行目标程序并且Suspend。然后注入DLL，挂接API。详细参看windows核心编程，现在我们假定挂接了USER32.CreateDialogIndirectPreamA。现在有了一个自主的处理函数，只要在里面判断模板是否为特定模板就好……这个是module的一个res，理论上不是动态生成的，所以位置不变。而且一个对话框一个模板，很好认不会出错。如果是特定模板就返回NULL，否则正常调用。这样程序的提示框就永远弹不出来了。&lt;/p&gt;&#xA;&lt;p&gt;这个其实是将软件的对话框禁止技术搬到了API层去实现，由于API层代码相对稳定，通用性强，所以破解相对简单。不过也是有代价的。如果软件无法生成对话框会导致出错……这个就没戏了。而且要写注入程序（可以写个注入的模板，或者一次写好可以多次用……），毕竟不是直接运行程序，使用不大方便。而且速度会受影响，如果程序里面对话框满天飞的话……&lt;/p&gt;</description>
    </item>
    <item>
      <title>光盘镜像Copy、底层文件读写和CreateFile</title>
      <link>//blog.shell909090.org/blog/archives/164/</link>
      <pubDate>Sat, 28 May 2005 00:22:58 +0800</pubDate>
      <guid>//blog.shell909090.org/blog/archives/164/</guid>
      <description>&lt;p&gt;1.CreateFile读写文件，设备，网络。&lt;/p&gt;&#xA;&lt;p&gt;刚刚看到有人在问，知道了数据的物理位置，如何读取光盘上的数据。于是我很纳闷，这有何难。看他的意思不会是要编程进行硬件交互读取吧。如果已知数据的偏移地址，那么使用CreateFile(&amp;quot;&lt;a href=&#34;file://.X&#34;&gt;\.X&lt;/a&gt;:&amp;quot;&amp;hellip;)就可以直接读取某个盘上的数据了。（Windows 2000 Support Tools中DiskProbe就是用这种方法直接读写物理磁盘的，包括可以读写0面0道0扇区，不过他用的对象是&lt;a href=&#34;file://.PHYSICALDRIVEx&#34;&gt;\.PHYSICALDRIVEx&lt;/a&gt;而已）&lt;/p&gt;&#xA;&lt;p&gt;还有可以打开的对象包括管道（会用的人一定知道），文件（废话），Consoles（简单来说就是命令行界面），通信资源（例如COM1）。据说还可以打开内存，似乎是PHYSICMEM资源，记不得了。&lt;/p&gt;&#xA;&lt;p&gt;以上资源的打开都有限制的，多数都比较简单，就是在打开时候使用OPEN_EXISTING标志。另外还有些当然的限制，例如光盘不能做为GENERIC_WRITE打开（我是没有试过啦，不过想也知道，光盘哪里能写。）&lt;/p&gt;&#xA;&lt;p&gt;举例来说，这次我做的ISO镜像制作程序（ISO可以是光盘的按字节镜像），代码大致就是这样的。（以下代码都是伪代码，不要拿去编译哦。）&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;GetLogicalDriveStrings(nBufferLength, lpBuffer);&#xA;lpRootPathName=lpBuffer;&#xA;while( lpRootPathName\[0\] ){&#xA;&#x9;if(GetDriveType(lpRootPathName) &amp;amp; DRIVE\_CDROM )&#xA;&#x9;&#x9;break;&#xA;&#x9;lpRootPathName+=strlen(lpRootPathName)+1;&#xA;};&#xA;if( !lpRootPathName\[0\] )&#xA;&#x9;return -1;&#xA;strcpy(RootPathName, &amp;quot;\\.&amp;quot;);&#xA;strcat(RootPathName, lpRootPathName);&#xA;RootPathName\[strlen(RootPathName)-1\]=0;&#xA;hFileCDROM=CreateFile(RootPathName,&#xA;&#x9;&#x9;&#x9;  GENERIC\_READ,//我要做镜像，不是刻盘（不知道能不能刻）&#xA;&#x9;&#x9;&#x9;  FILE\_SHARE\_READ, NULL,&#xA;&#x9;&#x9;&#x9;  //你这个用户有访问能力就是NULL，没有自己去看API编程去 OPEN\_EXISTING,&#xA;&#x9;&#x9;&#x9;  //必须如此,这个是打开光盘的限制条件 FILE\_ATTRIBUTE\_NORMAL |&#xA;&#x9;&#x9;&#x9;  FILE\_FLAG\_OVERLAPPED, //交叠模式&#xA;&#x9;&#x9;&#x9;  0);&#xA;hFileISO=CreateFile(ISOpath, GENERIC\_WRITE, 0, NULL,&#xA;&#x9;&#x9;&#x9;OPEN\_ALWAYS, FILE\_ATTRIBUTE\_NORMAL, 0);&#xA;Overlap.hEvent=CreateEvent(NULL, FALSE, FALSE, NULL);&#xA;do{&#xA;&#x9;Overlap.Offset=...;&#xA;&#x9;Overlap.OffsetHigh=...;&#xA;&#x9;ReadFile(hFileCDROM, lpBuffer, BUFF\_SIZE,&#xA;&#x9;&#x9; &amp;amp;NumberOfBytes, &amp;amp;Overlap);&#xA;&#x9;WaitForSingleObject(olRead.hEvent, TimeOut);&#xA;&#x9;if(!GetOverlappedResult(hFileCDROM, &amp;amp;Overlap, &amp;amp;NumberOfBytes, FALSE) ){&#xA;&#x9;&#x9;switch( GetLastError() ){&#xA;&#x9;&#x9;case ERROR\_IO\_INCOMPLETE:&#xA;&#x9;&#x9;&#x9;CancelIo(hFileCDROM);&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;default:&#xA;&#x9;&#x9;&#x9;break;&#xA;&#x9;&#x9;}&#xA;&#x9;&#x9;//error&#xA;&#x9;}&#xA;&#x9;WriteFile(hFileISO, lpBuffer, BUFF\_SIZE, &amp;amp;NumberOfBytes, NULL);&#xA;}while( 1 );&#xA;CloseHandle(Overlap.hEvent);&#xA;CloseHandle(hFileISO);&#xA;CloseHandle(hFileCDROM);&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;p&gt;2.OVERLAPPED模式和大文件&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
