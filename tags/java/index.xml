<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Shell&#39;s Home</title>
    <link>http://blog.shell909090.org/tags/java/</link>
    <description>Recent content in Java on Shell&#39;s Home</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>CC-BY-SA4.0</copyright>
    <lastBuildDate>Tue, 30 Oct 2012 16:42:25 +0800</lastBuildDate>
    
	<atom:link href="http://blog.shell909090.org/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>异常之殇</title>
      <link>http://blog.shell909090.org/blog/archives/2266/</link>
      <pubDate>Tue, 30 Oct 2012 16:42:25 +0800</pubDate>
      
      <guid>http://blog.shell909090.org/blog/archives/2266/</guid>
      <description>异常之殇 辗转开解 辗转开解(stack unwinding)说的其实是这么一个现象。当执行流从深层向浅层转移时，深层调用所产生的栈上对象(stack object)需要销毁，资源需要释放。对于面对对象语言而言，往往就会执行到析构函数。
辗转开解中的异常 辗转开解真正令人迷惑之处在于，如果在析构函数中发生错误怎么办？在异常处理中发生异常，我们可以继续向上抛出。但是在辗转开解代码中出现异常，上层应当收到两个异常呢？还是一个？
无论是哪种可能，都没有完美自恰的符合直觉，因此这一般是一个未定义的行为。在C++中，进程会整个彻底崩溃掉的。因此，千万不要在析构函数内抛出(或者可能抛出)异常。
如果分离析构和资源销毁 一种做法是，在析构时不做资源销毁，转而提供专门的函数来执行资源销毁过程。析构只处理简单的delete等操作。然而这种做法的杯具在于，你在任何时候，一旦使用对象，都必须使用finally来保证销毁函数的调用。在发生异常时，栈上对象的辗转开解是自动的，析构函数的调用也是自动的，但是销毁函数的调用就是手工的了。
拷贝构造和隐式转换 和构造相反，对于构造函数，我们不能限制异常使用。你必须捕获构造函数的异常。
假如构造函数出了错 普通函数出错，你有两种选择。1. 异常。2. 返回值。构造函数出错，是没有选项2的。因此构造函数凡是出错必定异常。
而如果构造函数可能出错，而你期望捕获他，你就不能栈上构造一个对象出来。因为这会导致栈上对象的作用域被限定在捕获他所用的try块之内。
分离构造的尝试 和析构函数类似，我们可以尝试在构造函数外，提供一个构造函数，来替代构造的初始化过程。这样可以很大程度上保证构造函数不出错。
然而，首先，这样的代码就会变的复杂。每次构造函数完成调用后，都必须调用初始化函数。而且，有两种特殊的构造函数你不可能使用这种方法来解决。
拷贝构造和隐式转换 是的，这两种构造函数分别叫做拷贝构造(copy construct)和隐式转换(implicit casting)。我们举例来说。如果你在函数内建立了一个对象，你希望返回这个对象，怎么做呢？第一个思路是引用返回。不幸的是，要做引用返回，这个对象必须是堆上对象，而非栈上对象。因为栈上对象在返回后会销毁掉。如果要返回栈上对象，唯一靠谱的方案是先将对象复制到堆上，然后再复制到调用者的栈里。
C++中有一类特殊的优化，叫做对象返回优化。当编译器察觉到你需要返回栈上对象时，那么编译器会直接获得调用者栈里的对象地址。这样可以避免两次的拷贝过程。然而，如果没有对象返回优化（或者没有识别出来），那么就需要两次复制以保证正确性。而C++里，默认的复制过程是内存拷贝。
对于很多对象，内存拷贝是错误的行为。例如字符串，一种字符串的加速方法叫做共享内存字符串。两个字符串对象会共享一个内存块，以避免重复内容的开销。直到其中一块需要修改时，复制才真的继续。对于这种情况，直接拷贝会明显的导致错误。因此C++有一种特殊的构造函数，叫做拷贝构造。
在拷贝构造的时候，调用是由C++隐式发生的，你根本没有先构造，再调用的机会和权力。因此，试图分离构造在技术上不可行。
隐式转换是另一种情况。当你传递的参数和实际被赋值对象的类型不一致时（例如调用了某个函数，其参数类型不一致），C++会试图将你的对象转换为目标对象。如果是内部类型，这个被称为内部隐式转换。unsigned char可以被无错的转换为unsigned long，这个大家都知道。但是如果是对象，转换行为就需要由构造函数定义，这个叫做隐式转换构造函数。
另外，隐式转换也是OO中的一大问题。我强烈建议你用explicit禁用所有隐式转换，改为显式转换。这会费一点事，但是却可以避免很多问题。
分离构造/析构的邪恶之处 ZMQ的作者曾经吐槽过这种在构造/析构之外再定义初始化/清除代码的努力。他的观点是，如果万一在构造函数中加入了代码，会引起半构造现象。为了解决这个问题，会使得整个类带上状态。我在上面已经假定这件事情不会发生了，否则代码会更加复杂，问题也更加严重。
二次异常 是的，你不应当在异常处理代码中抛出异常。当然，这里的异常指的是你的异常处理代码不应当发生异常。经过逻辑判定，当前的异常应当由更上层处理的情况不在此列。
如果在异常处理中抛出异常，很可能导致的结果就是异常处理没有完成。而未完成的异常处理会发生什么问题，那只有天晓得。这个在任何带有异常系统的语言中都是成立的。</description>
    </item>
    
    <item>
      <title>面对对象的吐槽——类型之殇</title>
      <link>http://blog.shell909090.org/blog/archives/2265/</link>
      <pubDate>Mon, 29 Oct 2012 14:26:30 +0800</pubDate>
      
      <guid>http://blog.shell909090.org/blog/archives/2265/</guid>
      <description>继承之殇 讲继承问题，我们首先得定义什么是继承(inherit)，他是用来干吗的。
所谓继承，就是当两种实体，满足其中一种必然全部都满足另一种的定义(is a)。一旦构成继承，可以带来以下好处（简单起见，我们直接就管这俩实体一个叫派生类一个叫父类）：
 派生类具备父类所有已经实现的方法，毋须再实现一遍——除非需要重写(override)。 派生类可以当作父类使用，凡是使用父类的地方给与派生类也对。  继承的最主要作用，是用于复用(reuse)。
内涵和外延 形式逻辑里面有一句话，内涵越大，外延越小。在继承上，如果我们严格按照定义来做，会发生很反人类的事情。因为类的定义是依赖于内涵的，
我们还是看平行四边形，长方形和正方形的例子。我们用两边长度，夹角来定义平行四边形。然后如何定义长方形？夹角为pi/2。然后如何定义正方形？两边长度相当。
不知道你是否看出了问题。是的，按照正统来定义，数据的约束只会越来越多。因为派生类必须是(ISA)父类，因此父类的约束必须全部满足。我们接着上面的例子，我们为平行四边形定义一个方法，设定夹角大小。那么在长方形中，这个方法如何处理？一旦用户调用方法设定夹角大小，必然会破坏长方形定义，因此这个方法只能重写抛错。
为什么？从逻辑的本源来说，平行四边形是“两组对边分别平行”，并没有说夹角的事情。到长方形的时候才说，长方形是夹角为90度的平行四边形。显然，长方形是不能设定夹角的。因此，我们要么承认，不是每个平行四边形都可以设定夹角的，例如长方形不行。要么承认，每个平行四边形都可以设定夹角，长方形不是平行四边形。显然，后者违背逻辑，我们只能得出结论，不是每个平行四边形都可以设定夹角。
同样，正方形的例子也说明，不是每个平行四边形都可以设定两个分离的边长。如果以此标准来定义类，那么必然得到的是正确而无用的逻辑玩具。平行四边形没有夹角，我们就不能定义面积计算的函数，也不能——基本什么都不可以。更过分的是，我们还不能定义两个分离的边长，因为定义并没有告诉我们，边长一定不等。照此下去，我们除了一个空空荡荡的“平行四边形”这个名字外，什么都定义不下去。
为了解决这个问题，实践中，我们采取的都是，平行四边形是可以设定夹角的，然后对特例做抛错处理。这其实在本质上就违背了继承的原初意义。
继承和聚合 继承的另一个容易混淆的地方，就是分不清继承和聚合。
其实从逻辑上说。继承和聚合根本就不是一回事情。例如你有(have a)一条狗，你可以让狗做任何狗可以做的事情，例如追猎物。我们可以说，你可以做的事情和狗没有区别，所以——你就是(ISA)一条狗？！
傻子都不会弄错其中的区别！
我们说，如果一个东西看起来像鸭子，叫起来像鸭子，走起路来像鸭子，我们就可以当他是一只鸭子，说的是弱类型语言。而且我们只能认为，我们不知道那个东西是什么(这是弱类型的特点)，总之可以当他是一只鸭子用。但是这不代表那个东西就是一只鸭子，他也可以是鸭子的代理人，或者拥有一只鸭子。在静态类型语言中，为了复用就不管三七二十一，直接声明PNG图像是一种BMP图像的——这绝对是逻辑上错误的行为。
然而，你自己数数你在代码里面犯过多少次错？
多重继承 继承本身的问题我们先不说，我们再说一个很常见的问题——多重继承。
既然我们说，只要一种满足ISA谓词判定，就可以认为是继承。那么理论上，我们就不能否决双重继承。例如我们定义了平行四边形，又定义了中心对称图形。那么长方形就同时是(ISA)这两者。从逻辑关系上，我们说长方形可以合法的继承两者。
但是如果我们真的在程序内设定将长方形继承两者，马上会引起一连串的问题。
当多重继承发生冲突时 首先第一个是继承冲突。即当两个父类都具备同一个方法的时候，对派生类做方法调用会发生什么行为？
 肯定不能只调用一个，这会因此另一个父类的方法间发生内在不一致。这违背了继承的好处2。 也不能两个都调用。两者的先后次序可能引发逻辑问题，因此先调用谁都是错误的。而且函数还有返回值问题——你返回谁的返回值呢？如果多值返回合并，这和函数原始的定义又发生了悖离，从而又违背了继承的好处2。 因此，我们只能宣布这是个错误。 既然是个错误，鉴于类间函数可能存在的内在联系，其他继承的函数也未必能够正常使用。  你看，明明是合法的多重继承，居然造成了不可复用的结果。这就是继承冲突。
菱形继承 如果说继承冲突还是一个比较好考虑的问题的话，菱形继承就是一个让人吐血的东西了。
所谓菱形继承，就是两个父类继承同一个基类。在这种情况下，对父类的调用会间接转到基类上。那么，基类的函数会调用几次呢？
继承冲突的几种解法  所有冲突的函数，父类必须都无实现。 不得多重继承。这是很扯淡的，不过也是大多数时候的做法。我的编程指南之一就是——在C++中，任何时候都不要使用多重继承。 使用其中一者。python是个典型的使用其中一者的例子，具体使用的按照继承编写顺序展开成MRO次序决定。然而这直接违背了继承类是(ISA)父类的定义。因此不要以为在python中，继承后总是没问题的。有的时候可能会出现继承后不能正常工作的情况。 强制用户解决。要求用户必须人工定义函数，解决继承冲突的问题。从逻辑上说，如果用户定义的函数可以同时兼容于两个父类，就可以彻底化解多重继承冲突问题。然而杯具的是，很多时候在逻辑上，继承冲突是无解的。  区分接口和继承 父类没有实现冲突的函数，那么派生类中就不必纠结于调用谁的问题了。但是这引发了另一个问题——这就无法复用了。作为这一解法的极限，java不允许多重继承——除非继承的父类都是没有实现的类。这其实不是继承，而是实现(implement)接口(interface)。
接口编程是一个很有道理的东西，COM里面大量着重于接口。但是接口也有自己扯淡的地方——接口是一个编写期的东西，他最大的用途就是编译期类型检查。接口并不能复用(reuse)代码。如果你有一个接口，叫做平行四边形。里面有个方法，用于计算平行四边形面积。然后你实现了长方形和正方形——那么杯具来了，你需要在两个里面通通实现一遍这个方法，即使他们基本没区别。
当然，接口本身的好坏各有评价。你看，接口的唯一作用，就是声明类提供了某些函数。当我们对方法传入一个新的类的时候，我们必须将新的类也实现一下接口——哪怕这个类其实已经实现了这些方法。只要不实现接口，方法就不认可。这是强制编译器类型检查(静态类型语言)的基础。因此一般来说，静态类型语言，使用接口。动态类型语言，duck typing。</description>
    </item>
    
    <item>
      <title>从C&#43;&#43;的一个特性到设计原则再到哲学</title>
      <link>http://blog.shell909090.org/blog/archives/1875/</link>
      <pubDate>Mon, 08 Aug 2011 09:59:46 +0800</pubDate>
      
      <guid>http://blog.shell909090.org/blog/archives/1875/</guid>
      <description>最近在看C++的设计和演化，里面讲到算符重载。关于这个，Effactive C++里面明确说明，不要试图重载&amp;amp;&amp;amp;和||算符。因为这个重载造成的结果和默认不符(Not same with the default)。
&amp;amp;&amp;amp;和||有什么特殊？熟悉C的朋友考虑这么一个问题。if(i &amp;amp;&amp;amp; ++i)的作用是什么？基本来说，这个语句是判断i是否为0或者-1的，并且有个额外效果就是对i进行自增。但是，如果i == 0，则不进行自增，这就是&amp;amp;&amp;amp;的短路求值原则。这个原则产生了一系列写法，例如sh中常见的[ -z &amp;ldquo;\$ABC&amp;rdquo; ] &amp;amp;&amp;amp; { &amp;hellip; }。
不过当重载了&amp;amp;&amp;amp;或者||后，就破坏了短路求值原则。因为C系列语言是应用序语言，参数先求值。所以后参数*一定*会被求值，无论前参数的值是多少。
更加悲崔的是，这个破坏了最小惊讶原则，或者叫做知识内隐原则。当你使用一个知识的时候，你会根据自己的经验对这个知识做内隐的预期。例如，虽然螺丝有左螺纹也有右螺纹，然而你在拧螺丝的时候，多数预期是顺时针拧紧。不论其理由，这个已经成为常态。同样，有下压把手的门是扇页门，画着杯子的店家是咖啡店和茶馆，画着裙子的厕所是女厕，这些都是你对知识内隐的预期。破坏这个预期，相当于把螺丝改为反向，下压把手的门改成移门，画着杯子的店家是古董店，男厕画裙子一样，会让人感到不知所措。大家会莫名其妙的绕出去，确认门上画的确实是裙子，走进去再看到男厕，感到世界莫名其妙。
同样的道理，如果一个对象使用了&amp;amp;&amp;amp;重载，程序员唯一能够快速发现的机会就是在调试时单步了&amp;amp;&amp;amp;的语句。如果他运气不好，可能在数个小时内都找不到理由，直到反汇编目标代码为止。
那C++为什么设计算符重载？那是设计给需要的算符用的。其实C++一直是一个矛盾的设计，一方面他认为，程序员是不可信的，所以C++里面有隔离保护系统，例如私有成员函数和变量。另一方面，他又认为程序员应当对自己的行为负责，因此他设计了复杂的算符重载，复杂的继承系统，并期待程序员能够按照正确的方法使用。这是一个奇妙的，矛盾的设计思路，反映设计者自身的冲突（例如多人设计），或者C++设计者的实用主义倾向（选择最实用的设计）。python语言的思路相对统一，他认为程序员应当为自己的行为负责，所以python的隔离系统都是伪系统。而java的思路也相对统一，他认为程序员是不可信的，所以java才会搞出复杂的架构哲学。</description>
    </item>
    
    <item>
      <title>为什么我说框架和工具不是解决安全性的良好方案</title>
      <link>http://blog.shell909090.org/blog/archives/1663/</link>
      <pubDate>Thu, 30 Dec 2010 16:24:00 +0800</pubDate>
      
      <guid>http://blog.shell909090.org/blog/archives/1663/</guid>
      <description>在python-cn的maillist上，刚刚爆发了一场关于动态语言合并出错的争论。问题的起源，来自于这样一个问题。
一个程序员A，写了一个函数，function1。程序员B对函数进行了调用。现在两个人分别在svn上工作，A修改了function1，而b修改了其他内容。
由于python并不在编译时检查类别问题，因此当两人的svn merge后，运行并没有出错。现在，问题只有等上线后客户提出来了。
几乎所有的人都同意，这问题的根源不是一个语言的问题。本质上说，这是一个工作流程问题。即使是C，也只检查参数的个数和类别，对于行为的变化和参数意义的变化还是无能为力的。
1.当你公开了一个函数，并要修改这个函数的外观行为的时候，必须向其他人通告。 2.python代码要通过unittest和黑盒检查覆盖。 3.代码应当cross review。
争论的焦点主要是在python下如何避免这个问题。楼主Zhang Jiawei的观点是使用pydev，加上工具来检查。我，沈崴，ZQ的意见是通过行为来避免这个问题。所谓行为，主要包括以下几个。
1.互相review代码。 2.修改通告。 3.编写无检查和无处理的代码，并大量运行。如果代码中有错，程序会持续崩溃。因此当大量运行程序不崩溃时，代码就无错了。
为什么我们并不推荐使用自动化工具来检测错误呢？主要是因为自动化工具可以*找到*问题，但是却不能*保证*是找到问题最彻底的一种。我举个最简单的例子：
网络工程师A，用了pylint，找到了自己code中的15个低级bug。他很高兴，因为工具使用起来很方便。
A向领导汇报了自己的心得，建议全公司推行这个工具。假定他的领导是项目经理B。
A：这个工具太好了，一下就找出了我15个bug，我发现用这个工具很方便，blahblahblah。
B：恩，很好，过两天你在公司里面讲讲这个工具。对了，你的code review做了么？
A：我用工具查过拉。
B：你确定他找出了你的*所有*bug么？
问题的关键，就是*所有*。我们当然不可能找出程序中的所有bug。我所知的bug最少的程序是TeX，据说在数年的时间内只有数个bug。但是其版本号仍旧是3.1415926——正好是祖率的密率——而不是pi。我们毕竟不敢——高伯伯也不敢——保证没有bug。但是通过cross review，不处理加覆盖性检测，我们可以保证bug出现的概率在某个水平以下。
自动化工具寻找出的bug，是在这个水准以上的。就是说，自动化工具看的出的，人应该看的出。人看的出的，自动化工具不一定看的出。如果做不到这点，说明你的水准还不足。
所以，当我们需要一个尽量无错的code时，当你pydev/pylint，或者其他工具做了检测，问题是否解决了呢？没有，你仍旧需要review来保证没有bug。这样一来，工具的意义在哪里呢？
当然，这并非说在做code review之前，你*不能*去做一遍代码扫描。只是说这样做并*不能替代*对错误的人工控制行为。
除非你的目标是使用最低的成本，将错误减少到一个可接受的规模——而不是最低。就像我们在外包中常做的那样。这种情况下使用工具是比较合适的。
而且一旦使用工具，很多程序员会产生依赖。所谓依赖，并不是讲从逻辑上他们不清楚在代码扫描外还需要独立的人工检测。但是在检测时，心里就会抱有一种放松的心态。尤其是其中某些虫族程序员让人无语叹息的行为。在中国的程序员界，有着诸多非常有创造力的bug提供者。例如擅长用str+=的java网页程序员很常见，这属于常见问题。但是自己写一套字典映射规则以完成数字到字符转换的（就是c下面的itoa）.net程序员真的让我大开眼界——而且他同时犯下了str+=错误。要指望工具修正+=是可以的，要指望工具找出这类极品代码，估计下面会有更极品的人犯下更极品的错误。。。</description>
    </item>
    
    <item>
      <title>专业程序员需要掌握的几种语言</title>
      <link>http://blog.shell909090.org/blog/archives/116/</link>
      <pubDate>Thu, 20 May 2010 18:03:00 +0800</pubDate>
      
      <guid>http://blog.shell909090.org/blog/archives/116/</guid>
      <description>受到这篇文章（http://blog.youxu.info/fyi/21-days/）的启发，我突然想起对我所会的和要学的语言做个分类。确定一下专业的程序员到底需要会多少种语言。
1.系统类。只有C一个，必须学，而且需要在几个系统上编程就要学几次。学习系统类语言需要的是对系统结构和运行原理的了解，因此抽离系统的学习语法/抽象库/代码结构是没有任何意义的。
2.面对对象类。C#,Java等，推荐Java。构架方法优美大气，代码容易修改容易阅读，复用性好。然而做事上架梁叠屋，吃个馒头洗三遍手。可以学习构架方法，千万别学做事方法。
3.一门快速的脚本语言。Python, Php, Perl, Bash，各有特色。实际上如果你有空可以统统学一遍，非常有好处。快速脚本语言的特色就是整合其他代码和已经存在的东西，快速的构建出一个可用的程序。
4.一门语法抽象语言。目前只有Lisp和Scheme，推荐Scheme。这两种语言是在人工智能和符号推理的发展过程中产生的，因此对理解“机器是如何思考的”很有帮助。注意这两种语言的本质就是有限图灵机。
5.汇编。汇编语言种类太多，推荐80x86汇编。熟悉汇编语言对了解硬件和系统如何工作很有帮助，并且为查找系统内部(internal)的错误提供了便利。
按照上面的分类，程序员最少要会五种语言，我假定是C/Java/Python/Scheme/Asm80x86。C++不要学，那个是万恶之源。那么下面列举了我推荐的一些书单，可以由浅而深的学习这些语言。
1.入门，《21天学习C语言》《Dive Into Python》《80x86汇编基础教程》等等，这类书的目地是快速的教会是使用语言和语法。完成这个阶段的程序员可以找一些简单的题目做一下，但还不能独立完成普通程序的编写。
2.简单，《Think In Java》《数据结构与算法（Java语言版）》《设计模式》。这个层面基本涉及了数据结构，设计模式和编程方法。完成这个阶段后，可以找几个实际项目玩一玩了。
3.普通，《操作系统：设计和实现》《Unix系统编程》《windows核心编程》《TCP-IP详解》《Effective C》。这个层面涉及了系统运作原理和细节。完成这个阶段就可以写一些系统工具了。
4.阅读，《Python源码剖析》《深入浅出MFC》《Linux内核完全注释》。这个阶段注重阅读和积累各种代码经验。
5.专家，《计算机程序的构造和解释》《计算机程序设计艺术》《MIT算法导论》《数值算法》。通过前面的学习，普通程序编写应当已经不成问题。这个阶段面对的是将实际问题抽象成数学问题后，试图从数学上进行解决的过程。从此以上，就是数学的领域了。</description>
    </item>
    
    <item>
      <title>关于Java和C&#43;&#43;的一点争论</title>
      <link>http://blog.shell909090.org/blog/archives/353/</link>
      <pubDate>Fri, 26 Jan 2007 07:00:15 +0800</pubDate>
      
      <guid>http://blog.shell909090.org/blog/archives/353/</guid>
      <description>不知道为什么，大家好像都喜欢争来争去。关于Java和C++的优劣不知道听了多少。碰巧我两者都会，怎么说也算是公平了吧。我就大着胆子，比较下两者的情况。
对程序而言，速度不是最终要素。否则我们都应该去用汇编不是？一个程序有六个特性，易学，易用，安全，高效，可变，成本低。然而他们一般都是两两冲突的，好学了，就不好用。强大了，就不好学。安全了，自然要执行很多检查，高效了，自然不安全。针对某个平添优化了，可变性就很差，又不能移植，又不好修改。成本低了，自然什么都差。
往往我们写企业应用的时候，都看重可变，低成本，安全，易用。高效呢？企业有钱买大服务器啊，这样的话效率差的不是太多也能接受。易学呢？企业有钱搞推广培训啊，只要有什么功能就加什么功能，不用考虑学不会。写用户应用的时候，则是看重安全，高效，然后易学易用里面要占据一样。可变呢？用户应用有多大？不行重写一个。低成本呢？这就是比较吊诡的事情了，没有啥经济效益的用户程序，往往是写起来最不怕费时最不管经济效益的。
首先从性能角度来说。也许C++程序员说到这里就得意了，不过先别高兴。如果单论速度，汇编语言还在C之上呢。现在网络上很多人讲C优化好了比汇编快，Java优化好了比C快。听听都要笑掉大牙的。C再怎么快，完成同样的步骤，都需要这些汇编代码。Java再怎么快，完成一个动作，底下C代码也不会少的。所谓Java优化好了能快过C，不过是一个Java高手一门心思搞优化，加上碰到一个C语言白痴而已。
我们先不讨论上面问题，就一般Java程序员和C++程序员而言(注意为啥我没说是C程序员，因为能自称纯C程序员的人要么非常精通语言，不会使用C++特性，要么就根本是个白痴)，Java程序员编写出的代码效率比C++大约慢5倍上下。这个数据是我个人写两个程序，一个运算，一个读取处理，对比出来的。都是没有优化的代码。经过极端的优化后，C++的代码我大概提高了4-8倍的速度。可惜我不是个很好的Java程序员，Java代码的速度大概提升了一倍还不足。就是说，最终C++代码比Java快了将近15倍。
但是C++程序员们先别乐，首先我Java语言并不好，这还不是最终的速度比。其次我牺牲了C++的很多特性。运算上几乎就是在写汇编了，接口都直接用了WIN32SDKAPI。没有移植性，没有可维护性，还需要特殊的技巧，怎么想都是牺牲重大。如果要真的这么追求速度，相信汇编会是更好的选择。我们在速度相差5倍左右的情况下就可以使用C++而不用汇编，为什么不能在速度相差5倍的情况下选择Java呢？
然后我们再看性能的另外一个方面，存储管理。说简单点，就是外围设备吞吐管理和内存管理。这方面上C++也是远远超越了Java。不需要的内存就不要，不必须的吞吐就不吐。C++是门培养人的语言，没有很好的功底是无法驾驭的。C++是门程序员负责一切的语言，任何错误都是程序员的错误。然而对于Java来说，就不必处理复杂而没有意义的内存管理了。假设一个Java程序员需要传一个对象给子函数，他只要传递就可以了。然而如果C++程序员直接传递，那么就会出现参数拷贝过程。不但效率差，还可能出现错误。单单一个参数传递，就有三种方式。传值，传址，引用。又分成四类，静态动态，常量非常量。交叉起来，总共是12种情况，需要量材选用。如此烦琐的管理方式，我们可以想想对于内存来说是很有好处的。嵌入系统中大型程序设计绝对是C的天下。然而这么困难的使用方式，需要多大的人力成本才能做到呢？这明显的违反了低成本的原则。
Java的内存管理从C++的角度看绝对是具有瑕疵的，内存释放了不管，直到没有空间了才收集。然而很多C++程序高手在特殊情况下，会重载operator
new算子。其中的行为就很类似这个，Java只是将特殊情况下的应用放到了一般情况。这样对于速度的后果就是，很多的缓存会被持续的从物理内存中挤压出去，导致磁盘吞吐效率降低。对于Java程序，我猜测提升效率的瓶颈将会在和系统交互以取得最佳的垃圾收集时间上。
下面的论题就可能是C++程序员所不高兴看到的了，安全性和可变性。
就语言来说，用户输入的检查这种安全性是一点意义都没有的。我们所说的基本包括几个方面，非正常用法安全，线程安全，异常过程安全。就语言来说，分为了解释型和编译型。那么怎么区分呢？我这里有个很简单的方法，如果程序本身能被本身修改，就是编译型的，否则是解释型。注意，不是让你修改了磁盘上的源码再运行。这个能力赋予了C++强大的功能，例如修改游戏，检查病毒，都需要这个能力。但是不可否认的，比起无法修改自身的程序，安全性就差太多了。线程安全性上讲，Java的所有对象都是系统管理的，也就很容易的可以管理互斥。用过C++的都知道，C++自身是没有互斥的，全靠系统的函数库或者第三方库支撑。好用不好用不说，无法移植是一定的！最后是异常过程安全，C++的异常过程是很恐怖的。关键在于C++的异常传递有三种办法，传值，传址，引用。而且在异常过程中还又涉及回了内存管理啥的。天啊，要是异常都不能专心处理异常，我还要异常干嘛？
至于可变性，那就更别说了。连处理异常都要小心内存泄露的家伙，你指望在修改代码的时候轻松到哪里去？C++是具备了强大的可变性，然而处于效率考虑，很多增强可变性的东西是选项的。例如RTTI，居然要开编译器选项的说。需要使用可变性就要牺牲性能，而且还要你小心的使用。如果使用不小心，抱歉，你又陷入效率和安全的问题里面去了。
如果你有很好的系统功底，准备往计算机领域发展(注意不是计算领域)。那么C++是门很好的语言，只是非常费时而已。而且建议你学C#，VB或者Java作为第二语言，选择Bash或者Perl作为第三语言。这样在处理问题上可以事半功倍。如果你打算增加自己的计算机能力，方便日常的电脑使用，而不准备深入学习这个领域。那么只学C#，VB或者Java就足够了。
最后要提到的是易学和易用，这两个特性都是软件设计所赋予的。也就是说，即使是以简单著称的VB.NET，也可以写很好用的程序。以复杂著称的汇编，也可以写很友好的界面。这就不在本文的论题以内了。</description>
    </item>
    
    <item>
      <title>JNI试用记</title>
      <link>http://blog.shell909090.org/blog/archives/257/</link>
      <pubDate>Thu, 10 Nov 2005 19:35:19 +0800</pubDate>
      
      <guid>http://blog.shell909090.org/blog/archives/257/</guid>
      <description>近两天要用JIN做数据加密系统，所以特别写了这篇。省得以后忘记，顺便造福大家。   下面是核心编码：   //CTX.java   public abstract class CTX {\ protected byte\[\] state = new byte\[20\];   protected long count;   protected byte\[\] buffer = new byte\[0\]; /\* input buffer \*/   protected byte\[\] PADDING = { -128, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\ 0, 0, 0, 0, 0, 0 };   // 大端点序\ protected static void putChar(byte\[\] b, int off, char val) ;   // 大端点序\ protected static void putLong(byte\[\] b, int off, long val) ;   static {\ System.</description>
    </item>
    
    <item>
      <title>RTD of java</title>
      <link>http://blog.shell909090.org/blog/archives/210/</link>
      <pubDate>Mon, 26 Sep 2005 07:04:12 +0800</pubDate>
      
      <guid>http://blog.shell909090.org/blog/archives/210/</guid>
      <description>Everyone who use VC++ knows that VC++ have a Run Time Debugger in it. And you can watch assemble code of you program or even ofcommon library code. Farther, we use Ollydbg or softice or something like that which is called Run Time Debugger to track the program. Or looking assemble code, enumerate window handles or some other handles, searching stack for something importent like password. In a word, you can do anything you wanna.</description>
    </item>
    
  </channel>
</rss>