<!doctype html>
<html lang="en-us">
  <head>
    <title>VeryCD版电驴(eMule)存在封锁 // Shell&#39;s Home</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.112.5">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Shell Xu" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css" />

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WH8XZZ4WLY"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WH8XZZ4WLY', { 'anonymize_ip': false });
}
</script>

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="VeryCD版电驴(eMule)存在封锁"/>
<meta name="twitter:description" content="eMule是一个GPL程序，所以VeryCD的改版必须公开源码。今天听说VeryCD版有封锁的现象，所以贝壳抓源码来看看。如果大家认为老调重弹的话，不妨把文章拉到最后。
源码从此处下载：http://www.emule.org.cn/download/
最下方链接：http://download.verycd.com/eMule-VeryCD-src.rar
贝壳下到的文件大小13,703,064字节，打包时间2008-09-11。经过贝壳查找，在eMule-VeryCD-srcsrc WordFilter发现两个文件，WordFilter.cpp 2008-03-12 09:57 13374和WordFilter.h 2007-11-20 17:56 1009。仔细阅读里面，发现有以下内容。
void CWordFilter::Init() { HANDLE hFile; DWORD dwRead; int nLen; BOOL bResult; CStringList list; //m_count = 0; CString saaa = thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) &#43; FLITER_FILE; CString sbbb = thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) &#43; FLITER_FILE; // 如果文件目录不对，程序移动一下，到config目录下 added by kernel1983 2006.07.31 if (PathFileExists(thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) &#43; FLITER_FILE)) MoveFile(thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) &#43; FLITER_FILE, thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) &#43; FLITER_FILE); if (!PathFileExists(thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) &#43; FLITER_FILE)) { // 不存在，所有的都过滤 added by kernel1983 2006.08.08 m_filterall = true; return; } // Open file for read hFile = CreateFile(thePrefs."/>

    <meta property="og:title" content="VeryCD版电驴(eMule)存在封锁" />
<meta property="og:description" content="eMule是一个GPL程序，所以VeryCD的改版必须公开源码。今天听说VeryCD版有封锁的现象，所以贝壳抓源码来看看。如果大家认为老调重弹的话，不妨把文章拉到最后。
源码从此处下载：http://www.emule.org.cn/download/
最下方链接：http://download.verycd.com/eMule-VeryCD-src.rar
贝壳下到的文件大小13,703,064字节，打包时间2008-09-11。经过贝壳查找，在eMule-VeryCD-srcsrc WordFilter发现两个文件，WordFilter.cpp 2008-03-12 09:57 13374和WordFilter.h 2007-11-20 17:56 1009。仔细阅读里面，发现有以下内容。
void CWordFilter::Init() { HANDLE hFile; DWORD dwRead; int nLen; BOOL bResult; CStringList list; //m_count = 0; CString saaa = thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) &#43; FLITER_FILE; CString sbbb = thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) &#43; FLITER_FILE; // 如果文件目录不对，程序移动一下，到config目录下 added by kernel1983 2006.07.31 if (PathFileExists(thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) &#43; FLITER_FILE)) MoveFile(thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) &#43; FLITER_FILE, thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) &#43; FLITER_FILE); if (!PathFileExists(thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) &#43; FLITER_FILE)) { // 不存在，所有的都过滤 added by kernel1983 2006.08.08 m_filterall = true; return; } // Open file for read hFile = CreateFile(thePrefs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="//blog.shell909090.org/blog/archives/38/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2008-09-24T17:11:00+08:00" />
<meta property="article:modified_time" content="2008-09-24T17:11:00+08:00" />

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body);
        });
    </script>

<header>

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-eighties.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="//blog.shell909090.org/">/home/shell&#39;s home</a>
      </li>
      

      

    </ul>
  </nav>
</header>


  </head>
  <body>
    <header class="app-header">
      <a href="//blog.shell909090.org/"><img class="app-header-avatar" src="/avatar.jpg" alt="Shell Xu" /></a>
      <span class="app-header-title">Shell&#39;s Home</span>
      <p>贝壳的壳</p>
      <p>Copyright &copy; 2024 Shell Xu - <a href="//blog.shell909090.org/license/">License</a></p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">VeryCD版电驴(eMule)存在封锁</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Sep 24, 2008
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          4 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="//blog.shell909090.org/tags/computer/">computer</a>
              <a class="tag" href="//blog.shell909090.org/tags/emule/">emule</a>
              <a class="tag" href="//blog.shell909090.org/tags/filter/">filter</a>
              <a class="tag" href="//blog.shell909090.org/tags/verycd/">verycd</a>
              <a class="tag" href="//blog.shell909090.org/tags/%E5%B0%81%E9%94%81/">封锁</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>eMule是一个GPL程序，所以VeryCD的改版必须公开源码。今天听说VeryCD版有封锁的现象，所以贝壳抓源码来看看。如果大家认为老调重弹的话，不妨把文章拉到最后。</p>
<p>源码从此处下载：http://www.emule.org.cn/download/</p>
<p>最下方链接：http://download.verycd.com/eMule-VeryCD-src.rar</p>
<p>贝壳下到的文件大小13,703,064字节，打包时间2008-09-11。经过贝壳查找，在eMule-VeryCD-srcsrc WordFilter发现两个文件，WordFilter.cpp 2008-03-12 09:57 13374和WordFilter.h 2007-11-20 17:56 1009。仔细阅读里面，发现有以下内容。</p>
<pre><code>void    CWordFilter::Init()
{
	HANDLE    hFile;
	DWORD    dwRead;
	int        nLen;
	BOOL    bResult;
	CStringList list;

	//m_count = 0;

	CString saaa = thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) + FLITER_FILE;
	CString sbbb = thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) + FLITER_FILE;

	// 如果文件目录不对，程序移动一下，到config目录下 added by kernel1983 2006.07.31
	if (PathFileExists(thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) + FLITER_FILE))
		MoveFile(thePrefs.GetMuleDirectory(EMULE_EXECUTEABLEDIR) + FLITER_FILE, thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) + FLITER_FILE);

	if (!PathFileExists(thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) + FLITER_FILE))
	{
		// 不存在，所有的都过滤 added by kernel1983 2006.08.08
		m_filterall = true;
		return;
	}

	// Open file for read
	hFile = CreateFile(thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) + FLITER_FILE, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	//AddLogLine(false,_T(&quot;:%sn&quot;),thePrefs.GetConfigDir() + FLITER_FILE);
	if(hFile == NULL || hFile == INVALID_HANDLE_VALUE)
	{
		// 读取错误，所有的都过滤 added by kernel1983 2006.08.08
		m_filterall = true;
		return;
	}

	DWORD dwSize = GetFileSize(hFile, NULL);

	TCHAR * pszData = new TCHAR[(dwSize / sizeof(TCHAR)) + 1];            // 申请空间
	bResult = ReadFile(hFile, pszData, dwSize, &amp;amp;dwRead, NULL);        // 读入文件1
	CloseHandle(hFile);
	pszData[(dwSize / sizeof(TCHAR))] = 0;

	if(bResult)
	{
		// 加入解码算法
		{
			std::string tempstr( (char*)pszData + 1 , ((int)dwSize - 1) &amp;gt; 0 ? dwSize -1 : 0 );

			// 查看是否是老格式
			char * pszData_a = (char*) pszData;

			if( pszData_a[0] != 0x15 ) {
				// 老格式，进行转换
				CUnicodeToMultiByte wc2mb( thePrefs.GetMuleDirectory(EMULE_CONFIGDIR) + FLITER_FILE );
				tempstr.assign( (char*)pszData , dwSize );
				InternalBase64::encode2file( tempstr , std::string((LPCSTR)wc2mb , wc2mb.GetLength()) );

				delete [] pszData;
				// 重新载入
				return Init();
			}

			vector vec = InternalBase64::decode( tempstr );
			char * pszt = (char*) pszData;
			for( size_t i = 0; i &amp;lt; vec.size() ; i++ ) {
				pszt[i] = vec[i];
			}
			dwSize = vec.size();
		}

		TCHAR * pszTemp = wcstok(pszData + 1, _T(&quot;rn&quot;));
		while(pszTemp != NULL)
		{
			nLen = wcslen(pszTemp);
			while(pszTemp[nLen - 1] == 't' || pszTemp[nLen - 1] == ' ')
			{
				nLen --;
				pszTemp[nLen] = 0;
			}
			while(*pszTemp == 't' || *pszTemp == ' ')
			{
				pszTemp ++;
				nLen --;
			}
			//AddLogLine(false,_T(&quot;pszTemp:%s&quot;),pszTemp);
			//AddLogLine(false,_T(&quot;nLen:%d&quot;),nLen);
			if(nLen &amp;gt; 0)list.AddTail(pszTemp);
			//if(nLen == 8)AddLogLine(false,_T(&quot;:%d %d %d %d &quot;),((char*)pszTemp)[0],((char*)pszTemp)[1],((char*)pszTemp)[2],((char*)pszTemp)[3]);
			pszTemp = wcstok(NULL, _T(&quot;rn&quot;));
		}
	}

	delete[] pszData;

	m_count = list.GetCount();
	//AddLogLine(false,_T(&quot;m_count:%d&quot;),m_count);

	if(bResult &amp;amp;&amp;amp; m_count &amp;gt; 0)
	{
		m_filterwords = new TCHAR*[m_count+1];
		m_kmpvalue = new int*[m_count+1];
		ZeroMemory(m_filterwords, sizeof(TCHAR *) * m_count);
		ZeroMemory(m_kmpvalue, sizeof(int *) * m_count);
	}

	for(int i = 0; bResult &amp;amp;&amp;amp; (i &amp;lt; m_count); i ++)
	{
		CString s = list.GetAt(list.FindIndex(i));
		s.MakeLower();
		nLen = s.GetLength();
		//AddLogLine(false,_T(&quot;nLen:%d&quot;),nLen);
		m_filterwords[i] = new TCHAR[nLen + 1];
		m_filterwords[i][nLen] = 0;    // 最后一个字节设为0
		m_kmpvalue[i] = new int[nLen];
		//AddLogLine(false,_T(&quot;nLen:%d&quot;),nLen);
		_tcscpy(m_filterwords[i],s);
		//AddLogLine(false,_T(&quot;m_filterwords[i]:%s&quot;),m_filterwords[i]);
		KMP_GetNext(m_filterwords[i], m_kmpvalue[i]);    // 得到一个与内容有关的数值m_kmpvalue[i]
	}

	if(m_count == 0 || !bResult)
	{
		Free();
		//m_filterall = true;
	}
}

bool    CWordFilter::VerifyString(const CString &amp;amp; sString)    // 验证字符是否合法
{
	bool bIsRm = sString.Right(3)==_T(&quot;.rm&quot;);
	CString sReduceString=sString;
	CString sInterpunctionString = _T(&quot;（），().。·；：－《》『』～　“”〓！【】★×┇&quot;);
	try // VC-Huby[2007-03-20]:满足中国国情特色,加强过滤
	{
		int j=0;
		for( int i=0; i&amp;lt; sString.GetLength(); i++ )
		{
			if( sString.GetAt(i)&amp;lt;=_T('/') &amp;amp;&amp;amp; sString.GetAt(i)&amp;gt;=_T(' ') ) //从空格到'/'之间的字符减掉后再过滤
			{
				continue;
			}
			else if( sString.GetAt(i)&amp;lt;=_T('@') &amp;amp;&amp;amp; sString.GetAt(i)&amp;gt;=_T(':') )
			{
				continue;
			}
			else if( sString.GetAt(i)&amp;lt;=_T('`') &amp;amp;&amp;amp; sString.GetAt(i)&amp;gt;=_T('[') )
			{
				continue;
			}
			else if( sString.GetAt(i)&amp;lt;=_T('~') &amp;amp;&amp;amp; sString.GetAt(i)&amp;gt;=_T('{') )
			{
				continue;
			}
			else if( sInterpunctionString.Find(sString.GetAt(i))&amp;gt;=0 )
			{
				continue;
			}
			else
			{
				sReduceString.SetAt(j,sString.GetAt(i));
				j++;
			}
		}
		if( j&amp;lt; sString.GetLength() )
			sReduceString.SetAt(j,_T(''));
	}
	catch (...)
	{
	}

	if(m_filterall){
		//AddLogLine(false,_T(&quot;m_filterall&quot;));
		return true;    // 检测不到文件，或者读取错误的情况下放弃过滤
	}
	if(m_count == 0){
		//AddLogLine(false,_T(&quot;m_count == 0&quot;));
		return true;    // 文件是空的时候，放弃过滤功能
	}
	CString strSearch = ((CString)sReduceString).MakeLower();

	//vc-huby: 过滤中文字符超过15字符
	//CString sReduceString2=strSearch;
	int k=0;
	for( int i=0; i&amp;lt; strSearch.GetLength(); i++ )
	{
		if( strSearch.GetAt(i)&amp;lt;=_T('9') &amp;amp;&amp;amp; strSearch.GetAt(i)&amp;gt;=_T('0') )
		{
			continue;
		}
		if( strSearch.GetAt(i)&amp;lt;=_T('z') &amp;amp;&amp;amp; strSearch.GetAt(i)&amp;gt;=_T('a') )
		{
			continue;
		}
		else
		{
			k++;
		}
	}

	if( k&amp;gt;=20 &amp;amp;&amp;amp; bIsRm )
		return false;
//int m = sReduceString2.GetLength();
/*
  if( k&amp;gt;=60 )
  return false;*/

/*if (strSearch.GetLength() &amp;gt; 20)
  {
  return false;
  }*/

	for(int i = 0; i &amp;lt; m_count; i ++)
	{
		if(KMP_Match(strSearch, m_filterwords[i], m_kmpvalue[i]))
		{
			//AddLogLine(false,_T(&quot;KMP_Match&quot;));
			return false;    // 关键词命中了，被fliter了
		}
	}
	//AddLogLine(false,_T(&quot;漏掉的&quot;));
	return true;

}

void CWordFilter::Free()    //
{
	for(int i = 0; i &amp;lt; m_count; i ++)
	{
		if(m_filterwords[i])
			delete[] m_filterwords[i];
		if(m_kmpvalue[i])
			delete[] m_kmpvalue[i];
	}
	delete[] m_filterwords;
	delete[] m_kmpvalue;
}

CWordFilter::~CWordFilter()
{
	Free();
}
</code></pre>
<p>其中WordFilter.h的第17行有以下定义。</p>
<pre><code>#define FLITER_FILE _T(&quot;wordfilter.txt&quot;)
</code></pre>
<p>于是贝壳查看了C:Program FileseMuleconfig目录，在下面发现了wordfilter.txt 2007-09-30 12:58 10788。大家有兴趣自己看看里面的内容，贝壳就不贴了，贴出来绝对被封，死1090次。</p>
<p>下面说一点起效方式，也许大家很奇怪，这些内容是可以搜索的。贝壳仔细查看了代码，类在两处被引用了，一个是MFC初始化系统的时候初始化类，载入词典。另外一个是在SearchList.cpp 2007-11-20 17:56 22505，351行AddToList函数，第360行，内容如下。</p>
<pre><code>// WordFilter added by kernel1983 2006.07.31
if(!WordFilter.VerifyString(toadd-&amp;gt;GetFileName()))
{
	delete toadd;
	return false;
}
</code></pre>
<p>这个封锁手法尤其狠毒，并非封锁你的搜索，而是如果你的文件信息内有这些关键词，那么文件共享消息就不会被发送到服务器上，如同这个文件没有被共享一样。这样既没有用户会发现被封锁的事实(因为有少量其他客户端的数据会被检索出来)，又能达到封锁的目地。</p>
<p>当然，贝壳理解VeryCD这帮人的苦心，毕竟他们还住在中国，不过估计从此后，贝壳和朋友的机器上不会装VeryCD了。</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
