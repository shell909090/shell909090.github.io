<!doctype html>
<html lang="en-us">
  <head>
    <title>通知时代 // Shell&#39;s Home</title>
    <link rel="shortcut icon" href="/favicon.ico" />
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.112.5">
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Shell Xu" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/css/main.min.3c3c186cd62e563ad6e2f00a89dbee656ab912d1d46f856b5605dd0232521e2a.css" />

    
<script async src="https://www.googletagmanager.com/gtag/js?id=G-WH8XZZ4WLY"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-WH8XZZ4WLY', { 'anonymize_ip': false });
}
</script>

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="通知时代"/>
<meta name="twitter:description" content="以下内容可以说是作为一个时代的预告，请大家见证将来是否按照我的预想进行。
首先请大家想想，当大家上网的时候，都做什么？也许是打游戏，也许是看电影，也许是泡论坛，也许是看好友的blog。随着web2.0时代的到来，我们每个人都有发布自己话语的能力。看上去和上世纪末的主页时代类似，然而不同的是，发布的频率增高了。假定你和我一样，有大约20-50个好友在网络上进场写blog。每个人每月写一篇，那么你每天就有1-2篇blog要看。你喜欢的电视剧有10个，它们每周更新一次，那么你每天就有1-2集电视剧要看。依此类推，你所关心的东西在网络上绝对不缺。每天平均下来都要看3-5篇东西，和几个朋友聊聊最新的生活，看几集电视剧，多好的生活。然而，当前却有个不和谐的问题，你需要持续的检查更新！
按照我们上文举出的数据来推算，如果这个人每天需要看这些东西作为日常的网络活动。那么他就需要检查30-100个页面来确定哪些内容更新了，需要跟踪10-20个页面来确定需要下载的东西。在网络小众的时代，也许这不是个问题。我们的习惯是每天上网，然后收一次邮件，检查书签里面所有的页面，看看是否有更新了。下载最新的东西，把写好的信件发出去。以天为单位来说，这不是一个问题。然而正如在线时间的增长催生了IM来替代Mail一样，长时间的在线使得我们希望简单的获得&quot;第一时间&quot;的东西。邮件到达的时候，我希望&quot;第一时间&quot;的获得。有新闻的时候，我希望&quot;第一时间&quot;的关注。朋友写了blog的时候，我希望&quot;第一时间&quot;的回复。OK，假定5分钟是你可以认可的&quot;第一时间&quot;。那么你需要每5分钟&quot;检查30-100个页面来确定哪些内容更新了，需要跟踪10-20个页面来确定需要下载的东西&quot;。
幸运的是，我们可以使用程序来自动做这些事情，并且现在已经有了部分解决方案。有一种邮件跟踪程序，可以跟踪pop3，hotmail，yahoo等常见的邮箱，检查是否有新的邮件。好友的blog和新闻都可以用rss软件来跟踪是否有新的内容。然而不幸的是，每种解决方案都是单独的。如果你需要持续的跟踪，就必须挂上邮箱的检查程序，rss的检查程序，网页的检查程序(用于部分不支持rss的网页)。不但复杂难以管理而且资源消耗也相当惊人。
我预期将来大家都会持续的挂线，因此预计将来的模型是&quot;通知&quot;而非&quot;检查&quot;。当你有邮件时，会收到邮件到达通知，当你关注的新闻更新时，会收到新闻更新通知。而具体怎么实现呢？我估计是IM系统整合。当今IM界发展的趋势是互通，IM的特点又是即时，因此有很大可能性会是使用IM来通告新的内容到达。你可以向一些支持的网站注册你的IM，而后他们会视图加你为好友，并且向你提供验证号。当你将验证号回复给网站后，你的网站账户(如果需要的话)就和IM绑定在一起。而后你可以主动订阅一些内容主体的更新通知，当网站程序更新这些内容的时候，会读取到你的订阅。而后将内容更新和你的IM发送到一个队列中，这个队列再将这些消息发送到你的IM中。
当然，IM接受这些消息的显示方式很可能不会用通常的消息界面，更可行的界面是类似google
reader的聚合通告界面。当你完成订阅后，你的IM就会将源放到一个通知树中。每个源是一个列表，代表了这个源的内容。例如邮箱源的列表就是邮箱内的邮件，rss源的列表就是rss的新闻，&ldquo;越狱&quot;这种源的列表就是一堆的&quot;越狱&quot;影片下载地址(当然，如果合法的话)。甚至论坛的某个帖子都可以做源。源代表了内容，并且通告变化，而IM则记录了客户是否看过每个源的具体内容。有可能还会出现一些服务网站，负责每一定时间去检测不支持源的页面，如果满足一定的更新条件，那么就通知页面更新了。
通过这种模式，你每天上线后就可以看到没上线时更新的内容，直接点击过去看。并且在线的时候各种需要的消息还会持续的通告过来。当然，你也应该可以(只要客户端支持)设定某种消息会强制的弹出(例如公司的邮箱里面有新邮件)，而某些只是更改托盘区的图标(例如某些有点关心的新闻更新了，你不会希望这个原因把你从游戏里面拉出来吧)。理论上说，当IM的客户端范畴拓展到手机后，我们甚至可以如同宣传中说的一样&quot;随时随地，掌握信息&quot;了。"/>

    <meta property="og:title" content="通知时代" />
<meta property="og:description" content="以下内容可以说是作为一个时代的预告，请大家见证将来是否按照我的预想进行。
首先请大家想想，当大家上网的时候，都做什么？也许是打游戏，也许是看电影，也许是泡论坛，也许是看好友的blog。随着web2.0时代的到来，我们每个人都有发布自己话语的能力。看上去和上世纪末的主页时代类似，然而不同的是，发布的频率增高了。假定你和我一样，有大约20-50个好友在网络上进场写blog。每个人每月写一篇，那么你每天就有1-2篇blog要看。你喜欢的电视剧有10个，它们每周更新一次，那么你每天就有1-2集电视剧要看。依此类推，你所关心的东西在网络上绝对不缺。每天平均下来都要看3-5篇东西，和几个朋友聊聊最新的生活，看几集电视剧，多好的生活。然而，当前却有个不和谐的问题，你需要持续的检查更新！
按照我们上文举出的数据来推算，如果这个人每天需要看这些东西作为日常的网络活动。那么他就需要检查30-100个页面来确定哪些内容更新了，需要跟踪10-20个页面来确定需要下载的东西。在网络小众的时代，也许这不是个问题。我们的习惯是每天上网，然后收一次邮件，检查书签里面所有的页面，看看是否有更新了。下载最新的东西，把写好的信件发出去。以天为单位来说，这不是一个问题。然而正如在线时间的增长催生了IM来替代Mail一样，长时间的在线使得我们希望简单的获得&quot;第一时间&quot;的东西。邮件到达的时候，我希望&quot;第一时间&quot;的获得。有新闻的时候，我希望&quot;第一时间&quot;的关注。朋友写了blog的时候，我希望&quot;第一时间&quot;的回复。OK，假定5分钟是你可以认可的&quot;第一时间&quot;。那么你需要每5分钟&quot;检查30-100个页面来确定哪些内容更新了，需要跟踪10-20个页面来确定需要下载的东西&quot;。
幸运的是，我们可以使用程序来自动做这些事情，并且现在已经有了部分解决方案。有一种邮件跟踪程序，可以跟踪pop3，hotmail，yahoo等常见的邮箱，检查是否有新的邮件。好友的blog和新闻都可以用rss软件来跟踪是否有新的内容。然而不幸的是，每种解决方案都是单独的。如果你需要持续的跟踪，就必须挂上邮箱的检查程序，rss的检查程序，网页的检查程序(用于部分不支持rss的网页)。不但复杂难以管理而且资源消耗也相当惊人。
我预期将来大家都会持续的挂线，因此预计将来的模型是&quot;通知&quot;而非&quot;检查&quot;。当你有邮件时，会收到邮件到达通知，当你关注的新闻更新时，会收到新闻更新通知。而具体怎么实现呢？我估计是IM系统整合。当今IM界发展的趋势是互通，IM的特点又是即时，因此有很大可能性会是使用IM来通告新的内容到达。你可以向一些支持的网站注册你的IM，而后他们会视图加你为好友，并且向你提供验证号。当你将验证号回复给网站后，你的网站账户(如果需要的话)就和IM绑定在一起。而后你可以主动订阅一些内容主体的更新通知，当网站程序更新这些内容的时候，会读取到你的订阅。而后将内容更新和你的IM发送到一个队列中，这个队列再将这些消息发送到你的IM中。
当然，IM接受这些消息的显示方式很可能不会用通常的消息界面，更可行的界面是类似google
reader的聚合通告界面。当你完成订阅后，你的IM就会将源放到一个通知树中。每个源是一个列表，代表了这个源的内容。例如邮箱源的列表就是邮箱内的邮件，rss源的列表就是rss的新闻，&ldquo;越狱&quot;这种源的列表就是一堆的&quot;越狱&quot;影片下载地址(当然，如果合法的话)。甚至论坛的某个帖子都可以做源。源代表了内容，并且通告变化，而IM则记录了客户是否看过每个源的具体内容。有可能还会出现一些服务网站，负责每一定时间去检测不支持源的页面，如果满足一定的更新条件，那么就通知页面更新了。
通过这种模式，你每天上线后就可以看到没上线时更新的内容，直接点击过去看。并且在线的时候各种需要的消息还会持续的通告过来。当然，你也应该可以(只要客户端支持)设定某种消息会强制的弹出(例如公司的邮箱里面有新邮件)，而某些只是更改托盘区的图标(例如某些有点关心的新闻更新了，你不会希望这个原因把你从游戏里面拉出来吧)。理论上说，当IM的客户端范畴拓展到手机后，我们甚至可以如同宣传中说的一样&quot;随时随地，掌握信息&quot;了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="//blog.shell909090.org/blog/archives/428/" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2008-02-21T22:54:36+08:00" />
<meta property="article:modified_time" content="2008-02-21T22:54:36+08:00" />

    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.css" integrity="sha384-D+9gmBxUQogRLqvARvNLmA9hS2x//eK1FhVb9PiU86gmcrBrJAQT8okdJ4LMp2uv" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/katex.min.js" integrity="sha384-483A6DwYfKeDa0Q52fJmxFXkcPCFfnXMoXblOkJ4JcA8zATN6Tm78UNL72AKk+0O" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0-rc.1/dist/contrib/auto-render.min.js" integrity="sha384-yACMu8JWxKzSp/C1YV86pzGiQ/l1YUfE8oPuahJQxzehAjEt2GiQuy/BIvl9KyeF" crossorigin="anonymous"></script>
    <script>
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body);
        });
    </script>

<header>

  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/tomorrow-night-eighties.min.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script>
  <nav>
    <ul>
      
      
      <li class="pull-left ">
        <a href="//blog.shell909090.org/">/home/shell&#39;s home</a>
      </li>
      

      

    </ul>
  </nav>
</header>


  </head>
  <body>
    <header class="app-header">
      <a href="//blog.shell909090.org/"><img class="app-header-avatar" src="/avatar.jpg" alt="Shell Xu" /></a>
      <span class="app-header-title">Shell&#39;s Home</span>
      <p>贝壳的壳</p>
      <p>Copyright &copy; 2024 Shell Xu - <a href="//blog.shell909090.org/license/">License</a></p>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">通知时代</h1>
      <div class="post-meta">
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Feb 21, 2008
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div>
        <div>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <title>tag</title>
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>
</svg>
              <a class="tag" href="//blog.shell909090.org/tags/computer/">computer</a>
        </div>
      </div>
    </header>
    <div class="post-content">
      <p>以下内容可以说是作为一个时代的预告，请大家见证将来是否按照我的预想进行。</p>
<p>首先请大家想想，当大家上网的时候，都做什么？也许是打游戏，也许是看电影，也许是泡论坛，也许是看好友的blog。随着web2.0时代的到来，我们每个人都有发布自己话语的能力。看上去和上世纪末的主页时代类似，然而不同的是，发布的频率增高了。假定你和我一样，有大约20-50个好友在网络上进场写blog。每个人每月写一篇，那么你每天就有1-2篇blog要看。你喜欢的电视剧有10个，它们每周更新一次，那么你每天就有1-2集电视剧要看。依此类推，你所关心的东西在网络上绝对不缺。每天平均下来都要看3-5篇东西，和几个朋友聊聊最新的生活，看几集电视剧，多好的生活。然而，当前却有个不和谐的问题，你需要持续的检查更新！</p>
<p>按照我们上文举出的数据来推算，如果这个人每天需要看这些东西作为日常的网络活动。那么他就需要检查30-100个页面来确定哪些内容更新了，需要跟踪10-20个页面来确定需要下载的东西。在网络小众的时代，也许这不是个问题。我们的习惯是每天上网，然后收一次邮件，检查书签里面所有的页面，看看是否有更新了。下载最新的东西，把写好的信件发出去。以天为单位来说，这不是一个问题。然而正如在线时间的增长催生了IM来替代Mail一样，长时间的在线使得我们希望简单的获得&quot;第一时间&quot;的东西。邮件到达的时候，我希望&quot;第一时间&quot;的获得。有新闻的时候，我希望&quot;第一时间&quot;的关注。朋友写了blog的时候，我希望&quot;第一时间&quot;的回复。OK，假定5分钟是你可以认可的&quot;第一时间&quot;。那么你需要每5分钟&quot;检查30-100个页面来确定哪些内容更新了，需要跟踪10-20个页面来确定需要下载的东西&quot;。</p>
<p>幸运的是，我们可以使用程序来自动做这些事情，并且现在已经有了部分解决方案。有一种邮件跟踪程序，可以跟踪pop3，hotmail，yahoo等常见的邮箱，检查是否有新的邮件。好友的blog和新闻都可以用rss软件来跟踪是否有新的内容。然而不幸的是，每种解决方案都是单独的。如果你需要持续的跟踪，就必须挂上邮箱的检查程序，rss的检查程序，网页的检查程序(用于部分不支持rss的网页)。不但复杂难以管理而且资源消耗也相当惊人。</p>
<p>我预期将来大家都会持续的挂线，因此预计将来的模型是&quot;通知&quot;而非&quot;检查&quot;。当你有邮件时，会收到邮件到达通知，当你关注的新闻更新时，会收到新闻更新通知。而具体怎么实现呢？我估计是IM系统整合。当今IM界发展的趋势是互通，IM的特点又是即时，因此有很大可能性会是使用IM来通告新的内容到达。你可以向一些支持的网站注册你的IM，而后他们会视图加你为好友，并且向你提供验证号。当你将验证号回复给网站后，你的网站账户(如果需要的话)就和IM绑定在一起。而后你可以主动订阅一些内容主体的更新通知，当网站程序更新这些内容的时候，会读取到你的订阅。而后将内容更新和你的IM发送到一个队列中，这个队列再将这些消息发送到你的IM中。</p>
<p>当然，IM接受这些消息的显示方式很可能不会用通常的消息界面，更可行的界面是类似google</p>
<p>reader的聚合通告界面。当你完成订阅后，你的IM就会将源放到一个通知树中。每个源是一个列表，代表了这个源的内容。例如邮箱源的列表就是邮箱内的邮件，rss源的列表就是rss的新闻，&ldquo;越狱&quot;这种源的列表就是一堆的&quot;越狱&quot;影片下载地址(当然，如果合法的话)。甚至论坛的某个帖子都可以做源。源代表了内容，并且通告变化，而IM则记录了客户是否看过每个源的具体内容。有可能还会出现一些服务网站，负责每一定时间去检测不支持源的页面，如果满足一定的更新条件，那么就通知页面更新了。</p>
<p>通过这种模式，你每天上线后就可以看到没上线时更新的内容，直接点击过去看。并且在线的时候各种需要的消息还会持续的通告过来。当然，你也应该可以(只要客户端支持)设定某种消息会强制的弹出(例如公司的邮箱里面有新邮件)，而某些只是更改托盘区的图标(例如某些有点关心的新闻更新了，你不会希望这个原因把你从游戏里面拉出来吧)。理论上说，当IM的客户端范畴拓展到手机后，我们甚至可以如同宣传中说的一样&quot;随时随地，掌握信息&quot;了。</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
